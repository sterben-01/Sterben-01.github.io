---
title: Effective STL 笔记
date: 2022-07-22 01:55:00 -0500
categories: [笔记]
tags: [STL]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true

---

# Effective STL 笔记

## 第二条：不要试图编写独立于容器类型的代码。

STL 是以泛化原则为基础的：

- 数组被泛化为”以其包含的对象的类型为参数“的容器；
- 函数被泛化为”以其使用的迭代器的类型为参数“的算法；
- 指针被泛化为”以其指向的对象的类型为参数“的迭代器；
- 容器被泛化为”序列式和关联式“容器。

**个人理解一句话：别给多个容器写一个通用的函数。没有意义而且效率低下。**

## 第三条：确保容器中的对象副本正确而高效。

- 当(通过如 insert 或 push_back 之类的操作)向容器中加入对象时，存入容器的是你所指定的对象的拷贝。
- 当(通过如front或back之类的操作)从容器中取出一个对象时，你所得到的是容器中所保存的对象的拷贝。

拷贝进来拷贝出去是STL的工作方式

在存在继承关系的情况下，拷贝动作会导致剥离(slicing)。也就是说，如果你创建了一个存放基类对象的容器，却向其中插入派生类的对象，那么在派生类对象(通过基类的拷贝构造函数)被拷贝进容器时，它所特有的部分(即派生类中的信息)将会丢失。”剥离”问题意味着向基类对象的容器中插入派生类对象几乎总是错误的。使拷贝动作高效、正确，并防止剥离问题发生的一个简单办法是使容器包含指针而不是对象。

上一句的例子：

```c++
class Base{
 	//...   
}
class Derived : public Base{
  //...  
};
vector<Base> father; //容器类型为父类对象
Derived child;
father.push_back(child); //子类对象通过基类复制构造函数复制进类型为父类对象的容器时，子类独有的部分会丢失。
```

所以我们为了实现多态，必须是容器保存父类指针。不能是对象也不能是引用。因为指针是一样大的。对象不是一样大的。父类也没办法成为子类引用。

```c++
vector<Base*> father;
Derived* child = new child(); //子类指针指向子类对象
Base* child = new child(); //父类指针指向子类对象两种都可以。
father.push_back(child);
```



## 第四条：调用empty而不是检查size()是否为0。

个人理解：因为比如链表这种，size()需要线性时间查找一遍之后告诉你size。但是empty是O(1)。所以用empty不要用size更快速。



## 第五条：区间成员函数优先于与之对应的单元素成员函数。

个人总结：能用区间函数的就不要使用循环一个一个拷贝。增加效率。尤其是序列容器的头插。一个一个插入到头部会造成大量的拷贝和析构。因为每插入一个，后面的元素都要移动一位。

那么，都有哪些区间成员函数？

- 区间创建函数、insert、erase、assign等。





## 第六条

C++非常煞笔的分析机制。函数和函数指针。加括号不加括号
```c++
// 注意：围绕参数名的括号(比如对f2中d)与独立的括号的区别：围绕参数名的括号被忽略，而独立的括号则表明参数
// 列表的存在：它们说明存在一个函数指针参数
int f1(double d); // 声明了一个带double参数并返回int的函数
int f2(double(d)); // 同上，d两边的括号被忽略,可以给参数名加上圆括号
int f3(double); // 同上，参数名被忽略
 
int g1(double(*pf)()); // 参数是一个指向不带任何参数的函数的指针，该函数返回double值；g1以指向函数的指针为参数
int g2(double pf()); // 同上，pf为隐式指针
int g3(double()); // 同上，省去参数名
```
所以
```c++
list<int> data(istream_iterator<int>(dataFile), istream_iterator<int>());
```

这一行代码的解释是：这声明了一个函数`data`，其返回值是`list<int>`。这个`data`函数有两个参数：

■　第一个参数的名称是`dataFile`。它的类型是`istream_iterator<int>`。`dataFile`两边的括号是多余的，会被忽略。

■　第二个参数没有名称。它的类型是指向不带参数的函数的指针，该函数返回一个`istream_iterator<int>`。

经典错误

```c++
class Widget{
    //...假设Widget有默认构造函数
}
Widget w(); //这是声明了一个名字叫w的函数，该函数没有参数，返回一个Wedget
```



## 第7条：如果容器中包含了通过new操作创建的指针，切记在容器对象析构前将指针delete掉。

```c++

class test;
class myfunc{
    public:
        void operator()(vector<int*>& vec, int p){
            vec.push_back(new int(p)); //新建一个指向int的指针并放入容器。
        }  
};

struct DEL{
    template<typename T>
    void operator()(T* ptr){ //创建删除函数利用foreach释放tt容器内的每一个指针指向的资源
        delete ptr;
        ptr = nullptr;
    }
};



class test{
    public:
    int val;
    test(){}
    test(int x):val(x){};
    void getbug(vector<int>& vec){
        vector<int*> tt; //函数内创建指针容器
        for_each(vec.begin(), vec.end(), bind(myfunc(), ref(tt), placeholders::_1)); //使用foreach和bind。记得传入容器需要加ref
        for_each(tt.begin(), tt.end(), [](int* content){cout <<*content << endl; }); //使用lambda表达式打印tt容器的每一个值。[]捕获列表没有参数因为我们没有用到上下文变量
        for_each(tt.begin(), tt.end(), DEL()); //如果这里不用foreach搭配释放函数释放，那么tt容器在离开函数的时候会被销毁。里面的指针全部都会被移除，但是指向的资源没有释放。导致内存泄漏。因为tt是局部变量。不属于class。
    }
};

int main()
{

    vector<int> rrr = {1,2,3,4,5,6,7};
    test obj;
    obj.getbug(rrr);

}

```

## 第 8 条：切勿创建包含 `auto_ptr` 的容器对象

`auto_ptr` 的容器(简称COAP) 是被禁止的。当你拷贝一个 `auto_ptr` 时，它所指向的对象的所有权被移交到拷入的 `auto_ptr` 上，而它自身被置为` NULL`。如果你的目标是包含智能指针的容器，这并不意味着你要倒霉，包含智能指针的容器是没有问题的。**但 `auto_ptr `非智能指针**。顺带提一句，`auto_ptr`在c++11已被摒弃。应使用`unique_ptr`或`shared_ptr`做替代。

## 第 9 条：慎重选择删除元素的方法

- 要删除容器中有特定值的所有对象：

  - 如果容器是vector、string或deque，则使用erase-remove习惯用法。

      - ```c++
        v.erase(remove(v.begin(), v.end(), VALUE), c.end);
        ```
      
        - 上面这句的要点是。remove仅是移除。他会把把每一个不和指定value相等的元素轮番赋值给first之后的空间。假设现在是112211要移除2，那么remove后应该是长成111111。最后两个数据是脏数据。remove返回的迭代器就指向倒数第二个1，也就是最开始的脏数据。然后erase使用这个迭代器为起点移除所有到结尾位置的数据。因为这一段全都是脏数据。记住，erase后，size改变，capacity不改变。如果需要改变capacity还需要配合swap或匿名对象。
      
  - 如果容器是list，则使用list::remove。
  
  - 如果容器是一个标准关联容器，则使用它的erase成员函数。
  
- 要删除容器中满足特定判别式（条件）的所有对象：

  - 如果容器是vector、string或deque，则使用erase-remove_if习惯用法。
  - 如果容器是list，则使用list::remove_if。
  - 如果容器是一个标准关联容器，则使用remove_copy_if和swap，或者写一个循环来遍历容器中的元素，记住当把迭代器传给erase时，要对它进行后缀递增。防止迭代器失效。

- 要在循环内部做某些（除了删除对象之外的）操作：

  - 如果容器是一个标准序列容器，则写一个循环来遍历容器中的元素，记住每次调用erase时，要用它的返回值更新迭代器。防止迭代器失效。
  - 如果容器是一个标准关联容器，则写一个循环来遍历容器中的元素，记住当把迭代器传给erase时，要对迭代器做后缀递增。防止迭代器失效。

## 第 10 条：了解分配子(allocator)的约定和限制 -- 罄待深入了解

- 你的分配子是一个模板，模板参数T代表你为它分配内存的对象的类型。
- 提供类型定义pointer和reference，但是始终让pointer为T* ，reference为T&。
- 千万别让你的分配子拥有随对象而不同的状态（per-object state）。通常，分配子不应该有非静态的数据成员。
- 记住，传给分配子的allocate成员函数的是那些要求内存的对象的个数，而不是所需的字节数。同时要记住，这些函数返回T* 指针（通过pointer类型定义），即使尚未有T对象被构造出来。
- 一定要提供嵌套的rebind模板，因为标准容器依赖该模板。

- 这里有一点 使用operator new的时候，给的大小是字节数。使用自定义allocator的时候，给的大小是对象的数量。



## 第12条：切勿对STL容器的线程安全性有不切实际的依赖。

对一个STL实现你最多只能期望：

- **多个线程读是安全的** 。多个线程可以同时读同一个容器的内容，并且保证是正确的。自然地，在读的过程中，不能对容器有任何写入操作。
- **多个线程对不同的容器做写入操作是安全的** 。多个线程可以同时对不同的容器做写入操作。

实现完全的容器线程安全性时可能采取的方式：

- 对容器成员函数的每次调用，都锁住容器直到调用结束。
- 在容器所返回的每个迭代器的生存期结束前，都锁住容器（比如通过begin或end调用）。
- 对于作用于容器的每个算法，都锁住该容器，直到算法结束。（实际上这样做没有意义。因为，如同在第32条中解释的，算法无法知道它们所操作的容器。尽管如此，在这里我们仍要讨论这一选择。因为即便这是可能的，我们也会发现这种做法仍不能实现线程安全性，这对于我们的讨论是有益的。）

个人理解：加锁就完事了。

下面的例子是一个不加锁也安全的例子。`vec`虽然是一个容器，但是这个容器里有10个小容器。我开了10个线程给这10个小容器进行多线程同时写入，是安全的。符合要求。也就是所谓的多个线程对不同的容器做写入操作。

```c++
void push(vector<int>& vec){
    for(int j = 0; j < 100; j++){
        vec.push_back(j);
    }
}
int main()
{   
    vector<vector<int>> vec(10, vector<int>());
    thread th[10];
    for(int i = 0; i < 10; i++){
        th[i] = thread(push, ref(vec[i])); //注意，这里是核心。我vec虽然是一个容器，但是我这个容器里有10个小容器。我开了10个线程给这10个小容器进行多线程同时写入，是安全的。符合要求
    }
    for(int i = 0; i < 10; i++){
        th[i].join();
    }
    for(int i = 0; i < 10; i++){
        for(int j = 0; j < vec[i].size(); j++){
            cout << vec[i][j];
        }
        cout<<endl;
    }
    return 0;

}
```

