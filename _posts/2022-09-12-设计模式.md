---
title: 设计模式
date: 2022-12-05 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true
  

---

# 设计模式

# 简单工厂模式

## 流程

- 设计一个抽象产品类，它包含一些产品类公共方法的实现;
- 从抽象产品类中派生出多个具体产品类，如篮球类、足球类、排球类，具体产品类中实现具体产品生产的相关代码;
- 设计一个工厂类，工厂类中提供一个生产各种产品的工厂方法，该方法根据传入参数（产品名称)创建不同的具体产品类对象;。客户只需调用工厂类的工厂方法，并传入具体产品参数，即可得到一个具体产品对象。

## 结构

- 工厂(Factory)︰根据客户提供的具体产品类的参数，创建具体产品实例
- 抽象产品(AbstractProduct):具体产品类的基类，包含创建产品的公共方法。可以做为抽象类（不提供实现）
- 具体产品(ConcreteProduct):抽象产品的派生类，包含具体产品特有的实现方法，是简单工厂模式的创建目标。



## 缺点

每次新增具体产品，不仅要新增具体产品类，而且要更改工厂类。

## 总结

- 简单工厂模式中，工厂只有一个。
  - 工厂生产所有种类的产品
- 工厂类的返回值是一个指向具体产品类的基类指针以满足多态调用。
- 工厂类中依据传入参数来调用对应的具体产品类。
- 抽象产品类可以做为抽象类也可以做为普通类。
- 具体产品类中进行具体产品的实现。



# 工厂方法模式

## 流程

- 设计一个抽象产品类，它包含一些产品类公共方法的实现;
- 从抽象产品类中派生出多个具体产品类，如篮球类、足球类、排球类，具体产品类中实现具体产品生产的相关代码;
- 设计一个抽象工厂类。是所有生产具体产品的工厂类的基类。提供工厂类的公共方法。
- 从抽象工厂类中派生出多个具体工厂类，具体工厂类中提供一个生产特定具体产品的方法，该方法可以返回一个具体产品类对象的指针。
- 使用时声明抽象工厂类指针，new一个具体工厂类的对象。让抽象工厂类指针指向具体工厂类对象。通过该指针调用具体工厂类的生产方法拿到一个指向具体产品类的抽象产品类指针。

## 结构

- 抽象工厂(AbstractFactory):所有生产具体产品的工厂类的基类，提供工厂类的公共方法;
- 具体工厂(ConcreteFactory) : 生产具体的产品
- 抽象产品(AbstractProduct):所有产品的基类，提供产品类的公共方法。
- 具体产品(ConcreteProduct) ︰具体的产品类

## 缺点

虽然我们这次不需要修改具体工厂类，只需要添加具体工厂类即可。但是：

- 这样做增加系统复杂度，因为类的数量变多了。
- 同时，由于工厂和产品都有抽象类，而且调用中也需要拿到对应的抽象类类型的指针，导致增加理解难度。降低代码可读性。

## 总结

- 我们这次拥有了抽象工厂类，这样我们就可以有多个不同的具体工厂类，让每一个工厂类都生产特定类别的具体产品。
- 抽象工厂类是抽象类。不提供具体实现。调用的时候需要声明一个抽象工厂类的指针指向某一个具体工厂
  - 这里的意思是必须要指明我们需要哪种工厂。
- 拿到具体工厂类指针后，可以通过具体工厂类的生产方法得到一个指向具体产品类的抽象产品类指针。
- **工厂方法模式把产品的具体创建过程延迟到了具体工厂类中。**

# 抽象工厂模式

## 和工厂方法模式的区别

抽象工厂和工厂方法非常相似。唯一的区别是：

- 在工厂方法中，我们每一个具体工厂类只能生产一个特定的具体产品。
- 在抽象工厂中，每一个具体工厂可以生产多种同类相关的产品。

## 缺点

- 在已有产品族中添加新产品时需要修改抽象工厂类代码。



# 适配器模式

**此处讲的是对象适配器而不是类适配器**

**类适配器需要多重继承支持。**

## 结构

- Target：目标抽象类
- Adapter：适配器类
- Adaptee：适配者类
- Client：客户类 （可以简化成调用对象）

## 流程：

- 创建target类。这个类是抽象基类。
- 创建adapter类。adapter类新增接口。调用所需的适配者类。
- 客户通过adapter类对象调用adapter类暴露出来的接口。

## 总结：

个人理解：当我们有一个任务需要调用多个类。我们就可以新增一个目标抽象类。然后适配器类继承自该目标抽象类。适配器类负责调用所需的适配者类，**也就是假如我们需要调用ABCDE五个类来完成这个任务。然后五个类关联不是很大，但是想让他们一起工作。我们就可以新增一个类。在这个类里面去调用ABCDE这五个类。我们外部客户只需要调用这个适配器类即可完成任务。**

**适配器模式和外观模式的核心区别**：

- 适配器模式的前提是你无法改变已经既有的类的需求。简单例子就是参数不同，类型不同等。
- 外观模式是你自己设计的时候，想要提供一个整洁一致的（看起来简洁的）接口给调用端。



# 外观模式（facade)

核心的个人理解：一个操作需要调用五个函数，太麻烦了，我们提供统一接口。这个接口内调用五个函数，但是客户只需要调用接口。

核心区别上面写过了。

## 结构

- 一个外观类（接口）
- 一堆你需要调用函数的类。

## 缺点：

- 增加或者减少子系统，必须要修改外观类。违反开闭原则。
- 客户端可以直接与子系统交互。如果加强限制则使系统灵活性降低。





# 观察者模式（Observer）

观察者模式定义：定义对象之间的一种一对多（变化）的依赖关系。以便当一个对象的状态发生改变时，所有依赖他的对象都会得到通知并自动更新。

简而言之就是如果一个对象被改变了，其他所有我们有关联（被注册）的对象都会得到通知并产生对应的行为。

## 结构

- Subject：被观察者的抽象类。
  - 通常这个类会有注册，和取消注册两个方法来进行观察者的管控。也就是控制有多少个对象需要观察这个被观察对象，也就是多少个对象依赖于被观察者。
  - 同时会有一个`notify`函数用于在自身状态改变的时候通知观察者。
- Concrete Subject：被观察者的具体目标类。
  - 通常会实现这个`notify`通知方法。
  - 同时具体目标会拥有自身的属性和成员方法。
- Observer：观察者的抽象类。
  - 通常观察者会接收到观察对象的状态改变消息。所以观察者需要有`update`来在接收到状态改变消息的时候改变自身状态。
- ConcereteObserver：观察者的具体目标类。
  - 通常会实现更新方法`update`。
  - 具体观察者中维护了一个具体目标对象中的引用或指针用来储存目标的状态
- **通常，观察者模式需要使用前向声明。因为有互相包含的关系。**

## 流程

参见代码。过长导致此处放不下。



## 优点

- 观察者模式实现了稳定的消息更新和传递的机制，通过引入抽象层可以扩展不同的具体观察者角色

- **支持广播通信**，所有已注册的观察者（添加到目标列表中的对象）都会得到消息更新的通知，简化了一对多设计的难度

  - 在我们的实例里就是遍历装有观察者的容器。

- **符合开闭原则**，增加新的观察者无需修改已有代码，在具体观察者与观察目标之间不存在关联关系的情况下增加新的观察目标也很方便。

  - 增加新的观察者在我们的示例里面就是被观察者的`join`

  

## 缺点

- **代码中观察者和观察目标相互引用，存在循环依赖**，观察目标会触发二者循环调用，有引起系统崩溃的风险
- 如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会耗费大量时间。
  - 因为要遍历观察者容器内的所有元素。
- 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

## 总结

- 适用场景
  - 一个对象的改变会引起其他对象的联动改变，但并不知道是哪些对象会产生改变以及产生什么样的改变
  - 如果需要设计一个链式触发的系统，可是使用观察者模式
  - 广播通信、消息更新通知等场景。

# 命令模式 （Command）

在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。

**命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系**，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。

举个例子：

- 鼠标点击某个键，就好像用户在向图片浏览器发送指令，图片浏览器内部接收到指令后开始调用相应的函数，最终结果是播放上一张或下一张图片，即执行或响应了用户发出的命令。客户并不知道发出的命令是什么形式，也不知道图片浏览器内部命令是如何执行的;同样，浏览器内部也不知道是谁发送了命令。**命令的发送方和接收方（执行方）没有任何关联。**



## 结构

- Command：抽象命令类
  - 一般只有一个`execute`执行接口。
- ConcreteCommand：具体命令类。
  - 这个类会实现`execute`执行接口。它对应具体的接收者对象。也就是一般来说，每一个对象都会有一个对应的具体命令类。将接收者的动作（action）绑定其中。
  - `execute`执行的就是接受者的动作。
- Invoker：调用者类
  - 请求的发送者。通过命令对象来执行请求。一个调用者不需要在设计时确定接收者。所以调用者通过聚合或注入与命令类产生关联。也就是可以将一个具体命令对象注入到调用者中，再通过调用具体命令对象的`execute`实现间接请求命令执行者（接收者）的操作。
- Receiver：接收者类
  - 一般实现处理请求的具体操作。也就是实现我们命令执行的动作（action）。
- Client：客户类
  - 在我们实例里客户就是`main`

## 流程

较为复杂 参考代码。

## 命令队列模式

有时候，当请求者发送一个请求时，有不止一个接收者产生响应(Qt信号槽，一个信号可以连接多个槽)，这些接收者将逐个执行业务方法，完成对请求的处理，此时可以用命令队列来实现。比如按钮开关同时控制电灯和风扇，这个例子中，请求发送者是按钮开关，有两个接收者产生响应，分别是电灯和风扇。

比如在代码中，我们设置一个命令队列。里面可以储存不同的命令。然后请求者只需要使用一次`touch`（包含命令队列类的execute）就可以执行所有的命令。

执行过程就是请求者使用`touch`调用命令队列类的`execute`，命令队列再依次调用所有具体命令类的`execute`来完成具体执行。



## 优点

- 降低系统的耦合度。
- 新的命令可以很容易地加入到系统中。
- 可以比较容易地设计一个命令队列和宏命令（组合命令）。
- 可以方便地实现对请求的Undo和Redo。

## 缺点

- 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。

## 总结

- 可以看到，客户端只需要有一个调用者和抽象命令类，在给调用者注入命令时，再将命令类具体化。这也就是定义中“可用不同的请求对客户进行参数化"的体现。客户端并不知道命令是如何传递和响应，只需发送命令`touch()`即可，由此实现命令发送者和接收者的解耦。
- 如果系统中增加了新的功能，功能键与新功能对应，只需增加对应的具体命令类，在新的具体命令类中调用新的功能类的`action()`方法，然后将该具体命令类通过注入的方式使调用者可以执行，无需修改原有代码，符合开闭原则。



- 在以下情况下可以使用命令模式：
  - 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。
  - 系统需要在不同的时间指定请求、将请求排队和执行请求。
  - 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。
  - 系统需要将一组操作组合在一起，即支持宏命令
