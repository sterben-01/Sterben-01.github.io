---
title: 设计模式
date: 2022-10-05 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true
  

---

# 设计模式

# 创建型模式部分

创建型模式主要关注与对象的创建。通常这类模式被用于创建对象的时候。比如抽象工厂被用于创建产品族，原型模式被用来模拟更自由的深拷贝等等。

# 简单工厂模式

## 流程

- 设计一个抽象产品类，它包含一些产品类公共方法的实现;
- 从抽象产品类中派生出多个具体产品类，如篮球类、足球类、排球类，具体产品类中实现具体产品生产的相关代码;
- 设计一个工厂类，工厂类中提供一个生产各种产品的工厂方法，该方法根据传入参数（产品名称)创建不同的具体产品类对象;。客户只需调用工厂类的工厂方法，并传入具体产品参数，即可得到一个具体产品对象。

## 结构

- 工厂(Factory)︰根据客户提供的具体产品类的参数，创建具体产品实例
- 抽象产品(AbstractProduct):具体产品类的基类，包含创建产品的公共方法。可以做为抽象类（不提供实现）
- 具体产品(ConcreteProduct):抽象产品的派生类，包含具体产品特有的实现方法，是简单工厂模式的创建目标。



## 缺点

每次新增具体产品，不仅要新增具体产品类，而且要更改工厂类。

## 总结

- 简单工厂模式中，工厂只有一个。
  - 工厂生产所有种类的产品
- 工厂类的返回值是一个指向具体产品类的基类指针以满足多态调用。
- 工厂类中依据传入参数来调用对应的具体产品类。
- 抽象产品类可以做为抽象类也可以做为普通类。
- 具体产品类中进行具体产品的实现。



# 工厂方法模式

代码参考`factory.cpp`

## 流程

- 设计一个抽象产品类，它包含一些产品类公共方法的实现;
- 从抽象产品类中派生出多个具体产品类，如篮球类、足球类、排球类，具体产品类中实现具体产品生产的相关代码;
- 设计一个抽象工厂类。是所有生产具体产品的工厂类的基类。提供工厂类的公共方法。
- 从抽象工厂类中派生出多个具体工厂类，具体工厂类中提供一个生产特定具体产品的方法，该方法可以返回一个具体产品类对象的指针。
- 使用时声明抽象工厂类指针，new一个具体工厂类的对象。让抽象工厂类指针指向具体工厂类对象。通过该指针调用具体工厂类的生产方法拿到一个指向具体产品类的抽象产品类指针。

## 结构

- 抽象工厂(AbstractFactory):所有生产具体产品的工厂类的基类，提供工厂类的公共方法;
- 具体工厂(ConcreteFactory) : 生产具体的产品
- 抽象产品(AbstractProduct):所有产品的基类，提供产品类的公共方法。
- 具体产品(ConcreteProduct) ︰具体的产品类

## 缺点

虽然我们这次不需要修改具体工厂类，只需要添加具体工厂类即可。但是：

- 这样做增加系统复杂度，因为类的数量变多了。
- 同时，由于工厂和产品都有抽象类，而且调用中也需要拿到对应的抽象类类型的指针，导致增加理解难度。降低代码可读性。

## 总结

- 我们这次拥有了抽象工厂类，这样我们就可以有多个不同的具体工厂类，让每一个工厂类都生产特定类别的具体产品。
- 抽象工厂类是抽象类。不提供具体实现。调用的时候需要声明一个抽象工厂类的指针指向某一个具体工厂
  - 这里的意思是必须要指明我们需要哪种工厂。
- 拿到具体工厂类指针后，可以通过具体工厂类的生产方法得到一个指向具体产品类的抽象产品类指针。
- **工厂方法模式把产品的具体创建过程延迟到了具体工厂类中。**

# 抽象工厂模式

代码参考`abstractfactory.cpp`

## 和工厂方法模式的区别

抽象工厂和工厂方法非常相似。唯一的区别是：

- 在工厂方法中，我们每一个具体工厂类只能生产一个特定的具体产品。
- 在抽象工厂中，每一个具体工厂可以生产多种同类相关的产品。也就是一个产品族

在代码中，我们的产品族指的是足球产品族和篮球产品族。每一个产品族包含球和球衣。

也就是说，抽象工厂模式是为了**创建一组（有多类）相关或依赖的对象**提供创建接口，而 工厂模式是为**一类对象**提供创建接口或延迟对象的创建到子类中实现。

## 缺点

这就是所谓的抽象工厂的开闭原则的倾斜性。

- 增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。假设我们新增排球产品族，只需要新增工厂即可。
- 增加新的产品具体内容：对于增加新的产品具体内容，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持“开闭原则”。比如我们现在需要特定的能量饮料，就需要在所有工厂类中新增一个能量饮料的产品。

- 当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品具体内容时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。

## 总结

工厂模式有非常高的自由度。比如可以把工厂写成嵌套类，然后定义一个嵌套类内的静态变量以达到隐藏嵌套工厂类的效果。也更加清晰明确某些类的对象就是必须使用工厂类来创建。也可以把创建方法写成lambda放入容器。总而言之，工厂模式的核心思想就是帮助我们创建对象，管理对象的创建方法，提供一个统一的接口。



# 创建者模式（Builder)

创建者模式最好的解释方法就是看它的名字。实际应用的场景主要是：在某些对象如果有复杂的创建过程的时候，比如可能需要10个构造函数的参数，或者是像是组成一个HTML文件，这个时候让一个类来进行实现就显得非常不雅。**创建者模式的核心就是让复杂对象的创建和表示（展示）分离开来。**在每一个构造中都可以引入参数。

> 在软件开发中，也存在大量类似汽车一样的复杂对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。

或者我们简单理解为，使用不同的配置文件来使得创建的对象具有不同的参数。

## 结构

- 产品（Product）：具体的产品对象
- 抽象建造者（AbstractBuilder）：创建产品（Product）对象的各个部件指定的抽象接口
- 具体建造者（ConcreteBuilder）：实现 抽象建造者（AbstractBuilder）的接口，实现各个部件的具体构造方法和装配方法，并返回创建结果。
- 指挥者（Director）：构建一个使用抽象建造者（AbstractBuilder）接口的对象，安排复杂对象的构建过程，客户端一般只需要与指挥者交互，指定建造者类型，然后通过构造函数或者setter方法将具体建造者对象传入指挥者。它主要作用是隔离客户与对象的生产过程，并负责控制产品对象的生产过程。

## 流程

参考代码`builder.cpp`

注意在我们的代码中，我们选择让抽象建造者管理一个产品对象（利用RAII）。我们也可以选择不让它管理。

## 优点

- 在建造者模式中， **客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。**
- 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， **用户使用不同的具体建造者即可得到不同的产品对象** 。
  - 也就是理解为我们说的 “替换配置文件“
- **可以更加精细地控制产品的创建过程** 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
  - 也就是我们建造中拆分出来的步骤。
- **增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。**
  - 具体建造者只需要更换具体实现，就可以当做“配置文件”传入建造者。**指挥者保有一个抽象建造者。也就是指挥者面向抽象建造者编程。我们会发现指挥者调用的就是抽象建造者的纯虚函数。**

## 缺点

- **建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。**
  - 假如产品的建造模式有大的区别，比如需要更换抽象建造者，则不适用于这种模式。
- 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。

## 总结

- 适用场景：

  - 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。

  - 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。

  - 对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。

  - 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。
- 建造者模式与抽象工厂模式的比较:

  - 抽象工厂模式相比， **建造者模式返回一个组装好的完整产品** ，而 **抽象工厂模式返回一系列相关的产品，这些产品拥有不同的具体内容，构成了一个产品族。**
  - 在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。
  - 如果将抽象工厂模式看成 **汽车配件生产工厂** ，生产一个产品族的产品，那么建造者模式就是一个 **汽车组装工厂** ，通过对部件的组装可以返回一辆完整的汽车。
  - **Builder 模式强调的是一步步创建对象，并通过相同的创建过程可以获得不同的结果对象，一般来说 Builder 模式中对象不是直接返回的。而在 AbstractFactory 模式中对象是直接返回的。**
- 其他技巧：

  - 我们可以增添链式调用以达到fluent builder的效果
  - **我们可以和facade模式结合在一起。参考代码`facade_builder`**

# 原型模式 (Prototype)

定义：

- 使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。

解释：

- 原型模式的工作原理是将一个原型对象传给要发动创建的对象（即客户端对象)，这个要发动创建的对象通过请求原型对象复制自己来实现创建过程。
- 从工厂方法角度而言，创建新对象的工厂就是原型类自己。
- 软件系统中有些对象的创建过程比较复杂，且有时需要频繁创建，原型模式通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象，这就是原型模式的意图所在。

**个人感受：我们通过某一个东西来创建出来一个它的副本。这个看上去很像拷贝构造和拷贝赋值。只不过这个模式是建立在这个基础上的。因为我们可能复制的只是一部分。可以理解为一个支持更加细粒度和更多种类操作的拷贝构造和拷贝赋值。比如拷贝特定部分，替换特定参数等等。**

## 结构

- Abstract Prototype: 抽象原型类
  - 声明一个clone自身的接口
- Concrete Prototype: 具体原型类
  - 实现clone接口
- Client: 客户端类
  - 客户端中声明一个抽象原型类，根据客户需求clone具体原型类对象实例。



## 流程

参考代码。里面设计有点问题。理论上应该直接使用并且返回抽象原型类指针。



## 优点

- 当创建新的对象实例较为复杂时，原型模式可以简化创建过程，提高创建对象的效率;
- 可扩展: 模式中提供了抽象原型类，具体原型类可适当扩展;
- 创建结构简单: 创建工厂即为原型对象本身

## 缺点

- 深克隆代码较为复杂
- 每一个类都得配备一个clone方法，且该方法位于类的内部，修改时违背开闭原则;

## 总结

适用环境：

- 当创建新的对象实例较为复杂时，原型模式可以简化创建过程;
- 结合优点第3条，需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少几个的组合状态，通过复制原型对象得到新实例，比通过使用构造函数创建一个新实例会更加方便。

原型模式可以理解为一个支持更加细粒度和更多种类操作的拷贝构造和拷贝赋值。比如拷贝特定部分，替换特定参数等等。**但是尤其要注意深拷贝和浅拷贝问题。**

### **在多态类中尤其要使用原型模式，或者相似的方法实现拷贝接口。**

因为我们在`vptr`中提到过，如果我们想通过一个父类指针获取指向的子类对象的拷贝，直接解引用调用的拷贝构造是父类的。因为解引用后元素的类型依靠的是静态类型，所以提取出来的元素类型是父类类型的引用。所以此时无法实现多态。因为你会发现`new`一个子类的时候没有一个对应的拷贝构造。所以这时候你只能使用类型转换：

```c++
struct a {
    a() = default;
    virtual void f() {
        cout <<"A" << endl;
    }
    a(const a&) {
        cout << "a copy" << endl;
    }
};

struct b :public a {
    b() = default;
    virtual void f() {
        cout <<"B" << endl;
    }
    b(const b&) {
        cout << "b copy" << endl;
    }
};
int main() {
    a* p = new b;
    a* err = new b(*p); //不可以。因为*p是a&类型。除非你在b新建一个构造函数，如 b(const a&)
    a* p1 = new b(*dynamic_cast<b*>(p)); //只能先转成b。这样会调用b的拷贝构造。输出b copy
    p->f();
    p1->f();
    delete p;
    delete p1;
    return 0;
}
```

如果这时候使用原型模式实现克隆接口就会非常顺畅：

```c++
struct a {
    a() = default;
    virtual void f() {
        cout <<"A" << endl;
    }
    a(const a&) {
        cout << "a copy" << endl;
    }
    virtual a* clone(){ //克隆接口
        return new a;
    }
};

struct b :public a {
    b() = default;
    virtual void f() {
        cout <<"B" << endl;
    }
    b(const a&){
        cout <<"wtf" << endl;
    }
    b(const b&) {
        cout << "b copy" << endl;
    } 
    virtual a* clone(){ //克隆接口
        return new b;
    }
};

int main() {
    a* p = new b;
    a* pclone = p->clone(); //克隆
    p->f();
    pclone->f(); //正确多态

    delete p;
    delete pclone;
    return 0;
}
```





# 结构型模式部分

结构型模式主要是用于设计更合理的API。也就是如何组织整个代码的结构。比如类的组织，继承，包含。哪些接口应该开放，对谁开放。这一部分中，很多模式是一种对底层类接口的包装。目的是简化使用，隐藏具体细节等等。

# 适配器模式 (Adapter)

- 类适配器中，适配器类通过继承适配者类，并重新实现适配者的具体接口来达到适配客户所需要的接口的目的。
  - 从图中我们可以看到，类适配器不仅要继承自目标抽象类，同时也要继承自所有的适配者类。所以类适配器需要多重继承的支持。所以如Java就不适用于这种方式。
- 对象适配器中，适配器类通过在类中实例化一个适配者类的对象，并将其封装在客户所需功能的接口里，达到最终的适配目的。
  - 我们的代码是对象适配器。

![QQ截图20230320011708](/assets/blog_res/2022-09-12-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/QQ%E6%88%AA%E5%9B%BE20230320011708.png)

## 结构

- Target：目标抽象类
- Adapter：适配器类
- Adaptee：适配者类
- Client：客户类 （可以简化成调用对象）

## 流程：

- 创建target类。这个类是抽象基类。
- 创建adapter类。adapter类新增接口。调用所需的适配者类。
- 客户通过adapter类对象调用adapter类暴露出来的接口。

## 总结：

个人理解：当我们有一个任务需要调用多个类。我们就可以新增一个目标抽象类。然后适配器类继承自该目标抽象类。适配器类负责调用所需的适配者类，**也就是假如我们需要调用ABCDE五个类来完成这个任务。然后五个类关联不是很大，但是想让他们一起工作。我们就可以新增一个类。在这个类里面去调用ABCDE这五个类。我们外部客户只需要调用这个适配器类即可完成任务。**

**适配器模式和外观模式的核心区别**：

- 适配器模式的前提是你无法改变已经既有的类的需求。简单例子就是参数不同，类型不同等。
  - 也就是适用于**想使用一个已经存在了的接口，而这个接口却不符合你的需求，此时就可以考虑使用适配器模式。**所以是**事后设计（擦屁股）**
  - **适配器模式的核心是转换。也就是包了一层的wrapper**

- 外观模式是你自己设计的时候，想要提供一个整洁一致的（看起来简洁的）接口给调用端。**强调是事前设计**。
  - **外观模式的核心是提供统一接口给客户端。注意是提供给客户端。**

# 外观模式（Facade)

核心的个人理解：一个操作需要调用五个函数，太麻烦了，我们提供统一接口。这个接口内调用五个函数，但是客户只需要调用接口。

核心区别上面写过了。

## 结构

- 一个外观类（接口）
- 一堆你需要调用函数的类。

## 缺点：

- 增加或者减少子系统，必须要修改外观类。违反开闭原则。
- 客户端可以直接与子系统交互。如果加强限制则使系统灵活性降低。

## 总结

- **不要试图通过外观类为子系统增加新行为**
  - 不要通过继承一个外观类在子系统中加入新的行为，这种做法是错误的。**外观模式的用意是为子系统提供一个集中化和简化的沟通渠道，而不是向子系统加入新的行为**，新的行为的增加应该通过修改原有子系统类或增加新的子系统类来实现，不能通过外观类来实现。
- 可以考虑新增抽象外观类来一定程度上缓解违背开闭原则的情况。
- 在一个系统中，通常情况下，一个外观类只需要一个实例。所以可以考虑将其实现为单例。当然这并不意味着在整个系统里只能有一个外观类，在一个系统中可以设计多个外观类，每个外观类都负责和一些特定的子系统交互，向用户提供相应的业务功能。

# 享元模式 (Flyweight)

**细粒度对象的大面积复用。Flyweight 模式在实现过程中主要是要为共享对象提供一个存放的“仓库”（对象（享元）池）**

- 如果一个系统在运行时创建太多相同或者相似的对象，会占用大量内存和资源，降低系统性能。享元模式通过共享技术实现相同或相似的细粒度对象的复用，提供一个享元池存储已经创建好的对象，并通过享元工厂类将享元对象提供给客户端使用。
- 运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。
- 例子1：我们有一万颗树。但是这些树的纹理，叶子的种类等等只有那么固定的几种，变化的部分不过是位置，和具体使用的种类而已。
- 例子2：围棋只有两种颜色。棋子与棋子之间的区别除了颜色和位置，没什么不同。也就是说，每个棋子对象的大部分状态都是一样的（形状、材料、质地等）。如果我们要设计一个程序来实现下围棋的功能，该如何来创建或者表示这上百个棋子对象呢?

## 结构

![QQ截图20230324145947](/assets/blog_res/2022-09-12-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/QQ%E6%88%AA%E5%9B%BE20230324145947.png)

- FlyWeight： 抽象享元类
  - 声明了具体享元类的公共方法。比如提供内部状态数据（比如例子里的名字）和设置（注入）外部状态（比如例子里的端口和IP）。
- ConcreteFlyWeight: 共享具体享元类
  - 里面会含有一些具体享元类中应有的数据和方法。为内部状态提供存储空间。比如例子中的具体享元类自己的名字。
  - 一般情况下每个享元类对象只应被创建一次。所以应该是单例模式。但是例子中的代码懒得写单例了。

- UnsharedConcreteFlyweight: 非共享具体享元类
  - 不是所有抽象享元类的子类都需要被共享。可以把不全部共享的子类设计为非共享具体享元类。

- FlyweightFactory: 享元工厂类
  - **创建并管理具体享元对象**。将各种具体享元类对象储存在一个享元池中。享元池一般设计为一个储存键值对的容器。可以结合工厂模式设计。客户需要某个享元对象时，如果已有该实例，则直接返回该实例。如果没有该实例，则新建一个实例然后返回给客户，同时**放入享元池**。


## 流程

具体参考代码。

## 优点

- 享元模式的优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。
- 享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。



## 缺点

- 享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。
- 为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。



## 总结

**在以下情况下可以使用享元模式：**

- 一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费。
- 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。
- 使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。

- 享元模式在编辑器软件中大量使用，如在一个文档中多次出现相同的图片，则只需要创建一个图片对象，通过在应用程序中设置该图片出现的位置，可以实现该图片在不同地方多次重复显示。

**单纯享元模式和复合享元模式**

- 单纯享元模式：在单纯享元模式中，所有的享元对象都是可以共享的，即所有抽象享元类的子类都可共享，不存在非共享具体享元类。
- 复合享元模式：将一些单纯享元使用组合模式加以组合，可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。

**享元模式与其他模式的联用**

- 在享元模式的享元工厂类中通常提供一个静态的工厂方法用于返回享元对象，使用简单工厂模式来生成享元对象。
- 在一个系统中，通常只有唯一一个享元工厂，因此享元工厂类可以使用单例模式进行设计。
- 享元模式可以结合组合模式形成复合享元模式，统一对享元对象设置外部状态。



# 桥接模式（bridge）

桥接模式简而言之就是两个独立的继承体系，通过“桥接”的方式结合在一起。

第一个例子： 

设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：

- 第一种设计方案是为每一种形状都提供一套各种颜色的版本。
- 第二种设计方案是根据实际需要对形状和颜色进行组合

对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。

第二个例子：

设想如果有两台手机，我们至少需要2个形状类，但是如果手机需要具有不同的应用程序，此时至少有如下两种设计方案：

- 第一种设计方案是为每一台手机都提供一套安装了各个程序的版本。
- 第二种设计方案是根据实际需要对手机和程序进行组合

**桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。**

## 结构

![QQ截图20230216032436](/assets/blog_res/2022-09-12-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/QQ%E6%88%AA%E5%9B%BE20230216032436.png)



通过这张图我们能非常清楚地看到两个独立的继承体系通过桥接方式组合在一起。

- **Abstraction(抽象类)**︰定义抽象类的接口（抽象接口)，由聚合关系可知，**抽象类中包含一个Implementor类型的对象**，它与Implementor之间有**关联关系**，既可以包含抽象业务方法，也可以包含具体业务方法;

- **lmplementor(实现类接口)**︰定义实现类的接口，这个接口可以与Abstraction类的接口不同一般而言，实现类接口只定义基本操作，而抽象类的接口还可能会做更多复杂的操作。

- **RefinedAbstraction (扩充抽象类)**︰具体类，实现在抽象类中定义的接口，可以调用在lmplementor中定义的方法;

- **Concretelmplementor(具体实现类)**︰具体实现了Implementor接口，在不同的具体实现类中实现不同的具体操作。运行时Concretelmplementor将替换父类。

  


**简言之，在Abstraction类中维护一个Implementor类指针，需要采用不同的实现方式的时候只需要传入不同的Implementor派生类就可以了。**



## 流程

查看代码。

## 优点

- **分离抽象接口与实现部分**，使用对象间的关联关系使抽象与实现解耦;
- **桥接模式可以取代多层继承关系**，多层继承违背单一职责原则，不利于代码复用;
- **桥接模式提高了系统可扩展性**，某个维度需要扩展只需增加实现类接口或者具体实现类，而且不影响另一个维度，符合开闭原则。

## 缺点

- 桥接模式难以理解，因为关联关系建立在抽象层，需要一开始就设计抽象层
- 如何准确识别系统中的两个维度是应用桥接模式的难点。

## 总结

个人感受这个东西非常像一种组合。但是注意不是组合模式。这是两个不同的东西。重点需要理解如何将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化。

- 抽象化：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。
- 实现化：针对抽象化给出的具体实现，就是实现化，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。
- 脱耦：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。

**在以下情况下可以使用桥接模式：**

- 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。
- 抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。
- 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。
- 虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。
- 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。

**适配器模式与桥接模式的联用:**

- 桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。
  - 换句话说，类无法协同工作的意思是各个类的所需的参数之类的都不同，很难组合到一起工作，就可以使用适配器模式，给这些类外面包一层。

**所以我们看到，两个不同的类，抽象和实现可以沿着自己的维度独立的变化。**



# 装饰模式 （Decorator）

装饰模式的核心思想是：不通过继承，而是通过组合的方式来进行对象功能的扩展。

## 结构

![QQ截图20230321050649](/assets/blog_res/2022-09-12-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/QQ%E6%88%AA%E5%9B%BE20230321050649.png)

- Component（抽象构件）︰是具体构件类和装饰类的共同基类，声明了在具体构件中定义的方法，客户端可以一致的对待使用装饰前后的对象
-  ConcreteComponent（具体构件）︰具体构件定义了构件具体的方法，装饰类可以给它增加更多的功能;
-  Decorator（抽象装饰类）∶用于给具体构件增加职责，但具体职责在其子类中实现。**抽象装饰类通过聚合关系蕴含一个抽象构件的对象，通过该对象可以调用装饰之前构件的方法，并通过其子类扩展该方法，达到装饰的目的**;
- ConcreteDecorator（具体装饰类）︰向构件增加新的功能。

例子就是我们假设现在有手机，我们需要给手机贴膜，加手机壳，加挂绳。我们如果不通过继承的方式而是通过组合的方式实现就可以使用装饰模式。

在这里我们的代码中，手机和抽象装饰类共同继承抽象构件接口。同时，抽象装饰类保有一个抽象构件的对象。为什么既要继承又要包含呢？查看我们的项目代码`decorate.cpp`，我们发现在main中，我们的每一个指针，无论是语义上的具体构件，还是具体装饰类，我们统一赋值给了抽象构件类。

-  这样做的第一个好处是我们可以把装饰器类的指针当成`component`的指针。也就是把装饰器对象当做一个`component`对象去使用。比较符合语义。

-  第二点是，不继承的话不符合链式装饰语义。因为每一个具体装饰器类都是接受`component`来构造。

而链式装饰要求把每一个装饰过的装饰器指针当做`component`传入。如果不继承`component`的话，无法当做`component`传入。因为没有多态性。比如115行的`Decorator *PhoneRope = new DecoratorRope(PhoneSticker2);`。这是一种递归的函数调用。每次我们先`getComponent`，所以先拿到贴纸的装饰器对象，然后调用对应的函数调用运算符。然后在里面继续拿，拿到了手机壳的装饰器对象，然后继续调用对应的函数调用运算符，直到拿到了`component`类对象，这时候不拿了，直接调用。然后再依次弹出。



## 和模板结合以产生静态装饰

我们有没有发现上面的模式有一个缺点？因为具体构件和抽象装饰类都是继承自抽象构件。所以说他们俩的共同接口就是抽象构建提供的几个接口。假设具体构件有一些自己独特的函数，我们应该怎么做？**可以采用`Mixin`方法**搭配完美转发。这个例子有点复杂并且和我们上面的例子不太一样。因为使用了`Mixin`，所以抽象装饰类不见了。每一个具体装饰类都继承自模板参数`T`，而且这个`T`不再是抽象构件，而是具体构件了。因为我们不再依赖于接口的动态。改为依赖模板的静态了。同时，由于我们继承的是`T`类，也就是具体构件，所以我们必须使用完美转发来直接调用`T`类的构造函数。同时，如果我们的具体装饰类有一些自己的参数需要传入，也很方便实现，只需要拆分可变参数就可以了。

## 优点

- 装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。
- 可以通过一种**动态的方式来扩展一个对象的功能**，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。
- **通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，也就是堆一个对象进行多次装饰以得到功能更为强大的对象。**
- **具体构件类与具体装饰类可以独立变化**，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，**符合“开闭原则”**

## 缺点

- 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。
- 这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。



 ## 总结

- 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
- 需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。
- 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）.
- 一个装饰类的接口必须与被装饰类的接口保持相同，对于客户端来说无论是装饰之前的对象还是装饰之后的对象都可以一致对待。
- 尽量保持具体构件类Component作为一个“轻”类，也就是说不要把太多的逻辑和状态放在具体构件类中，可以通过装饰类

对其进行扩展。 - 如果只有一个具体构件类而没有抽象构件类，那么抽象装饰类可以作为具体构件类的直接子类。



# 组合模式  (Composite)

组合模式的核心在于解决**树状组合结构的管理**。

## 结构

![QQ截图20230323000818](/assets/blog_res/2022-09-12-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/QQ%E6%88%AA%E5%9B%BE20230323000818.png)

- Component（抽象构件）: Component是一个抽象类，定义了构件的一些公共接口，这些接口是管理或者访问它的子构件的方法(如果有子构件)，具体的实现在叶子构件和容器构件中进行。
- Leaf（叶子构件）︰它代表树形结构中的叶子节点对象，叶**子构件本身在一般情况下没有子节点，它是我们需要通过树状组织来管理的具体节点**。叶子构件它实现了在抽象构件中定义的行为。对于抽象构件定义的管理子构件的方法，叶子构件可以通过抛出异常、提示错误等方式进行处理。
- Composite（容器构件）︰容器构件在一方面具体实现公共接口，另一方面通过聚合关系包含子构件，子构件可以是容器构件，也可以是叶子构件。**也就是说，容器构件一般来说会有一个`vector`或其他的容器来储存所有的`Component*/&`对象。因为容器构件本身也继承自`Component`，所以容器构件可以包含容器构件，形成一种嵌套，也就是树状的关系。**



**之所以区分安全组合模式和透明组合模式，是因为叶子构件不应该具有如添加，移除，获得叶子结点的操作。透明模式的优点是可以通过抽象构件接口获知全部动作，客户端可以一致的对待所有对象。缺点是可能会无意间调用叶子构件类的几个不应提供的函数。所以需要妥善处理。**

**而安全组合模式中，我们就不能通过抽象构件接口获知全部动作，客户端就要进行区别对待。尽管较为安全，但是不够透明。**

## 优点

- 清楚地定义分层次的复杂对象，表示出复杂对象的层次结构，让客户端忽略层次的差异。
- 客户端可以一致地使用层次结构中各个层次的对象，而不必关心其具体构件的行为如何实现。
- 在组合模式中增加新的叶子构件和容器构件非常方便，易于扩展，符合开闭原则。
- 为树形结构的案例提供了解决方案。

## 缺点

- **子构件或容器构件的行为受限制，因为它们来自相同的抽象层**。如果要定义某个容器或者某个叶子节点特有的方法，那么要求在运行时判断对象类型，增加了代码的复杂度。
  - **此处可以使用CRTP方法来实现所谓的定义某个容器或叶子结点特有的方法。**



## 技巧

有时候我们可以把单个对象当成一个组合（容器对待），方法就是提供`begin()`和`end()`函数。

具体实现可以像是这样：

```c++
Foo* begin(){
    return this;
}
Foo* end(){
    return this+1;
}
```

这样，这个单个对象会表现的和含有一个对象的容器一样。

## 总结

组合模式的核心在于解决**树状组合结构的管理**。在系统中需要用到树形结构和系统中能够分离出容器节点和叶子节点的时候比较适合使用。在具有整体和部门的层次结构中，能够通过某种方式忽略层次差异，使得客户端可以一致对待。

**组合模式通过和装饰模式有着类似的结构图，但是组合模式旨在构造类，而装饰模式重在不生成子类即可给对象添加职责。装饰模式重在修饰，而组合模式重在表示**



# 行为型模式部分

行为型模式每一种都不太一样，尽管有一些之间可能长得比较像，但是行为型模式每一种都是有针对性的，它们有针对性地解决某一种特定的问题。行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。

# 命令模式 （Command）

在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。

**命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系**，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。

举个例子：

- 鼠标点击某个键，就好像用户在向图片浏览器发送指令，图片浏览器内部接收到指令后开始调用相应的函数，最终结果是播放上一张或下一张图片，即执行或响应了用户发出的命令。客户并不知道发出的命令是什么形式，也不知道图片浏览器内部命令是如何执行的;同样，浏览器内部也不知道是谁发送了命令。**命令的发送方和接收方（执行方）没有任何关联。**

## 结构

- Command：抽象命令类
  - 一般只有一个`execute`执行接口。
- ConcreteCommand：具体命令类。
  - 这个类会实现`execute`执行接口。它对应具体的接收者对象。也就是一般来说，每一个对象都会有一个对应的具体命令类。将接收者的动作（action）绑定其中。
  - `execute`执行的就是接受者的动作。
- Invoker：调用者类
  - 请求的发送者。通过命令对象来执行请求。一个调用者不需要在设计时确定接收者。所以调用者通过聚合或注入与命令类产生关联。也就是可以将一个具体命令对象注入到调用者中，再通过调用具体命令对象的`execute`实现间接请求命令执行者（接收者）的操作。
- Receiver：接收者类
  - 一般实现处理请求的具体操作。也就是实现我们命令执行的动作（action）。
- Client：客户类
  - 在我们实例里客户就是`main`

## 流程

较为复杂 参考代码。

## 命令队列模式

有时候，当请求者发送一个请求时，有不止一个接收者产生响应(Qt信号槽，一个信号可以连接多个槽)，这些接收者将逐个执行业务方法，完成对请求的处理，此时可以用命令队列来实现。比如按钮开关同时控制电灯和风扇，这个例子中，请求发送者是按钮开关，有两个接收者产生响应，分别是电灯和风扇。

比如在代码中，我们设置一个命令队列。里面可以储存不同的命令。然后请求者只需要使用一次`touch`（包含命令队列类的execute）就可以执行所有的命令。

执行过程就是请求者使用`touch`调用命令队列类的`execute`，命令队列再依次调用所有具体命令类的`execute`来完成具体执行。



## 优点

- 降低系统的耦合度。
- 新的命令可以很容易地加入到系统中。
- 可以比较容易地设计一个命令队列和宏命令（组合命令）。
- 可以方便地实现对请求的Undo和Redo。

## 缺点

- 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。

## 总结

- 可以看到，客户端只需要有一个调用者和抽象命令类，在给调用者注入命令时，再将命令类具体化。这也就是定义中“可用不同的请求对客户进行参数化"的体现。客户端并不知道命令是如何传递和响应，只需发送命令`touch()`即可，由此实现命令发送者和接收者的解耦。
- 如果系统中增加了新的功能，功能键与新功能对应，只需增加对应的具体命令类，在新的具体命令类中调用新的功能类的`action()`方法，然后将该具体命令类通过注入的方式使调用者可以执行，无需修改原有代码，符合开闭原则。



- 在以下情况下可以使用命令模式：
  - 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。
  - 系统需要在不同的时间指定请求、将请求排队和执行请求。
  - 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。
  - 系统需要将一组操作组合在一起，即支持宏命令



# 状态模式 (State)

**个人理解就是把状态机换成了OOP。**

状态模式将一个对象的状态从对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变
化。对于客户端而言，无需天心刈家转念的戌换以人NR-，象，客户端都可以一致处理。

状态模式定义:

- 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

## 结构

- Context: 上下文类
  - 是拥有多种状态的对象。上下文类的状态存在多样性，并且在不同的状态下，对象表现出不同的行为。**在上下文类中，维护了一个抽象状态类的实例。**
- State：抽象状态类
  - 声明了一个接口，用于封装与在上下文类中的一个特定状态相关的行为在子类中实现在各种不同状态对应的方法。不同的子类可能存在不同的实现方法，相同的方法可以写在抽象状态类中。
- ConcreteState：具体状态类
  - 实现具体状态下的方法。每一个具体状态类对应一个具体的状态。
- **值得注意的是，上下文中维护了一个状态类的指针或者引用，可以由上下文类来决定具体实例化为哪一个具体的状态对象，也可以由具体的状态类来决定转换为哪一个实例，所以，上下文类和状态类之间存在依赖甚至相互引用的关系**

## 流程

搭配代码理解下面内容。

- 这段代码的宗旨是，在使用账户游玩游戏的时候，账户等级随着输赢变化。等级不同又会有不同的游玩技能。
- 所以我们账户内部需要有一个等级的实例。然后通过这个等级去调用不同等级的方法。多态可以天然完成这个行为。
- 每一次在给账户类设置新的等级实例的时候，需要记得回收旧的等级实例的内存。
- 等级类也有一个指向账户的指针用于获取账户信息。每次初始化等级实例的时候都需要设置账户。
- 每次升级的时候，先在等级类的构造函数内把新的等级类和账户类绑定，然后把当前帐户的等级类设置为新的等级类。

- **上面的代码不管我们账户当前是什么级别，都统一地调用了上下文类封装好的方法`playcard()`，即外界并不知道不同级别内部的具体实现细节。运行结果显示，账户的在不同的状态(级别)下能够表现不同的行为(不同的技能)，并且能够不断改变自身的状态(升级或降级)。**

## 优点

- 封装了转换规则。
- 枚举可能的状态，在枚举状态之前需要确定状态种类。
- 将所有与某个状态有关的行为放到一个类（具体状态类）中，可以方便地增加新的状态，只需要注入（依赖）不同的状态类对象到上下文类中，即可使上下文类拥有不同的行为。
- 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。

## 缺点

- 状态模式增加了系统中类的个数（不同的具体状态类)。
- 结构相对复杂（如前述实例的UML图)，代码逻辑也较复杂。
- 如果要增加新的状态，需要修改负责状态转换的代码，不符合开闭原则。
  - 如上述实例，如果增加了一个中间级别，就要修改很多状态转换的逻辑

## 总结

对开闭原则不太友好。个人理解为适用于if else状态非常多的场景。比如HTTP报文解析，TCP链接等。这种场景下一般很少去修改或增删新的状态了。

适用环境：

- 对象的行为根据它的状态的改变而不同
- 代码中含有大量与对象状态有关的判断逻辑(if else或switch case)





# 观察者模式（Observer）

观察者模式定义：定义对象之间的一种一对多（变化）的依赖关系。以便当一个对象的状态发生改变时，所有依赖他的对象都会得到通知并自动更新。

简而言之就是如果一个对象被改变了，其他所有我们有关联（被注册）的对象都会得到通知并产生对应的行为。

## 结构

- Subject：被观察者的抽象类。
  - 通常这个类会有注册，和取消注册两个方法来进行观察者的管控。也就是控制有多少个对象需要观察这个被观察对象，也就是多少个对象依赖于被观察者。
  - 同时会有一个`notify`函数用于在自身状态改变的时候通知观察者。
- Concrete Subject：被观察者的具体目标类。
  - 通常会实现这个`notify`通知方法。
  - 同时具体目标会拥有自身的属性和成员方法。
- Observer：观察者的抽象类。
  - 通常观察者会接收到观察对象的状态改变消息。所以观察者需要有`update`来在接收到状态改变消息的时候改变自身状态。
- ConcereteObserver：观察者的具体目标类。
  - 通常会实现更新方法`update`。
  - 具体观察者中维护了一个具体目标对象中的引用或指针用来储存目标的状态
- **通常，观察者模式需要使用前向声明。因为有互相包含的关系。**

## 流程

参见代码。过长导致此处放不下。



## 优点

- 观察者模式实现了稳定的消息更新和传递的机制，通过引入抽象层可以扩展不同的具体观察者角色

- **支持广播通信**，所有已注册的观察者（添加到目标列表中的对象）都会得到消息更新的通知，简化了一对多设计的难度

  - 在我们的实例里就是遍历装有观察者的容器。

- **符合开闭原则**，增加新的观察者无需修改已有代码，在具体观察者与观察目标之间不存在关联关系的情况下增加新的观察目标也很方便。

  - 增加新的观察者在我们的示例里面就是被观察者的`join`

  

## 缺点

- **代码中观察者和观察目标相互引用，存在循环依赖**，观察目标会触发二者循环调用，有引起系统崩溃的风险
- 如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会耗费大量时间。
  - 因为要遍历观察者容器内的所有元素。
- 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

## 总结

- 适用场景
  - 一个对象的改变会引起其他对象的联动改变，但并不知道是哪些对象会产生改变以及产生什么样的改变
  - 如果需要设计一个链式触发的系统，可是使用观察者模式
  - 广播通信、消息更新通知等场景。
  - **成就系统**





# 类型擦除

https://www.youtube.com/watch?v=4eeESJQk-mw

- 类型擦除有五种：多态，模板，容器，通用类型，闭包。


https://zhuanlan.zhihu.com/p/99532906

- 我们有最经典的C风格类型擦除。就是全都转换成`void*`。但是它类型不安全。

- 什么是类型擦除？我们从生活例子说起。

我们有shape类，然后有circle和square继承自shape。很合理对吧？

然后针对每一个子类，都要有一个draw。所以draw是虚函数。很合理对吧？

问题来了。不同的引擎要用不同的方式draw。所以我们要有metaldraw，opengldraw。所以我们要为每一个draw设计为一个单独的类。这样就会有metalcircle， openglcircle， metalsquare， openglsquare。每一个类有一个自己的draw。

这时候我们不仅仅要画了，还要序列化。而这个序列化是要依赖于我们的四个子类的。这时候有Aserializeopenglsquare, bserializeopenglsquare....

这是噩梦。

![QQ截图20230206233332](/assets/blog_res/2022-09-12-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/QQ%E6%88%AA%E5%9B%BE20230206233332.png)



- 我们学习了设计模式，这时候可以使用策略模式。也就是把draw作为一种策略嵌入到我们的每一个子类中。

我们有drawstrategy。这个类有openglstrategy和metalstrategy。openglstrategy下面可以有openglcirclestrategy和openglsquarestrategy。

我们的circle和square内部拥有一个drawstrategy类型的实例（指针，对象都可以）。构造circle或square对象的时候从外部传入对应的到底是openglstrategy还是metalstrategy。我们circle和square内部的draw只需要通过这个策略类实例调用策略类的draw就好了。

![QQ截图20230206233921](/assets/blog_res/2022-09-12-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/QQ%E6%88%AA%E5%9B%BE20230206233921.png)

- 但是还有问题。它性能不好，指针太多，虚函数太多，等等等等。怎么办？类型擦除。





## 类型擦除的特点

类型擦除不是：

- 不是`void*`指针。我们确实不再关心类型，但是这是错误理解。不是C那种做法了。
- 不是一个指向基类的指针。这就回到了多态。
- 也不是`std::variant`。`variant`其实是为封闭类型提供开放操作。而类型擦除是为开放类型提供封闭操作。

类型擦除是：

- 构造函数模板 和
- 完全不含有虚机制的接口 和
- 三个设计模式的结合：外部多态（external polymorphism） + 桥接（bridge） + 原型（prototype）



## 把我们刚才的例子换成类型擦除



![QQ截图20230207000338](/assets/blog_res/2022-09-12-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/QQ%E6%88%AA%E5%9B%BE20230207000338.png)

![QQ截图20230207000347](/assets/blog_res/2022-09-12-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/QQ%E6%88%AA%E5%9B%BE20230207000347.png)



- 现在我们的circle和square不需要知道任何关于draw和序列化的事情。他们只是单纯的几何基类。拥有必要的几何元素。

