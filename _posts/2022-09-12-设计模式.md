---
title: 设计模式
date: 2022-12-05 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true
  

---

# 设计模式

# 简单工厂模式

## 流程

- 设计一个抽象产品类，它包含一些产品类公共方法的实现;
- 从抽象产品类中派生出多个具体产品类，如篮球类、足球类、排球类，具体产品类中实现具体产品生产的相关代码;
- 设计一个工厂类，工厂类中提供一个生产各种产品的工厂方法，该方法根据传入参数（产品名称)创建不同的具体产品类对象;。客户只需调用工厂类的工厂方法，并传入具体产品参数，即可得到一个具体产品对象。

## 结构

- 工厂(Factory)︰根据客户提供的具体产品类的参数，创建具体产品实例
- 抽象产品(AbstractProduct):具体产品类的基类，包含创建产品的公共方法。可以做为抽象类（不提供实现）
- 具体产品(ConcreteProduct):抽象产品的派生类，包含具体产品特有的实现方法，是简单工厂模式的创建目标。



## 缺点

每次新增具体产品，不仅要新增具体产品类，而且要更改工厂类。

## 总结

- 简单工厂模式中，工厂只有一个。
  - 工厂生产所有种类的产品
- 工厂类的返回值是一个指向具体产品类的基类指针以满足多态调用。
- 工厂类中依据传入参数来调用对应的具体产品类。
- 抽象产品类可以做为抽象类也可以做为普通类。
- 具体产品类中进行具体产品的实现。



# 工厂方法模式

## 流程

- 设计一个抽象产品类，它包含一些产品类公共方法的实现;
- 从抽象产品类中派生出多个具体产品类，如篮球类、足球类、排球类，具体产品类中实现具体产品生产的相关代码;
- 设计一个抽象工厂类。是所有生产具体产品的工厂类的基类。提供工厂类的公共方法。
- 从抽象工厂类中派生出多个具体工厂类，具体工厂类中提供一个生产特定具体产品的方法，该方法可以返回一个具体产品类对象的指针。
- 使用时声明抽象工厂类指针，new一个具体工厂类的对象。让抽象工厂类指针指向具体工厂类对象。通过该指针调用具体工厂类的生产方法拿到一个指向具体产品类的抽象产品类指针。

## 结构

- 抽象工厂(AbstractFactory):所有生产具体产品的工厂类的基类，提供工厂类的公共方法;
- 具体工厂(ConcreteFactory) : 生产具体的产品
- 抽象产品(AbstractProduct):所有产品的基类，提供产品类的公共方法。
- 具体产品(ConcreteProduct) ︰具体的产品类

## 缺点

虽然我们这次不需要修改具体工厂类，只需要添加具体工厂类即可。但是：

- 这样做增加系统复杂度，因为类的数量变多了。
- 同时，由于工厂和产品都有抽象类，而且调用中也需要拿到对应的抽象类类型的指针，导致增加理解难度。降低代码可读性。

## 总结

- 我们这次拥有了抽象工厂类，这样我们就可以有多个不同的具体工厂类，让每一个工厂类都生产特定类别的具体产品。
- 抽象工厂类是抽象类。不提供具体实现。调用的时候需要声明一个抽象工厂类的指针指向某一个具体工厂
  - 这里的意思是必须要指明我们需要哪种工厂。
- 拿到具体工厂类指针后，可以通过具体工厂类的生产方法得到一个指向具体产品类的抽象产品类指针。
- **工厂方法模式把产品的具体创建过程延迟到了具体工厂类中。**

# 抽象工厂模式

## 和工厂方法模式的区别

抽象工厂和工厂方法非常相似。唯一的区别是：

- 在工厂方法中，我们每一个具体工厂类只能生产一个特定的具体产品。
- 在抽象工厂中，每一个具体工厂可以生产多种同类相关的产品。

## 缺点

- 在已有产品族中添加新产品时需要修改抽象工厂类代码。



# 适配器模式

**此处讲的是对象适配器而不是类适配器**

**类适配器需要多重继承支持。**

## 结构

- Target：目标抽象类
- Adapter：适配器类
- Adaptee：适配者类
- Client：客户类 （可以简化成调用对象）

## 流程：

- 创建target类。这个类是抽象基类。
- 创建adapter类。adapter类新增接口。调用所需的适配者类。
- 客户通过adapter类对象调用adapter类暴露出来的接口。

## 总结：

个人理解：当我们有一个任务需要调用多个类。我们就可以新增一个目标抽象类。然后适配器类继承自该目标抽象类。适配器类负责调用所需的适配者类，**也就是假如我们需要调用ABCDE五个类来完成这个任务。然后五个类关联不是很大，但是想让他们一起工作。我们就可以新增一个类。在这个类里面去调用ABCDE这五个类。我们外部客户只需要调用这个适配器类即可完成任务。**

**适配器模式和外观模式的核心区别**：

- 适配器模式的前提是你无法改变已经既有的类的需求。简单例子就是参数不同，类型不同等。
- 外观模式是你自己设计的时候，想要提供一个整洁一致的（看起来简洁的）接口给调用端。



# 外观模式（facade)

核心的个人理解：一个操作需要调用五个函数，太麻烦了，我们提供统一接口。这个接口内调用五个函数，但是客户只需要调用接口。

核心区别上面写过了。

## 结构

- 一个外观类（接口）
- 一堆你需要调用函数的类。

## 缺点：

- 增加或者减少子系统，必须要修改外观类。违反开闭原则。
- 客户端可以直接与子系统交互。如果加强限制则使系统灵活性降低。
