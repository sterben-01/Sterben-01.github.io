---
title: C++杂记 - 2
date: 2022-07-20 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true

---

# C++杂记 - 2

# 关于`delete this`

## 能否在类的析构函数中调用`delete this`?

**不能**

实验告诉我们，会导致堆栈溢出。原因很简单，**`delete`的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存**显然，`delete this`会去调用本对象的析构函数，而析构函数中又调用`delete this`，形成无限递归，造成堆栈溢出，系统崩溃。

## 能否在类的其它函数中调用`delete this`？

**可以，但不可以涉及到任何和this指针（成员变量，成员函数，虚函数）相关的东西。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。**

首先，让我们明确几点概念

- 在类对象的内存空间中，只有数据成员和虚表指针，并不包含代码内容。类的成员函数单独放在代码段中
- 在调用成员函数时，隐含传递一个`this`指针，让成员函数知道当前是哪个对象在调用它。当 调用`delete this`时，类对象的内存空间被释放。在`delete this`之后进行的其他任何函数调用，只要不涉及到`this`指针的内容，都能够正常运行。一旦涉及到`this`指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。

- **`delete this`释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的。这时访问数据成员可能是随机数，访问虚表发生指针无效的概率很高，系统崩溃。**

## 什么时候可以？

`this`指向的实例必须是`new`出来的，不能是`new[] `/`placement new`出来的，也不能是栈上的，也不是全局变量。只能是简单的`new`出来的。

调用了`delete this` 的成员函数（下面称为当事函数）**返回**后，这个实例不可以调用其他任何成员函数（这好理解，涉及到`this`指针，因为实例不存在了）。这个成员函数应当成为这个实例访问的最后一个函数。

调用了`delete this` 的成员函数后（从`delete this`这一行之后开始），这个实例不可以调用任何成员函数和成员变量（这好理解，理由同2）

调用了`delete this`之后，不得以任何形式提及`this`，包括比较、打印、类型转换等（因为this已经不存在了）。



# 什么时候需要虚析构函数

是多态基类的时候。多态一定有虚函数。（effective C++ 第七条)

**多态实现：通过指针+向上转换(子类转父类)(父类指针指向子类对象） + 虚函数 = 动态绑定 、虚机制**

## 为什么如果析构函数不是虚函数的时候，仅仅执行父类析构函数？

很多人可能会有疑问，问我们知道构造顺序是先父类构造再子类构造，析构顺序是先子类析构再父类析构（仅多态情况）。那么为什么我父类析构不是虚析构的时候仅执行父类析构？难道不应该是仅执行子类析构吗？

**因为忘了一点，多态调用必须是虚函数才可以，仅通过父类指针指向子类对象是不会触发虚机制（动态绑定（多态））的。**

**虽然父类指针可以指向子类，但是其访问范围还是仅仅局限于父类本身有的数据，那些子类的数据，父类指针是无法访问的。**

### 类继承是静态绑定，包含虚函数的情况才是动态绑定

```c++
class A{
    public:
    A(){}

};

class B: public A{
    public:
    B(){}
    int bval = 3;
};

class C :public B{
    public:
    C(){}
    int cval = 4;
};

int main(){
    A* a = new C;
    cout << a->bval << endl; //错误。类A没有成员bval
}
```

当定义一个指向子类实例的父类指针的时候，内存中实例化了子类，由于子类继承了父类,因此内存中的子类里包含父类的所有成员。但由于**申明的是父类指针，因此该指针不能够访问子类的成员，而只能访问父类的成员。然而在父类里可以声明纯虚函数和定义虚函数，使用父类指针访问虚函数或纯虚函数的时候，访问到的是子类里重写的函数。当然，对于虚函数，如果子类里没有对其重写的话，仍然访问到父类里定义的虚函数**。



**父类指针指向子类对象，仅可访问子类的父类部分。因为不知道子类的内存布局，所以没法访问子类的部分。也就是说，父类指针指向子类对象会发生隐式转换。所以说它还是个父类类型。**

多态的时候由于有RTTI所以可以在运行时获知子类类型。



**我们提到过，指向虚表的指针`_vfptr`是子类的父类部分。也就是父类指针可以访问的到子类的指向子类自己的虚表的指针`_vfptr`。父类访问这个指针后即可访问子类的虚表。（反复强调虚表一个类只有一个）。访问到这个虚表后，就会查表。即访问对应的虚函数。如果子类有重写，那么这个对应的虚表中的函数会在编译期就从父类的覆盖为子类的。这样就可以执行子类的函数了。如果子类没写，那个虚表里面的函数就还是父类的虚函数。**

所以，如果没有虚析构，则虚表里没有这一条。那么编译的时候发现不是虚函数，就会静态的将父类的析构函数编译过来。如果有了虚析构，则虚表里会有这一条。于是就会执行正常多态析构动作，先调用子类析构，再调用父类析构。也就是根据指向的对象找到对象的虚表指针，找到对象的虚表再调用对应的虚函数。实现多态。



# 运算符的重载，参数的数量怎么确定？在类里面和不在类里面？不在类里面声明怎么访问类里面的属性（如果是私有的呢？）

## 运算符重载

```c++
class multiple{
    public:
    int vala;
    int valb;
    multiple(){}
    multiple(int x, int y):vala(x), valb(y){}
    const multiple operator*(const multiple& rhs) const{
        multiple temp(this->vala * rhs.vala, this->valb*rhs.valb);
        return temp;
    }
    注意 乘法我们说是有两个参数即a*b 但是这里现在是成员函数，第一个参数默认是调用对象 即this 所以形参只有一个rhs。
    但是我们可以写为非成员函数，这样形参就会有rhs和lhs。
    非成员函数在进行隐式类型转换的时候可以实现交换律。参考effectiveC++ 条款24
    void getval(){
        cout << this->vala<< ", " << this->valb << endl;
    }

};

const multiple operator*(const multiple& lhs, const multiple& rhs){
    multiple temp(lhs.vala * rhs.vala, lhs.valb*rhs.valb);
    return temp;
}

//类外可以这么写。注意const不可修饰非成员函数！！
int main()
{
    multiple t1(5,5);
    multiple t2(6,4);
    multiple t3 = t1 * t2;
    t3.getval();
这里t3 = t1 * t2本质上是t3 = t1.operator*(t2)
t1是this，t2是rhs，t1.operator*(t2)对应函数返回值
}
```

 注意 这里重载第三个const的目的是让这个函数成为const函数。目的是可以被const对象调用 这里的例子就是我们避免以外赋值，使重载返回值也是const 因为如果不设置const的话 像是

```c__
(t1 * t2) = t3;
```

这种就不会报错。因为t1\*t2被当成了一个multiple类型的变量。可以给它赋值。因为它返回一个multiple对象。但是这违背了我们的意愿。所以我们加const来模拟常量确保t1\*t2不会被赋值 如果我们这个重载函数不设置const属性（也就是第三个const）的话，我们这样就无法链式调用了。因为我们现在的t1\*t2返回的是一个const multiple对象。const对象无法调用非const函数。所以我们的函数必须要const 

- 当运算符重载为**类的成员函数**时，函数的参数个数比原来的操作数要少一个（后置单目运算符除外），这是因为成员函数用this指针**隐式地访问了类的一个对象**，它充当了运算符函数最左边的操作数。因此：

  - 双目运算符重载为类的成员函数时，函数**只显式说明一个参数**，该形参是运算符的右操作数。

  - 前置单目运算符重载为类的成员函数时，**不需要显式说明参数**，**即函数没有形参**。

  - 后置单目运算符重载为类的成员函数时，函数要带有一个整型形参。

  - 调用成员函数运算符的格式如下：
    ```c++
    <对象名>.operator <运算符>(<参数>)
    它等价于
    <对象名><运算符><参数>                
    ```

- 当运算符重载为**类的友元函数**时，由于没有隐含的this指针，因此操作数的个数没有变化，所有的操作数都必须通过函数的**形参**进行传递，函数的参数与操作数自左至右一一对应。调用友元函数运算符的格式如下：

  ```c++
  operator<运算符>(<参数1>,<参数2>)
  它等价于
  <参数1><运算符><参数2>
  ```
  - **友元函数必须在类内声明。但是可以在类内或类外定义**
  ```c++
  class multiple{
      public:
      multiple(){}
      multiple(int x, int y):vala(x), valb(y){}
      friend const multiple operator*(const multiple& lhs, const multiple& rhs); //类内声明
      void getval(){
          cout << this->vala<< ", " << this->valb << endl;
      }
      private:
      int vala;
      int valb;
  
  };
  const multiple operator*(const multiple& lhs, const multiple& rhs){ //类内或类外定义均可。
      multiple temp(lhs.vala * rhs.vala, lhs.valb*rhs.valb);
      return temp;
  }
  int main()
  {
      multiple t1(5,5);
      multiple t2(6,4);
      multiple t3 = t1 * t2;
      t3.getval();
  }
  ```

- 在类外，因为不是成员函数所以没有this指针，所以必须要有全部参数。

## 解答：

1. 在类内，如果是双目运算符就少一个。因为左手部分是this。隐式传递。如果是类外，就正常两个。
2. 不在类里面声明，可以正常访问类公有部分。如果需要访问私有部分就需要使用友元函数。



# 关于mutable

很多人多`mutable`有错误认知。不仅仅是因为用得少，而且是有模糊概念。

**`mutable`是修饰成员变量所用。他的作用是让这个成员变量在任何时候都可以被修改，无论是:**

1. 做为参数传入形参带有`const`的函数
2. 做为参数传入被`const`修饰的(成员)函数
3. 在被`const`修饰的(成员)函数中
4. 被`const`修饰的变量中

首先举反例：

```c++
mutable int a; //这是啥？
const mutable int a; //这又是啥？
```

下面，正式开始举例：

```c++
class multiple{
    public:
    multiple(){}
    multiple(int x, int y):vala(x), valb(y){}
    
    
    mutable int vala;
    int valb;

};
```

我们拿到了类的定义。我们开始举例

```c++
mutable const int vala; //不可以 这啥玩意
const mutable int vala; //不可以 这啥玩意
```

**为了简便起见，我们只举成员函数的例子**

```c++
class multiple{
    public:
    multiple(){}
    multiple(int x, int y):vala(x), valb(y){}
    //------------------------------------- 被const修饰的成员函数
    void test1(multiple& x) const{
        vala = x.vala;
        x.vala = vala;
    }
    //-------------------------------------被const修饰的函数形参
    void test2(const multiple& x){
        vala = x.vala;
        x.vala = vala;
    }
    //-------------------------------------被const修饰的成员函数 和 被const修饰的函数形参
    void test3(const multiple& x) const{
        vala = x.vala;
        x.vala = vala;
    }
    //-------------------------------------
    mutable int vala;
    int valb;
};
```

**以上三个函数代表了三个例子。我们发现被无论是在被`const`修饰的成员函数中 还是 被当成参数传入被`const`修饰的函数形参中，我们都可以修改`mutable`修饰的变量。**

还有第四个例子

```c++
const multiple t1(3,3);
t1.valb = 3; //不可以
t1.vala = 3; //可以 因为被mutable修饰
```





# 关于`const_cast`

## 给一般读者：

- 常量指针（指向常量的指针）被转化成非常量的指针，并且仍然指向原来的对象；
- 常量引用被转换成非常量的引用，并且仍然指向原来的对象；

我们来看代码：

```c++
using namespace std;
class multiple{
    public:
    multiple():valc(0){}
    multiple(int x, int y, int z):vala(x), valb(y), valc(z){}
    int vala;
    int valb;
    const int valc;

};

int main()
{
    multiple p(1,3,5);
    const multiple* const_ptr = &p; 					//指向常量的指针
    //---------------------------------------------------------------------
    const_ptr = const_cast<multiple*> (const_ptr);		//进行const cast
    const_ptr->vala = 100;								//不可以, 必须要赋值给新的指针。
    const_cast<multiple*> (const_ptr)->vala = 100; 		//可以

    //---------------------------------------------------------------------
    multiple* ptr = const_cast<multiple*> (const_ptr);	//赋值给新指针
    ptr->vala = 10;										//可以
    ptr->valc = 100;									//不可以。因为valc是常量。
}
```



### 具体使用场景

### 1. **一个函数的形参数不是const对象，并且编程者事先已经知道在这个函数中不会对参数进行修改，但需要传递的实参却是已经定义好的const对象。为了成功调用这个函数，就需要利用到const_cast在实参传递前对其进行处理，从而使函数能够成功接收这个实参**

代码：

```c++
void Function(int &val){
    cout<<val<<endl;
}
int main(){
    const int value=21;
    Function(value);					//不可以
    Function(const_cast<int&>(value));	//转换为常量引用，可以
    return 0;
}
```





### 2. **如果我们定义了一个非const的变量，却使用了一个指向const对象的指针来指向它，而在程序的某处希望改变这个变量时发现只有指针可用，此时就可以const_cast进行处理**

```c++
int main(){
    int value=26;
    const int* const_ptr=&value;
    *const_ptr=3;							//不可以
    int* ptr=const_cast<int*>(const_ptr);	//转换为常量指针。可以
    *ptr=3;
    return 0;
}
```





## 给能思考的读者。因为这里我还没有完全弄明白，可能存在错误

我们直接看代码

```c++
class multiple{
    public:
    multiple():valc(0){}
    multiple(int x, int y, int z):vala(x), valb(y), valc(z){}
    int vala;
    int valb;
    const int valc;

};
int main()
{
    const multiple np(2,4,6);					//常量对象
    multiple ucnp = const_cast<multiple&>(np);	//这里下面会解释
    ucnp.vala = 10;
    //---------------------------------------------------------
    cout << ucnp.vala<< endl;						//输出10
    cout << ucnp.valb<< endl;						//输出4	
    cout << ucnp.valc<< endl;						//输出6
    //---------------------------------------------------------
    cout << np.vala<< endl;						//输出2
    cout << np.valb<< endl;						//输出4	
    cout << np.valc<< endl;						//输出6
}


```

**这里面我们进行`const_cast`的时候返回值并没有使用引用来接受。这是可以的。这里会产生一个临时变量做为中间值传给了结果值**

**有没有注意到问题，我们的`np`不是引用，是个对象。可能无法直观感受，我们接着看**  

这句话不知道对不对。来自：https://www.cnblogs.com/dracohan/p/3417842.html

下面有更狠的。

我们把`ucnp`换成引用。看看结果如何

```c++
int main()
{
    const multiple np(2,4,6);					//常量对象
    multiple& ucnp = const_cast<multiple&>(np);	//注意这里
    ucnp.vala = 10;
    //---------------------------------------------------------
    cout << ucnp.vala<< endl;						//输出10
    cout << ucnp.valb<< endl;						//输出4	
    cout << ucnp.valc<< endl;						//输出6
    //---------------------------------------------------------
    cout << np.vala<< endl;						//输出10
    cout << np.valb<< endl;						//输出4	
    cout << np.valc<< endl;						//输出6
}

```

**好像没什么问题啊？确实是这样的嘛。常量引用转换成非常量引用，有啥问题？**

**你再仔细看一眼。`np`是什么？是对象啊。这是个常量对象啊，我们修改了常量对象啊！**

我们可以来一个更明显的例子：

```c++
int main{
    
    multiple p(1,3,5);
    cout << p.valc << endl;					//输出5
    int& wtf = const_cast<int&>(p.valc);	//修改常量。
    wtf = 1000;
    cout << p.valc << endl;					//输出1000
    return 0;
}
```

**我们的`valc`是一个`const int`。但是这里我们修改了一个对象里的常量。**

**以上操作，编译器没有任何警告。但是这应该是一个未定义行为。需要避免修改任何已经声明为常量的对象。`const_cast`只能正确转换顶层（引用，指针）的常量性质，但是无法正确转换底层（引用的本体，指针指向的对象）的常量性质。强行转换会导致未定义行为。**

# 迭代器失效

我总是把迭代器失效理解成错误的含义。我们简单讲一下真正的含义是什么，不作具体细节展开

```c++
    vector<int> a = {1,2,3,4,5,6,7,8,9,10};
    auto it = a.end();
    cout << *(it-1) << endl; //输出10
    cout << a.size()<<endl; //输出10
    cout << a.capacity()<<endl; //输出10
    a.insert(a.begin() + 3, 3333); //插入后扩容，数据转移至新区域，原来区域被释放
    cout << *(it-1) << endl; //输出无效数据，迭代器失效。
```

首先，我们要知道。`begin()` 和`end()`每次都会动态的返回对应的迭代器，所以这俩不会失效。

啥时候会时效呢？**当有一个额外的手动赋值的迭代器出现的时候**

这句话是啥意思呢

比如：

`for(iter = a.begin();;)` 这里你声明了一个新的`iter`来接收这个调用`begin()`返回的迭代器。这就是另一个迭代器

或者如上图的：`auto it = a.end()`。这里也是新的。

所以为什么在for循环里对迭代器操作的时候会失效。因为你操作的迭代器不是动态获取的，而是你已经获取到之后对迭代器进行加减操作的。

另外一个简单例子

```c++
    vector<int> a;
    a.reserve(20);
    for(int i = 0 ;i < 10; i++){
        a.push_back(i);
    }
	//这时候a是{0,1,2,3,4,5,6,7,8,9}
    auto it = a.end();
    cout << *(it-1) << endl; //输出9
    a.insert(a.begin() + 3, 3333);
	//这时候a是{0,1,2,3333,3,4,5,6,7,8,9}
    cout << *(it-1) << endl; //输出8。
}
```

因为迭代器已经被赋值。对迭代器的加减操作我们可以理解为原始数组对指针的加减操作。所以原来的时候，最后一位指向的内存地址存的是9，我们可以理解为`end-1`是`begin+9`。我们执行`insert`之后，由于迭代器没有重新赋值，所以`begin+9`指向的内存地址不变。但是`insert`会让插入位置后的元素后移，8会被移到原来9的内存地址上。这样就是迭代器失效。

# eplicit

叽叽歪歪一大堆没意思。先看一个关键知识点

**当一个构造函数只有一个参数，而且该参数又不是本类的`const`引用时（这里存在不同说法。一说是只要不是本类类型即可），这种构造函数称为转换构造函数，即转换构造函数为单参构造函数的一种**。这里的只有一个参数可以拆分为，**只有一个形参**，或，**形参中只有一个没有默认值。**

**explicit只能限制住拷贝初始化，并不能限制直接初始化。我们下面提到了四种隐式转换的条件。**

啥意思？

## 只有一个形参

```c++
class A
{
public:
    A(int i):a(i){} 		//单参构造函数
    int getValue()
    {
        return a;
    };
private:
    int a;
};
```

```c++
int main(){
    A a = 10;			//case1
    A a(10);			//case2 注意这是直接初始化，不会受到explicit限制。
    A a;				//case3
    a = 10;
    return 0;
}
```

case1中，我们没有临时对象。而是直接把10作为参数传递给类型转换构造函数。使用了拷贝初始化（先调用默认构造，再调用拷贝构造）这虽然使用了"="，但是实际上我们在创建新对象。创建新对象的时候一律是拷贝构造而不是拷贝赋值。因为对象还不存在

case2中，我们没有临时对象，使用直接初始化调用默认构造。

case3中，我们有临时对象。编译器执行 `a = 10;`的时候相当于先使用 `A(10);`在栈中创建了一个临时对象。然后再调用对象`a`的拷贝赋值 `a(10)` 给`a`初始化（因为对象a已经存在）。然后临时对象销毁。这就是编译器做的隐式转换工作。

也就是说，如果我们使用了`explicit`，这里将会变成：

```c++
A a;
a = A(10); 	//显式调用构造函数 禁止隐式转换
```

## 多个形参但是只有一个没有默认值

```c++
class A
{
public:
    A(int i, int j = 5):a(i),b(j){} 		//单参构造函数
    int getValue()
    {
        return a;
    };
private:
    int a;
    int b;
};
```

原理和上面一样。但是有一个知识点：函数默认值假如第N个参数有，那么N后面的参数必须全都有。

## 发生隐式转换的条件

注意！由四种情况会发生隐式转换：

- 混合类型的算数运算表达式。

```c++
int a = 3;
double b = 4.5;
a + b; // a将会被自动转换为double类型，转换的结果和b进行加法操作
```

- 不同类型的赋值操作。（这里包含拷贝初始化）

```c++
int a = true ; ( bool 类型被转换为 int 类型)
int * ptr = null;（null被转换为 int *类型）
```

- 函数参数传值

```c++
void func(double a);
func(1); // 1被隐式的转换为double类型1.0
```

- 函数返回值。（此处例子）

```c++
double add( int a, int b)
{
    return a + b;
} //运算的结果会被隐式的转换为double类型返回

```

针对第四种我们举个例子。看代码：

```c++
class tmp{
    public:
    string _text;
    tmp(string c): _text(c) {}			//单参构造，可以看做转换构造

};
class test{
    public:
    string _text;
    test(string a): _text(a){}		//单参构造，可以看做转换构造
    test(tmp s): _text(s._text){}  //单参构造，可以看做转换构造。此处入参是tmp类型，return一个test类型，可以看成tmp可以转为test
};
class twonumber{
    public:
    test ret(){
        test(tmp("cde"));
        return(tmp("abc")); //此处返回的对象是一个tmp，但是函数头的返回类型却是test。可以运行。这里使用了构造函数的隐式转换。使用了临时对象
        return(test(tmp("abc"))); //如果设置了explicit，则需要这样进行显式转换。
    }
    //!由于return语句内是隐式转换，所以对应的构造函数如果有explicit关键字则无法进行隐式转换。即便这里看起来像拷贝初始化。

};
int main(){
    twonumber ttt;
    test rrr = ttt.ret();
    cout << rrr._text << endl;
    return 0;
}
```



## 说到底，我们啥时候想禁用呢？

- 当类中同时存在“non-explicit-one-argument 构造函数和类型转换函数的时候。有可能产生二义性。所以需要对“non-explicit-one-argument构造函数前加explicit防止编译器隐式自动转换类型



**再次重申，explicit只限制拷贝初始化，不限制直接初始化。而且对象类型不可以为本类类型。因为如果是本类类型那还转换个屁。**

```c++
A a(5);		//可以。直接初始化
A a = 5;	//不可以，拷贝初始化。
A b(a);		//可以。对象类型为本类，不属于类型转换。不发生隐式转换。
A b = a;	//可以。对象类型为本类，不属于类型转换。不发生隐式转换。
```

# 对于类来说，直接在类型后面加上括号，就是调用构造函数

类型后面+名字再+括号只不过是给了个名字而已。

```c++
class p{
    public:
    int a;
    int b;
    p(){}
    p(int x, int y):a(x),b(y){}

};
int main(){
    p t1;
    t1.a(5); //这是啥东西？构造函数怎么能构造出来对象的变量而不是对象本身呢？怎么可以通过构造函数给变量赋值？
    t1.a = 5;//对了
    
	
}
```

# 非类型模板参数

这块之前居然忽略了。必须简单说一下

```c++
template<typename T>
void func(T obj){
    //...
}

int main(){
    func<int>(5);
    return 0;
}
```

我们都知道模板参数一般都是类型。比如这里，T就是int。是类型。

但是如果我们有时候需要一些特殊情况， 例如想要传点奇怪东西的时候。

```c++
template<typename T, int MAXSIZE>
void func1(T obj){
    vector<T>a;
    a.reserve(MAXSIZE);
    cout << a.capacity() << endl;
    a.push_back(obj);
    cout << a[0] << endl; 			//干啥了不解释了 忽略即可
}

```

这里的int MAXSIZE就是非类型模板参数。因为他不是类型，而是变量。

使用非类型模板参数是有限制的。通常它们只能是整型常量（包含枚举，或可隐式转换的比如`bool`）（`string` `double`都不可以。前者是类对象，后者是浮点数），指向objects/functions/members的指针，objects/functions的左值引用以及`std::nullptr_t`。

当传递对象的指针或者引用作为模板参数时，对象不能是字符串常量，临时变量或者数据成员以及其他子对象。由于C++17之前，C++每次版本更新都会放宽以上限制，因此还有一些针对不同版本的限制：

- C++11中，对象必须要有外部链接
- C++14中，对象必须是外部链接或者内部链接

所以：传入的`s`必须是常量。

```c++
const int s = 4;	//必须是const
func1<int, s>(5);
```

# enable_if

简单看一下原型

```c++
template <bool, typename T=void>
struct enable_if {
};
template <typename T>
struct enable_if<true, T> { ///< 第一个模板参数为 true
  using type = T;           ///< type 才有定义
};
```

意思就是，前面的表达式为真，后面的类型定义才有意义。

一般三种用法：

- 控制函数返回类型
- 校验函数模板参数类型
- 类型偏特化

这里就随便写个控制函数返回类型的例子：

```c++
template<int stat> //这里是非模板类型参数。上面提到了。注意一下
typename enable_if<stat == 1, bool>::type checkstate(){
    cout <<"type is bool" << endl;
    return true;
}
template<int stat>
typename enable_if<stat == 0, int>::type checkstate(){
    cout <<"type is int" << endl;
    return 5;
}

template<bool stat>			//bool也可以。隐式转换为整型了，但是必须要常量。
typename enable_if<stat == true, int>::type checkstate1(){
    cout <<"type is int" << endl;
    return 5;
}

int main(){
    const int myobj = 1; 	//必须是const
    checkstate<myobj>();	//输出"type is bool" 
    checkstate<0>();		//输出"type is int" 
    return 0;
}
```

注意事项：返回类型前必须加`typename`来告知`enable_if::type`是个类型。还有就是非模板类型参数的限制。



# 析构函数和构造函数中的异常

- 构造函数中抛出的异常会导致析构函数无法被调用。因为被视为对象没有成功构造。会存在内存泄漏风险
- 在析构函数中是可以抛出异常的，但是这样做很危险，请尽量不要这要做。原因在《More Effective C++》中提到两个：

（1）如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。

（2）通常异常发生时，c++的异常处理机制在异常的传播过程中会进行栈展开（stack-unwinding），因发生异常而逐步退出复合语句和函数定义的过程，被称为栈展开。在栈展开的过程中就会调用已经在栈构造好的对象的析构函数来释放资源，此时若其他析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃。

# inline与宏区别?

- inline：
  - 编译期进行展开。
  - 是函数
  - 嵌入到目标代码
  - 可以进行安全检查，语句正确等编译功能
- 宏：
  - 预处理期进行替换。
  - 不是函数
  - 只是文本替换
  - 不能进行安全检查等。

# inline函数与普通函数区别？

当普通函数在被调用时，系统首先跳跃到该函数的入口地址，执行函数体，执行完成后，再返回到函数调用的地方，函数始终只有一份。

而内联函数则不需要进行一个寻址的过程，当执行到内联函数时，此函数展开（很类似宏的使用），如果在 N 处调用了此内联函数，则此函数就会有 N 个代码段的拷贝。空间换时间。

# 如何加深理解移动构造和拷贝构造

```c++
class myobj{
    public:
        myobj(int x):val(new int(x)){}
        int& getval(){
            return *val;
        }
        myobj(const myobj& obj){						//拷贝构造
            val = new int(*obj.val);					
        }
        myobj& operator=(const myobj & rhs){			//拷贝赋值
            if(this == &rhs){
                return *this;
            }
            delete this->val;
            val = new int(*rhs.val);
            return *this;
        }
        myobj(myobj&& obj){								//移动构造
            cout <<"mv" << endl;
            val = obj.val;
            obj.val = nullptr;
        }
        myobj& operator=(myobj&& rhs){					//移动赋值
            cout <<"mv=" << endl;
            if(this == &rhs){
                return *this;
            }
            if(this->val != nullptr){
                delete val;
            }
            val = rhs.val;
            rhs.val = nullptr;
            return *this;

        }
        ~myobj(){
            delete val;
            val = nullptr;
        }


        int* val;
        
};

int main(){
    myobj a(5);
    myobj b(10);
    cout << a.getval() << endl;					
    myobj c(a);							//拷贝构造
    cout << c.getval() << endl;
    myobj d = c;						//拷贝构造。因为d对象之前不存在。
    cout << d.getval() << endl;
    d = b;								//拷贝赋值
    cout << d.getval() << endl;
    myobj e = move(a);					//移动构造。因为e对象之前不存在。在这之后不可访问a，因为a所有权已被转移
    cout << e.getval() << endl;
    d = move(b);						//移动赋值。在这之后不可访问b,因为b所有权已被转移
    cout << d.getval() << endl;
    return 0;
}
```

首先我们要强化记忆，什么叫构造函数。构造函数就是创建对象的时候调用的。我们这里有一个类，里面有一根指针。首先，我们既然是构造，那么拷贝构造和默认构造都要对变量（指针）初始化（分配内存）。所以这里拷贝构造和默认构造都是`new`的。因为我们都是**无中生有**

那么移动构造和拷贝构造的区别在哪呢？

什么时候我们想要移动？假如我们要**转移所有权**，我们这时候会调用移动构造。也是无中生有。但是由于转移所有权，所以我们**不需要new**。我们只需要把原来指针指向的地址赋值给我们新变量的对应变量上即可。**移动之后，因为我们的目的是转移所有权，所以应当对原对象的对应指针变量置空。**



拷贝赋值和移动赋值。

- 拷贝赋值我们首先要检测自我赋值。通过地址来判断。如果是一个地址互相赋值，那么什么都不做。然后我们首先把自己的东西清理掉，也就是自己指针指向的资源释放掉。然后，由于我们是拷贝，不是移动。所以我们依旧要**开辟新空间，把原来对象的指针指向的值复制过来。**

- 移动赋值，我们首先也要检测自我赋值。然后也要先把自己的东西清理掉，也就是自己指针指向的资源释放掉。然后，由于我们是**移动**，所以我们直接复制指针而不是指针指向的值。然后把**源对象的指针置空，因为我们是转移所有权。**

- 返回值：

  - **构造函数，无论是默认构造，拷贝构造还是移动构造，函数都无返回值。**

  - 赋值操作符，无论是拷贝赋值还是移动赋值，**我们为了链式调用，也避免不必要的拷贝**，都应该返回对象的引用。

- 形参：

  - 拷贝构造和拷贝赋值，应该接受对象的常引用。

  - 移动构造和移动赋值因为涉及到对源对象的修改，即 对源成员变量（指针）置空，所以不能是常量。而且要接收右值。因为是移动。

- 什么时候该触发移动构造呢？

  - 如果临时对象即将消亡，并且它里面的资源是需要被再利用的，这个时候我们就可以触发移动构造。
    - 比如`vector.push_back(obj(8));`这就是往容器添加一个临时对象。这时候如果此临时对象有移动构造，则调用完默认构造后，直接触发移动构造进行搬移省去一次内存分配。否则需要调用拷贝构造。
  
  - 移动构造在使用vector的情况下，一般是vector扩容的时候重新分配内存的时候使用，如果自定义类型有移动构造就会用移动构造。没有就是拷贝构造。这里的移动构造必须是`noexcept`



## for循环

for循环的更新条件（第三个条件）是迭代之后执行的，也就是最后执行的。 



## i++和++i

- ++i 
 ++i 先自加，再赋值。

```c++
#include<stdio.h>
int main()
{
    int i = 0;
    int j = ++i;    
    cout << i << j <<endl;
    return 0;
}
```

此时输出 i=1 j=1 

- i++ 

​		i++ 先赋值，再自加。

```c++
#include<stdio.h>
int main()
{
    int i = 0;
    int j = i++;
    cout << i << j <<endl;
    return 0;
}
```

此时输出 i=1 j=0 

**i++是右值，++i是左值**

在内置类型的情况下

```c++
int a = i++;
```

这句话在编译器眼里是下面这样的两句话：

```c++
int a = i;
i++;
```

而

```c++
int a = ++i;
```

在编译器眼里则是这样：

```c++
i++;
int a = i;
```







**i++和++i在非自定义类型的情况下，只要不发生赋值，则没有差别**





我们深入看一下**自定义类型的情况**

```c++
struct mybase
{
    // 前置++
    mybase& operator++()
    {
        data++;
        return *this;
    }

    // 后置++
    mybase operator++(int)
    {
        auto tmp = *this;
        // 执行++有两种选择, data++或者调用上面的前置++
        data++;

        return tmp; //注意这是局部变量！！
    }

    int data = 0;
};
```

注意这里后置的++我们有一个非常奇怪的写法。我们用一个临时变量保存了自己，然后再把自己的值+1，然后返回一个自己的拷贝。**不能返回引用！因为这里的temp是临时变量，返回引用就炸了**

这也就是为什么i++先赋值再自增了。因为我们赋值过去的是一个没有自增的自己。

这也是为什么i++是一个右值。因为他符合了右值的定义之一：返回了一个非引用类型的 函数调用。因为++本身也可以重载，也是函数调用。他返回了一个临时对象的自己。



所以++i反而看起来非常简单。我们先给自己+1然后返回自己的引用。这也是为什么++i是先自增再赋值，也是为何++i是左值。
