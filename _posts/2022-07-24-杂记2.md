---
title: C++杂记 - 2
date: 2022-07-20 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true

---

# C++杂记 - 2

# 关于`delete this`

## 能否在类的析构函数中调用`delete this`?

**不能**

实验告诉我们，会导致堆栈溢出。原因很简单，**`delete`的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存**显然，`delete this`会去调用本对象的析构函数，而析构函数中又调用`delete this`，形成无限递归，造成堆栈溢出，系统崩溃。

## 能否在类的其它函数中调用`delete this`？

**可以，但不可以涉及到任何和this指针（成员变量，成员函数，虚函数）相关的东西。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。**

首先，让我们明确几点概念

- 在类对象的内存空间中，只有数据成员和虚表指针，并不包含代码内容。类的成员函数单独放在代码段中
- 在调用成员函数时，隐含传递一个`this`指针，让成员函数知道当前是哪个对象在调用它。当 调用`delete this`时，类对象的内存空间被释放。在`delete this`之后进行的其他任何函数调用，只要不涉及到`this`指针的内容，都能够正常运行。一旦涉及到`this`指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。

- **`delete this`释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的。这时访问数据成员可能是随机数，访问虚表发生指针无效的概率很高，系统崩溃。**

## 什么时候可以？

`this`指向的实例必须是`new`出来的，不能是`new[] `/`placement new`出来的，也不能是栈上的，也不是全局变量。只能是简单的`new`出来的。

调用了`delete this` 的成员函数（下面称为当事函数）**返回**后，这个实例不可以调用其他任何成员函数（这好理解，涉及到`this`指针，因为实例不存在了）。这个成员函数应当成为这个实例访问的最后一个函数。

调用了`delete this` 的成员函数后（从`delete this`这一行之后开始），这个实例不可以调用任何成员函数和成员变量（这好理解，理由同2）

调用了`delete this`之后，不得以任何形式提及`this`，包括比较、打印、类型转换等（因为this已经不存在了）。



# 什么时候需要虚析构函数

是多态基类的时候。多态一定有虚函数。（effective C++ 第七条)

**多态实现：通过指针+向上转换(子类转父类)(父类指针指向子类对象） + 虚函数 = 动态绑定 、虚机制**

## 为什么如果析构函数不是虚函数的时候，仅仅执行父类析构函数？

很多人可能会有疑问，问我们知道构造顺序是先父类构造再子类构造，析构顺序是先子类析构再父类析构（仅多态情况）。那么为什么我父类析构不是虚析构的时候仅执行父类析构？难道不应该是仅执行子类析构吗？

**因为忘了一点，多态调用必须是虚函数才可以，仅通过父类指针指向子类对象是不会触发虚机制（动态绑定（多态））的。**

**虽然父类指针可以指向子类，但是其访问范围还是仅仅局限于父类本身有的数据，那些子类的数据，父类指针是无法访问的。**

### 类继承是静态绑定，包含虚函数的情况才是动态绑定

```c++
class A{
    public:
    A(){}

};

class B: public A{
    public:
    B(){}
    int bval = 3;
};

class C :public B{
    public:
    C(){}
    int cval = 4;
};

int main(){
    A* a = new C;
    cout << a->bval << endl; //错误。类A没有成员bval
}
```

当定义一个指向子类实例的父类指针的时候，内存中实例化了子类，由于子类继承了父类,因此内存中的子类里包含父类的所有成员。但由于**申明的是父类指针，因此该指针不能够访问子类的成员，而只能访问父类的成员。然而在父类里可以声明纯虚函数和定义虚函数，使用父类指针访问虚函数或纯虚函数的时候，访问到的是子类里重写的函数。当然，对于虚函数，如果子类里没有对其重写的话，仍然访问到父类里定义的虚函数**。



**父类指针指向子类对象，仅可访问子类的父类部分。因为不知道子类的内存布局，所以没法访问子类的部分。也就是说，父类指针指向子类对象会发生隐式转换。所以说它还是个父类类型。**

多态的时候由于有RTTI所以可以在运行时获知子类类型。



**我们提到过，指向虚表的指针`_vfptr`是子类的父类部分。也就是父类指针可以访问的到子类的指向子类自己的虚表的指针`_vfptr`。父类访问这个指针后即可访问子类的虚表。（反复强调虚表一个类只有一个）。访问到这个虚表后，就会查表。即访问对应的虚函数。如果子类有重写，那么这个对应的虚表中的函数会在编译期就从父类的覆盖为子类的。这样就可以执行子类的函数了。如果子类没写，那个虚表里面的函数就还是父类的虚函数。**

所以，如果没有虚析构，则虚表里没有这一条。那么编译的时候发现不是虚函数，就会静态的将父类的析构函数编译过来。如果有了虚析构，则虚表里会有这一条。于是就会执行正常多态析构动作，先调用子类析构，再调用父类析构。也就是根据指向的对象找到对象的虚表指针，找到对象的虚表再调用对应的虚函数。实现多态。



# 运算符的重载，参数的数量怎么确定？在类里面和不在类里面？不在类里面声明怎么访问类里面的属性（如果是私有的呢？）

## 运算符重载

```c++
class multiple{
    public:
    int vala;
    int valb;
    multiple(){}
    multiple(int x, int y):vala(x), valb(y){}
    const multiple operator*(const multiple& rhs) const{
        multiple temp(this->vala * rhs.vala, this->valb*rhs.valb);
        return temp;
    }
    注意 乘法我们说是有两个参数即a*b 但是这里现在是成员函数，第一个参数默认是调用对象 即this 所以形参只有一个rhs。
    但是我们可以写为非成员函数，这样形参就会有rhs和lhs。
    非成员函数在进行隐式类型转换的时候可以实现交换律。参考effectiveC++ 条款24
    void getval(){
        cout << this->vala<< ", " << this->valb << endl;
    }

};

const multiple operator*(const multiple& lhs, const multiple& rhs){
    multiple temp(lhs.vala * rhs.vala, lhs.valb*rhs.valb);
    return temp;
}

//类外可以这么写。注意const不可修饰非成员函数！！
int main()
{
    multiple t1(5,5);
    multiple t2(6,4);
    multiple t3 = t1 * t2;
    t3.getval();
这里t3 = t1 * t2本质上是t3 = t1.operator*(t2)
t1是this，t2是rhs，t1.operator*(t2)对应函数返回值
}
```

 注意 这里重载第三个const的目的是让这个函数成为const函数。目的是可以被const对象调用 这里的例子就是我们避免以外赋值，使重载返回值也是const 因为如果不设置const的话 像是

```c__
(t1 * t2) = t3;
```

这种就不会报错。因为t1\*t2被当成了一个multiple类型的变量。可以给它赋值。因为它返回一个multiple对象。但是这违背了我们的意愿。所以我们加const来模拟常量确保t1\*t2不会被赋值 如果我们这个重载函数不设置const属性（也就是第三个const）的话，我们这样就无法链式调用了。因为我们现在的t1\*t2返回的是一个const multiple对象。const对象无法调用非const函数。所以我们的函数必须要const 

- 当运算符重载为**类的成员函数**时，函数的参数个数比原来的操作数要少一个（后置单目运算符除外），这是因为成员函数用this指针**隐式地访问了类的一个对象**，它充当了运算符函数最左边的操作数。因此：

  - 双目运算符重载为类的成员函数时，函数**只显式说明一个参数**，该形参是运算符的右操作数。

  - 前置单目运算符重载为类的成员函数时，**不需要显式说明参数**，**即函数没有形参**。

  - 后置单目运算符重载为类的成员函数时，函数要带有一个整型形参。

  - 调用成员函数运算符的格式如下：
    ```c++
    <对象名>.operator <运算符>(<参数>)
    它等价于
    <对象名><运算符><参数>                
    ```

- 当运算符重载为**类的友元函数**时，由于没有隐含的this指针，因此操作数的个数没有变化，所有的操作数都必须通过函数的**形参**进行传递，函数的参数与操作数自左至右一一对应。调用友元函数运算符的格式如下：

  ```c++
  operator<运算符>(<参数1>,<参数2>)
  它等价于
  <参数1><运算符><参数2>
  ```
  - **友元函数必须在类内声明。但是可以在类内或类外定义**
  ```c++
  class multiple{
      public:
      multiple(){}
      multiple(int x, int y):vala(x), valb(y){}
      friend const multiple operator*(const multiple& lhs, const multiple& rhs); //类内声明
      void getval(){
          cout << this->vala<< ", " << this->valb << endl;
      }
      private:
      int vala;
      int valb;
  
  };
  const multiple operator*(const multiple& lhs, const multiple& rhs){ //类内或类外定义均可。
      multiple temp(lhs.vala * rhs.vala, lhs.valb*rhs.valb);
      return temp;
  }
  int main()
  {
      multiple t1(5,5);
      multiple t2(6,4);
      multiple t3 = t1 * t2;
      t3.getval();
  }
  ```

- 在类外，因为不是成员函数所以没有this指针，所以必须要有全部参数。

## 解答：

1. 在类内，如果是双目运算符就少一个。因为左手部分是this。隐式传递。如果是类外，就正常两个。
2. 不在类里面声明，可以正常访问类公有部分。如果需要访问私有部分就需要使用友元函数。



# 关于mutable

很多人多`mutable`有错误认知。不仅仅是因为用得少，而且是有模糊概念。

**`mutable`是修饰成员变量所用。他的作用是让这个成员变量在任何时候都可以被修改，无论是:**

1. 做为参数传入形参带有`const`的函数
2. 做为参数传入被`const`修饰的(成员)函数
3. 在被`const`修饰的(成员)函数中
4. 被`const`修饰的变量中

首先举反例：

```c++
mutable int a; //这是啥？
const mutable int a; //这又是啥？
```

下面，正式开始举例：

```c++
class multiple{
    public:
    multiple(){}
    multiple(int x, int y):vala(x), valb(y){}
    
    
    mutable int vala;
    int valb;

};
```

我们拿到了类的定义。我们开始举例

```c++
mutable const int vala; //不可以 这啥玩意
const mutable int vala; //不可以 这啥玩意
```

**为了简便起见，我们只举成员函数的例子**

```c++
class multiple{
    public:
    multiple(){}
    multiple(int x, int y):vala(x), valb(y){}
    //------------------------------------- 被const修饰的成员函数
    void test1(multiple& x) const{
        vala = x.vala;
        x.vala = vala;
    }
    //-------------------------------------被const修饰的函数形参
    void test2(const multiple& x){
        vala = x.vala;
        x.vala = vala;
    }
    //-------------------------------------被const修饰的成员函数 和 被const修饰的函数形参
    void test3(const multiple& x) const{
        vala = x.vala;
        x.vala = vala;
    }
    //-------------------------------------
    mutable int vala;
    int valb;
};
```

**以上三个函数代表了三个例子。我们发现被无论是在被`const`修饰的成员函数中 还是 被当成参数传入被`const`修饰的函数形参中，我们都可以修改`mutable`修饰的变量。**

还有第四个例子

```c++
const multiple t1(3,3);
t1.valb = 3; //不可以
t1.vala = 3; //可以 因为被mutable修饰
```





# 关于`const_cast`

## 给一般读者：

- 常量指针（指向常量的指针）被转化成非常量的指针，并且仍然指向原来的对象；
- 常量引用被转换成非常量的引用，并且仍然指向原来的对象；

我们来看代码：

```c++
using namespace std;
class multiple{
    public:
    multiple():valc(0){}
    multiple(int x, int y, int z):vala(x), valb(y), valc(z){}
    int vala;
    int valb;
    const int valc;

};

int main()
{
    multiple p(1,3,5);
    const multiple* const_ptr = &p; 					//指向常量的指针
    //---------------------------------------------------------------------
    const_ptr = const_cast<multiple*> (const_ptr);		//进行const cast
    const_ptr->vala = 100;								//不可以, 必须要赋值给新的指针。
    const_cast<multiple*> (const_ptr)->vala = 100; 		//可以

    //---------------------------------------------------------------------
    multiple* ptr = const_cast<multiple*> (const_ptr);	//赋值给新指针
    ptr->vala = 10;										//可以
    ptr->valc = 100;									//不可以。因为valc是常量。
}
```



### 具体使用场景

### 1. **一个函数的形参数不是const对象，并且编程者事先已经知道在这个函数中不会对参数进行修改，但需要传递的实参却是已经定义好的const对象。为了成功调用这个函数，就需要利用到const_cast在实参传递前对其进行处理，从而使函数能够成功接收这个实参**

代码：

```c++
void Function(int &val){
    cout<<val<<endl;
}
int main(){
    const int value=21;
    Function(value);					//不可以
    Function(const_cast<int&>(value));	//转换为常量引用，可以
    return 0;
}
```





### 2. **如果我们定义了一个非const的变量，却使用了一个指向const对象的指针来指向它，而在程序的某处希望改变这个变量时发现只有指针可用，此时就可以const_cast进行处理**

```c++
int main(){
    int value=26;
    const int* const_ptr=&value;
    *const_ptr=3;							//不可以
    int* ptr=const_cast<int*>(const_ptr);	//转换为常量指针。可以
    *ptr=3;
    return 0;
}
```





## 给能思考的读者。因为这里我还没有完全弄明白，可能存在错误

我们直接看代码

```c++
class multiple{
    public:
    multiple():valc(0){}
    multiple(int x, int y, int z):vala(x), valb(y), valc(z){}
    int vala;
    int valb;
    const int valc;

};
int main()
{
    const multiple np(2,4,6);					//常量对象
    multiple ucnp = const_cast<multiple&>(np);	//这里下面会解释
    ucnp.vala = 10;
    //---------------------------------------------------------
    cout << ucnp.vala<< endl;						//输出10
    cout << ucnp.valb<< endl;						//输出4	
    cout << ucnp.valc<< endl;						//输出6
    //---------------------------------------------------------
    cout << np.vala<< endl;						//输出2
    cout << np.valb<< endl;						//输出4	
    cout << np.valc<< endl;						//输出6
}


```

**这里面我们进行`const_cast`的时候返回值并没有使用引用来接受。这是可以的。这里会产生一个临时变量做为中间值传给了结果值**

**有没有注意到问题，我们的`np`不是引用，是个对象。可能无法直观感受，我们接着看**  

这句话不知道对不对。来自：https://www.cnblogs.com/dracohan/p/3417842.html

下面有更狠的。

我们把`ucnp`换成引用。看看结果如何

```c++
int main()
{
    const multiple np(2,4,6);					//常量对象
    multiple& ucnp = const_cast<multiple&>(np);	//注意这里
    ucnp.vala = 10;
    //---------------------------------------------------------
    cout << ucnp.vala<< endl;						//输出10
    cout << ucnp.valb<< endl;						//输出4	
    cout << ucnp.valc<< endl;						//输出6
    //---------------------------------------------------------
    cout << np.vala<< endl;						//输出10
    cout << np.valb<< endl;						//输出4	
    cout << np.valc<< endl;						//输出6
}

```

**好像没什么问题啊？确实是这样的嘛。常量引用转换成非常量引用，有啥问题？**

**你再仔细看一眼。`np`是什么？是对象啊。这是个常量对象啊，我们修改了常量对象啊！**

我们可以来一个更明显的例子：

```c++
int main{
    
    multiple p(1,3,5);
    cout << p.valc << endl;					//输出5
    int& wtf = const_cast<int&>(p.valc);	//修改常量。
    wtf = 1000;
    cout << p.valc << endl;					//输出1000
    return 0;
}
```

**我们的`valc`是一个`const int`。但是这里我们修改了一个对象里的常量。**

**以上操作，编译器没有任何警告。但是这应该是一个未定义行为。需要避免修改任何已经声明为常量的对象。`const_cast`只能正确转换顶层（引用，指针）的常量性质，但是无法正确转换底层（引用的本体，指针指向的对象）的常量性质。强行转换会导致未定义行为。**

# 迭代器失效

我总是把迭代器失效理解成错误的含义。我们简单讲一下真正的含义是什么，不作具体细节展开

```c++
    vector<int> a = {1,2,3,4,5,6,7,8,9,10};
    auto it = a.end();
    cout << *(it-1) << endl; //输出10
    cout << a.size()<<endl; //输出10
    cout << a.capacity()<<endl; //输出10
    a.insert(a.begin() + 3, 3333); //插入后扩容，数据转移至新区域，原来区域被释放
    cout << *(it-1) << endl; //输出无效数据，迭代器失效。
```

首先，我们要知道。`begin()` 和`end()`每次都会动态的返回对应的迭代器，所以这俩不会失效。

啥时候会时效呢？**当有一个额外的手动赋值的迭代器出现的时候**

这句话是啥意思呢

比如：

`for(iter = a.begin();;)` 这里你声明了一个新的`iter`来接收这个调用`begin()`返回的迭代器。这就是另一个迭代器

或者如上图的：`auto it = a.end()`。这里也是新的。

所以为什么在for循环里对迭代器操作的时候会失效。因为你操作的迭代器不是动态获取的，而是你已经获取到之后对迭代器进行加减操作的。

另外一个简单例子

```c++
    vector<int> a;
    a.reserve(20);
    for(int i = 0 ;i < 10; i++){
        a.push_back(i);
    }
	//这时候a是{0,1,2,3,4,5,6,7,8,9}
    auto it = a.end();
    cout << *(it-1) << endl; //输出9
    a.insert(a.begin() + 3, 3333);
	//这时候a是{0,1,2,3333,3,4,5,6,7,8,9}
    cout << *(it-1) << endl; //输出8。
}
```

因为迭代器已经被赋值。对迭代器的加减操作我们可以理解为原始数组对指针的加减操作。所以原来的时候，最后一位指向的内存地址存的是9，我们可以理解为`end-1`是`begin+9`。我们执行`insert`之后，由于迭代器没有重新赋值，所以`begin+9`指向的内存地址不变。但是`insert`会让插入位置后的元素后移，8会被移到原来9的内存地址上。这样就是迭代器失效。

# eplicit

叽叽歪歪一大堆没意思。先看一个关键知识点

**当一个构造函数只有一个参数，而且该参数又不是本类的`const`引用时（这里存在不同说法。一说是只要不是本类类型即可），这种构造函数称为转换构造函数，即转换构造函数为单参构造函数的一种**。这里的只有一个参数可以拆分为，**只有一个形参**，或，**形参中只有一个没有默认值。**

**explicit只能限制住拷贝初始化，并不能限制直接初始化。我们下面提到了四种隐式转换的条件。**

啥意思？

## 只有一个形参

```c++
class A
{
public:
    A(int i):a(i){} 		//单参构造函数
    int getValue()
    {
        return a;
    };
private:
    int a;
};
```

```c++
int main(){
    A a = 10;			//case1
    A a(10);			//case2 注意这是直接初始化，不会受到explicit限制。
    A a;				//case3
    a = 10;
    return 0;
}
```

case1中，我们没有临时对象。而是直接把10作为参数传递给类型转换构造函数。使用了拷贝初始化（先调用默认构造，再调用拷贝构造）这虽然使用了"="，但是实际上我们在创建新对象。创建新对象的时候一律是拷贝构造而不是拷贝赋值。因为对象还不存在

case2中，我们没有临时对象，使用直接初始化调用默认构造。

case3中，我们有临时对象。编译器执行 `a = 10;`的时候相当于先使用 `A(10);`在栈中创建了一个临时对象。然后再调用对象`a`的拷贝赋值 `a(10)` 给`a`初始化（因为对象a已经存在）。然后临时对象销毁。这就是编译器做的隐式转换工作。

也就是说，如果我们使用了`explicit`，这里将会变成：

```c++
A a;
a = A(10); 	//显式调用构造函数 禁止隐式转换
```

## 多个形参但是只有一个没有默认值

```c++
class A
{
public:
    A(int i, int j = 5):a(i),b(j){} 		//单参构造函数
    int getValue()
    {
        return a;
    };
private:
    int a;
    int b;
};
```

原理和上面一样。但是有一个知识点：函数默认值假如第N个参数有，那么N后面的参数必须全都有。

## 发生隐式转换的条件

注意！由四种情况会发生隐式转换：

- 混合类型的算数运算表达式。

```c++
int a = 3;
double b = 4.5;
a + b; // a将会被自动转换为double类型，转换的结果和b进行加法操作
```

- 不同类型的赋值操作。（这里包含拷贝初始化）

```c++
int a = true ; ( bool 类型被转换为 int 类型)
int * ptr = null;（null被转换为 int *类型）
```

- 函数参数传值

```c++
void func(double a);
func(1); // 1被隐式的转换为double类型1.0
```

- 函数返回值。（此处例子）

```c++
double add( int a, int b)
{
    return a + b;
} //运算的结果会被隐式的转换为double类型返回

```

针对第四种我们举个例子。看代码：

```c++
class tmp{
    public:
    string _text;
    tmp(string c): _text(c) {}			//单参构造，可以看做转换构造

};
class test{
    public:
    string _text;
    test(string a): _text(a){}		//单参构造，可以看做转换构造
    test(tmp s): _text(s._text){}  //单参构造，可以看做转换构造。此处入参是tmp类型，return一个test类型，可以看成tmp可以转为test
};
class twonumber{
    public:
    test ret(){
        test(tmp("cde"));
        return(tmp("abc")); //此处返回的对象是一个tmp，但是函数头的返回类型却是test。可以运行。这里使用了构造函数的隐式转换。使用了临时对象
        return(test(tmp("abc"))); //如果设置了explicit，则需要这样进行显式转换。
    }
    //!由于return语句内是隐式转换，所以对应的构造函数如果有explicit关键字则无法进行隐式转换。即便这里看起来像拷贝初始化。

};
int main(){
    twonumber ttt;
    test rrr = ttt.ret();
    cout << rrr._text << endl;
    return 0;
}
```



## 说到底，我们啥时候想禁用呢？

- 当类中同时存在“non-explicit-one-argument 构造函数和类型转换函数的时候。有可能产生二义性。所以需要对“non-explicit-one-argument构造函数前加explicit防止编译器隐式自动转换类型



**再次重申，explicit只限制拷贝初始化，不限制直接初始化。而且对象类型不可以为本类类型。因为如果是本类类型那还转换个屁。**

```c++
A a(5);		//可以。直接初始化
A a = 5;	//不可以，拷贝初始化。
A b(a);		//可以。对象类型为本类，不属于类型转换。不发生隐式转换。
A b = a;	//可以。对象类型为本类，不属于类型转换。不发生隐式转换。
```

# 对于类来说，直接在类型后面加上括号，就是调用构造函数

类型后面+名字再+括号只不过是给了个名字而已。

```c++
class p{
    public:
    int a;
    int b;
    p(){}
    p(int x, int y):a(x),b(y){}

};
int main(){
    p t1;
    t1.a(5); //这是啥东西？构造函数怎么能构造出来对象的变量而不是对象本身呢？怎么可以通过构造函数给变量赋值？
    t1.a = 5;//对了
    
	
}
```

# 非类型模板参数

这块之前居然忽略了。必须简单说一下

```c++
template<typename T>
void func(T obj){
    //...
}

int main(){
    func<int>(5);
    return 0;
}
```

我们都知道模板参数一般都是类型。比如这里，T就是int。是类型。

但是如果我们有时候需要一些特殊情况， 例如想要传点奇怪东西的时候。

```c++
template<typename T, int MAXSIZE>
void func1(T obj){
    vector<T>a;
    a.reserve(MAXSIZE);
    cout << a.capacity() << endl;
    a.push_back(obj);
    cout << a[0] << endl; 			//干啥了不解释了 忽略即可
}

```

这里的int MAXSIZE就是非类型模板参数。因为他不是类型，而是变量。

使用非类型模板参数是有限制的。通常它们只能是整型常量（包含枚举，或可隐式转换的比如`bool`）（`string` `double`都不可以。前者是类对象，后者是浮点数），指向objects/functions/members的指针，objects/functions的左值引用以及`std::nullptr_t`。

当传递对象的指针或者引用作为模板参数时，对象不能是字符串常量，临时变量或者数据成员以及其他子对象。由于C++17之前，C++每次版本更新都会放宽以上限制，因此还有一些针对不同版本的限制：

- C++11中，对象必须要有外部链接
- C++14中，对象必须是外部链接或者内部链接

所以：传入的`s`必须是常量。

```c++
const int s = 4;	//必须是const
func1<int, s>(5);
```

# enable_if

简单看一下原型

```c++
template <bool, typename T=void>
struct enable_if {
};
template <typename T>
struct enable_if<true, T> { ///< 第一个模板参数为 true
  using type = T;           ///< type 才有定义
};
```

意思就是，前面的表达式为真，后面的类型定义才有意义。

一般三种用法：

- 控制函数返回类型
- 校验函数模板参数类型
- 类型偏特化

这里就随便写个控制函数返回类型的例子：

```c++
template<int stat> //这里是非模板类型参数。上面提到了。注意一下
typename enable_if<stat == 1, bool>::type checkstate(){
    cout <<"type is bool" << endl;
    return true;
}
template<int stat>
typename enable_if<stat == 0, int>::type checkstate(){
    cout <<"type is int" << endl;
    return 5;
}

template<bool stat>
typename enable_if<stat == true, int>::type checkstate1(){
    cout <<"type is int" << endl;
    return 5;
}

int main(){
    const int myobj = 1; 	//必须是const
    checkstate<myobj>();	//输出"type is bool" 
    checkstate<0>();		//输出"type is int" 
    return 0;
}
```

几个注意事项。返回类型前必须加`typename`来告知`enable_if::type`是个类型
