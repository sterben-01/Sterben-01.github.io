---
title: C++杂记 - 2
date: 2022-07-20 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true

---

# C++杂记 - 2

# 关于`delete this`

## 能否在类的析构函数中调用`delete this`?

**不能**

实验告诉我们，会导致堆栈溢出。原因很简单，**`delete`的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存**显然，`delete this`会去调用本对象的析构函数，而析构函数中又调用`delete this`，形成无限递归，造成堆栈溢出，系统崩溃。

## 能否在类的其它函数中调用`delete this`？

**可以，但不可以涉及到任何和this指针（成员变量，成员函数，虚函数）相关的东西。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。**

首先，让我们明确几点概念

- 在类对象的内存空间中，只有数据成员和虚表指针，并不包含代码内容。类的成员函数单独放在代码段中
- 在调用成员函数时，隐含传递一个`this`指针，让成员函数知道当前是哪个对象在调用它。当 调用`delete this`时，类对象的内存空间被释放。在`delete this`之后进行的其他任何函数调用，只要不涉及到`this`指针的内容，都能够正常运行。一旦涉及到`this`指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。

- **`delete this`释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的。这时访问数据成员可能是随机数，访问虚表发生指针无效的概率很高，系统崩溃。**

## 什么时候可以？

`this`指向的实例必须是`new`出来的，不能是`new[] `/`placement new`出来的，也不能是栈上的，也不是全局变量。只能是简单的`new`出来的。

调用了`delete this` 的成员函数（下面称为当事函数）**返回**后，这个实例不可以调用其他任何成员函数（这好理解，涉及到`this`指针，因为实例不存在了）。这个成员函数应当成为这个实例访问的最后一个函数。

调用了`delete this` 的成员函数后（从`delete this`这一行之后开始），这个实例不可以调用任何成员函数和成员变量（这好理解，理由同2）

调用了`delete this`之后，不得以任何形式提及`this`，包括比较、打印、类型转换等（因为this已经不存在了）。



## 换言之，为什么一个指向类成员的指针被delete并置空后依旧可以调用不访问类成员数据的函数？或者是为什么一个类类型的空指针可以访问类内非虚且不访问成员变量的函数？

```c++
class myclass{
    public:
        void print(){
            cout <<"myclass" << endl;
        }

        int vala = 10;//类成员没有被print函数访问。

};
int main(){
    myclass* ptr = new myclass();
    ptr->print(); //输出myclass
    delete ptr;
    ptr = nullptr;
    ptr->print(); //输出myclass
    return 0;
}
```



我们看到`delete`后依旧可以调用没有访问类成员的函数。**另一个前提是该函数不是虚函数。因为虚函数的调用需要依靠对象的虚函数指针找虚函数表。调用`delete`资源释放后置空导致和`this`有关联了。所以报错。**

**非虚的类成员函数在编译的时候就已经解决了访问问题。也就是编译成带作用域的全局函数。并添加`this`形参。**也就是访问非虚而且不访问类成员(变量)的函数是不涉及到`this`指针的。虽然指针必须要被传入，但是传入参数并不关心当前指针是否有效。只要没有解引用`this`指针即可。



我们再思考一下。如果上面的例子换成C写是什么样子的？

```c++
struct myclass_inC{
    int vala = 10;
};

void print(myclass_inC* self){
    cout <<"myclass" << endl;
}


int main(){
    struct myclass_inC *myclass_c = NULL;
    print(myclass_c); //输出my_class
    return 0;
}
```

在深度探索C++对象模型的笔记4.1我们提到：

> 因为编译器会把每所有的非虚函数（此处不确定是否正确。有的笔记里写的是普通函数，普通成员函数和静态成员函数。书里此处没有提及静态成员函数。）进行处理：
>
> 1. 首先是把对象调用的方式改为值调用。也就是在形参的第一个位置放一个this指针（指向对象的指针）做为入参
>
> 2. 其次是把函数内对于非静态数据成员的直接操作变成用this指针的操作。
>
> 3. 然后是名称重新编译成独特名称（这一步的目的是实现重载。注意，C++重载是依靠名称和参数，C只有名称）
> 4. 最后是实施NRV优化（如果有）
>
> 类成员函数在处理后可以理解为变成了带作用域的全局函数。虚函数也只不过是多了查表的步骤。

我们上面用C写的例子和处理后的非虚类成员函数差不多。此时我们可以看到。尽管我们的类指针是空的。但是它依旧符合函数入参类型。而且我们在函数内并没有通过这个指针访问任何数据成员。所以并不会报错。单纯传递空指针是可以的。所以是可以调用这样的成员函数的。

# 什么时候需要虚析构函数

是多态基类的时候。多态一定有虚函数。（effective C++ 第七条)

**多态实现：通过指针+向上转换(子类转父类)(父类指针指向子类对象） + 虚函数 = 动态绑定 、虚机制**

## 为什么如果析构函数不是虚函数的时候，仅仅执行父类析构函数？

很多人可能会有疑问，问我们知道构造顺序是先父类构造再子类构造，析构顺序是先子类析构再父类析构（仅多态情况）。那么为什么我父类析构不是虚析构的时候仅执行父类析构？难道不应该是仅执行子类析构吗？

**因为忘了一点，多态调用必须是虚函数才可以，仅通过父类指针指向子类对象是不会触发虚机制（动态绑定（多态））的。**

**虽然父类指针可以指向子类，但是其访问范围还是仅仅局限于父类本身有的数据，那些子类的数据，父类指针是无法访问的。**

### 类继承是静态绑定，包含虚函数的情况才是动态绑定

```c++
class A{
    public:
    A(){}

};

class B: public A{
    public:
    B(){}
    int bval = 3;
};

class C :public B{
    public:
    C(){}
    int cval = 4;
};

int main(){
    A* a = new C;
    cout << a->bval << endl; //错误。类A没有成员bval
}
```

当定义一个指向子类实例的父类指针的时候，内存中实例化了子类，由于子类继承了父类,因此内存中的子类里包含父类的所有成员。但由于**申明的是父类指针，因此该指针不能够访问子类的成员，而只能访问父类的成员。然而在父类里可以声明纯虚函数和定义虚函数，使用父类指针访问虚函数或纯虚函数的时候，访问到的是子类里重写的函数。当然，对于虚函数，如果子类里没有对其重写的话，仍然访问到父类里定义的虚函数**。



**父类指针指向子类对象，仅可访问子类的父类部分。因为不知道子类的内存布局，所以没法访问子类的部分。也就是说，父类指针指向子类对象会发生隐式转换。所以说它还是个父类类型。**

多态的时候由于有RTTI所以可以在运行时获知子类类型。



**我们提到过，指向虚表的指针`_vfptr`是子类的父类部分。也就是父类指针可以访问的到子类的指向子类自己的虚表的指针`_vfptr`。父类访问这个指针后即可访问子类的虚表。（反复强调虚表一个类只有一个）。访问到这个虚表后，就会查表。即访问对应的虚函数。如果子类有重写，那么这个对应的虚表中的函数会在编译期就从父类的覆盖为子类的。这样就可以执行子类的函数了。如果子类没写，那个虚表里面的函数就还是父类的虚函数。**

所以，如果没有虚析构，则虚表里没有这一条。那么编译的时候发现不是虚函数，就会静态的将父类的析构函数编译过来。如果有了虚析构，则虚表里会有这一条。于是就会执行正常多态析构动作，先调用子类析构，再调用父类析构。也就是根据指向的对象找到对象的虚表指针，找到对象的虚表再调用对应的虚函数。实现多态。



# 运算符的重载，参数的数量怎么确定？在类里面和不在类里面？不在类里面声明怎么访问类里面的属性（如果是私有的呢？）

## 运算符重载

```c++
class multiple{
    public:
    int vala;
    int valb;
    multiple(){}
    multiple(int x, int y):vala(x), valb(y){}
    const multiple operator*(const multiple& rhs) const{
        multiple temp(this->vala * rhs.vala, this->valb*rhs.valb);
        return temp;
    }
    注意 乘法我们说是有两个参数即a*b 但是这里现在是成员函数，第一个参数默认是调用对象 即this 所以形参只有一个rhs。
    但是我们可以写为非成员函数，这样形参就会有rhs和lhs。
    非成员函数在进行隐式类型转换的时候可以实现交换律。参考effectiveC++ 条款24
    void getval(){
        cout << this->vala<< ", " << this->valb << endl;
    }

};

const multiple operator*(const multiple& lhs, const multiple& rhs){
    multiple temp(lhs.vala * rhs.vala, lhs.valb*rhs.valb);
    return temp;
}

//类外可以这么写。注意const不可修饰非成员函数！！
int main()
{
    multiple t1(5,5);
    multiple t2(6,4);
    multiple t3 = t1 * t2;
    t3.getval();
这里t3 = t1 * t2本质上是t3 = t1.operator*(t2)
t1是this，t2是rhs，t1.operator*(t2)对应函数返回值
}
```

 注意 这里重载第三个const的目的是让这个函数成为const函数。目的是可以被const对象调用 这里的例子就是我们避免意外赋值，使重载返回值也是const 因为如果不设置const的话 像是

```c__
(t1 * t2) = t3;
```

这种就不会报错。因为t1\*t2被当成了一个multiple类型的变量。可以给它赋值。因为它返回一个multiple对象。但是这违背了我们的意愿。所以我们加const来模拟常量确保t1\*t2不会被赋值 如果我们这个重载函数不设置const属性（也就是第三个const）的话，我们这样就无法链式调用了。因为我们现在的t1\*t2返回的是一个const multiple对象。const对象无法调用非const函数。所以我们的函数必须要const 

- 当运算符重载为**类的成员函数**时，函数的参数个数比原来的操作数要少一个（后置单目运算符除外），这是因为成员函数用this指针**隐式地访问了类的一个对象**，它充当了运算符函数最左边的操作数。因此：

  - 双目运算符重载为类的成员函数时，函数**只显式说明一个参数**，该形参是运算符的右操作数。

  - 前置单目运算符重载为类的成员函数时，**不需要显式说明参数**，**即函数没有形参**。

  - 后置单目运算符重载为类的成员函数时，函数要带有一个整型形参。

  - 调用成员函数运算符的格式如下：
    ```c++
    <对象名>.operator <运算符>(<参数>)
    它等价于
    <对象名><运算符><参数>                
    ```

- 当运算符重载为**类的友元函数**时，由于没有隐含的this指针，因此操作数的个数没有变化，所有的操作数都必须通过函数的**形参**进行传递，函数的参数与操作数自左至右一一对应。调用友元函数运算符的格式如下：

  ```c++
  operator<运算符>(<参数1>,<参数2>)
  它等价于
  <参数1><运算符><参数2>
  ```
  - 友元函数不属于任何类，但是可以当做类成员函数使用，即访问私有部分。**友元函数必须在类内声明。但是可以在类内或类外定义**
  ```c++
  class multiple{
      public:
      multiple(){}
      multiple(int x, int y):vala(x), valb(y){}
      friend const multiple operator*(const multiple& lhs, const multiple& rhs); //类内声明
      void getval(){
          cout << this->vala<< ", " << this->valb << endl;
      }
      private:
      int vala;
      int valb;
  
  };
  const multiple operator*(const multiple& lhs, const multiple& rhs){ //类内或类外定义均可。
      multiple temp(lhs.vala * rhs.vala, lhs.valb*rhs.valb);
      return temp;
  }
  int main()
  {
      multiple t1(5,5);
      multiple t2(6,4);
      multiple t3 = t1 * t2;
      t3.getval();
  }
  ```

- 在类外，因为不是成员函数所以没有this指针，所以必须要有全部参数。



#### 注意，类外的运算符重载（此处指的是类的运算符而不是函数调用运算符）的时候，不能单独写一个类。要么在原来的类里面，要么是全局函数

```c++
class myclass{
    public:
    int val1;
    int val2;
    myclass(){}
    myclass(int x, int y):val1(x), val2(y){}
    bool operator()(const myclass& a, const myclass& b){
        cout <<"comp" <<endl;
        return a.val1 < b.val1;
    }
    
};

class mycomp{						//这么写是错的。这里的运算符重载被当做了mycomp的运算符重载
    public:
    bool operator<(const myclass& a, const myclass& b){
        cout <<"comp11" <<endl;
        return a.val1 < b.val1;
    }
};
bool operator<(const myclass& a, const myclass& b){
        cout <<"comp11" <<endl;
        return a.val1 < b.val1;
    }


int main()
{
    set<myclass> myset;					//如果重载的是小于号，则写在类内类外都不需要在模板处指定排序类型。
    set<myclass, myclass> myset1;		//如果重载的是括号也就是调用运算符，则无论写在类内类外都需要在模板处指定排序类型。
    myset.insert(myclass(5,10));
    myset.insert(myclass(1,10));
    myset.insert(myclass(10,10));
	return 0;
}
```





#### 如果是指针容器呢？

```c++
class myclass{
    public:
    int val1;
    int val2;
    myclass(){}
    myclass(int x, int y):val1(x), val2(y){}
    bool operator()(const myclass& a, const myclass& b) const {
        cout <<"comp" <<endl;
        return a.val1 < b.val1;
    }
    bool operator()(const myclass* a, const myclass* b){
        cout <<"comp112" <<endl;
        return a->val1 < b->val1;
    }
    
};


class mycomp{
    public:
    bool operator()(const myclass* a, const myclass* b){		//写在类外
        cout <<"comp11" <<endl;
        return a->val1 < b->val1;
    }
};
int main()
{
    set<myclass*, myclass> myset;				//指针容器，必须使用重载函数调用运算符的方式，并且指定其类型。可以写在类外
    set<myclass*, mycomp> myset;				//也可以
    myset.insert(new myclass(5,10));
    myset.insert(new myclass(1,10));
    myset.insert(new myclass(10,10));
	return 0;
}
```

**指针容器，必须使用重载函数调用运算符的方式，并且指定其类型。可以写在类外。重载普通的运算符 如 `<`，要求形参必须是类类型。但是指针不是类类型。所以无法写在类外。而且，对象指针和对象不是一个东西。对象指针依旧是指针类型。所以他会去指针的类里面找重载，写在类内的重载无法被触发。**





## 成员访问运算符 -> 重载

类成员访问运算符（` ->` ）可以被重载，它被定义用于为一个类赋予"指针"行为。**运算符 `-> `必须是一个成员函数。如果使用了 `-> `运算符，返回类型必须是指针或者是类的对象。**

```c++
class obj{
    public:
    int val;
    obj(int x):val(x){};

    void objfunc(){
        cout <<"obj" << endl;
    }
    void getval(){
        cout << val << endl;
    }
};
class objhelper{
    public:
    objhelper(){
        objptr = new obj(10); //构造函数初始化另一个类的对象
    }
    obj* operator->(){ //注意，返回的是obj类的指针。
        return objptr;
    }

    ~objhelper(){
        delete objptr; //析构函数释放对象。
    }
    obj* objptr; //类内持有一个另一个类的指针。

    
};
int main(){

    objhelper helper;
    helper->objfunc(); //输出obj
    helper->getval();  //输出10

    return 0;
}
```

从上面代码我们可以看到，重载类成员访问运算符多半是起到一个帮助作用，帮助我们访问另一个类。

重载成员访问运算符根据调用者的类型不同，有两条作用规则：

1. 如果调用者是指针，则按照内置的箭头运算符去处理。表达式等价于`(*调用者).member`。首先解引用该指针，然后从所得的对象中获取指定的成员。如果调用者所指的类没有名为member的成员，则编译器报错。
2. 如果调用者是一个定义了`operator->() `的类对象，则`调用者->member`等价于`调用者.operator->() ->member`。其中，如果`operator->()`的返回结果是一个指针，则转第1步；如果返回结果仍然是一个对象，且该对象本身也重载了`operator->()`，则重复调用第2步，否则编译器报错。最终，过程要么结束在第一步，要么无限递归，要么报错。
   https://blog.csdn.net/friendbkf/article/details/45949661

## 解引用运算符`*`重载

`*`是一个一元操作符，作用于指针，获取指针所指单元的内容。当某个类中对`*`操作符重载时，是将该类对象当做一个指针看待，用`*`操作符提取指针所指向的内容。**它一般有两个版本。一个是普通成员函数返回某个类中的指针的解引用的引用，也就是指针指向的对象的引用。另一个版本是常量成员函数返回`const`引用。（再次强调返回值不是函数签名。但是修饰成员函数的const是函数签名）**

- 为什么要返回引用？如果不返回引用则无法给解引用的对象赋值。比如`*ptr = 200`
  - 不返回引用的话，解引用返回的是一个临时对象，是右值。无法给右值赋值。

```c++
//在上面的代码中添加：
obj& operator*(){ //返回的是引用！！
    return *objptr; //返回类内指针的解引用
}

const obj& operator*() const{
    return *objptr;
}
```

## 解答：

1. 在类内，如果是双目运算符就少一个。因为左手部分是this。隐式传递。如果是类外，就正常两个。
2. 不在类里面声明，可以正常访问类公有部分。如果需要访问私有部分就需要使用友元函数。


## 关于为什么赋值运算符重载一般都返回引用

比如在移动赋值或者拷贝赋值中返回的都是引用。

原因主要是性能。

- 链式调用：

```c++
a = b = c;
//就是先执行b=c然后执行a = b。等价于
a.operator=(b.operator=(c))
```

此时若不返回左值的引用，将会生成临时对象，



# 关于mutable

很多人多`mutable`有错误认知。不仅仅是因为用得少，而且是有模糊概念。

**`mutable`是修饰成员变量所用。他的作用是让这个成员变量在任何时候都可以被修改，无论是:**

1. 做为参数传入形参带有`const`的函数
2. 做为参数传入被`const`修饰的(成员)函数
3. 在被`const`修饰的(成员)函数中
4. 被`const`修饰的变量中

首先举反例：

```c++
mutable int a; //这是啥？
const mutable int a; //这又是啥？
```

下面，正式开始举例：

```c++
class multiple{
    public:
    multiple(){}
    multiple(int x, int y):vala(x), valb(y){}
    
    
    mutable int vala;
    int valb;

};
```

我们拿到了类的定义。我们开始举例

```c++
mutable const int vala; //不可以 这啥玩意
const mutable int vala; //不可以 这啥玩意
```

**为了简便起见，我们只举成员函数的例子**

```c++
class multiple{
    public:
    multiple(){}
    multiple(int x, int y):vala(x), valb(y){}
    //------------------------------------- 被const修饰的成员函数
    void test1(multiple& x) const{
        vala = x.vala;
        x.vala = vala;
    }
    //-------------------------------------被const修饰的函数形参
    void test2(const multiple& x){
        vala = x.vala;
        x.vala = vala;
    }
    //-------------------------------------被const修饰的成员函数 和 被const修饰的函数形参
    void test3(const multiple& x) const{
        vala = x.vala;
        x.vala = vala;
    }
    //-------------------------------------
    mutable int vala;
    int valb;
};
```

**以上三个函数代表了三个例子。我们发现被无论是在被`const`修饰的成员函数中 还是 被当成参数传入被`const`修饰的函数形参中，我们都可以修改`mutable`修饰的变量。**

还有第四个例子

```c++
const multiple t1(3,3);
t1.valb = 3; //不可以
t1.vala = 3; //可以 因为被mutable修饰
```



# 四种cast强制类型转换表达式（运算符/关键字/特殊运算符），都不改变对象本身。

- **四种cast强制类型转换是表达式（特殊运算符）。**他只是长得像类模板但是不是。
  - 这类运算符还包括如`new`, `delete`, `sizeof`, `typeid`,`noexcept`等。
- 四种cast强制类型转换对转换对象没有任何影响。他只是生成一个你想转换的类型的临时变量。
- 强制类型转换并不改变原对象类型，只是通过原对象生成新的对象。


例子：

```c++
float ss = 10.12345;
cout << ss << endl; //10.12345
cout << static_cast<int>(ss) << endl; //10
cout << ss <<endl; //10.12345
```

由此可见，强制类型转换会生成一个转换类型的临时变量。并不改变原来的对象。



## 强制类型转换可以进行引用类型的转换

其实就是通过原对象生成一个原对象的引用。这个操作合法。

例子：

```c++
float ss = 10.12345;
float& dd = static_cast<float&>(ss); //生成一个ss的引用。也就是通过ss生成一个新的float&类型的对象。
cout << dd <<endl; //10.1235
dd = 9.324;
cout << dd << endl; //9.324
cout << ss << endl; //9.324
```





# 关于`static_cast` 和 `const_cast`之间的区别

## `static_cast`

```c++
static_cast <type-id> (expression)
```

将expression转换为type-id类型，主要用于非多态类型之间的转换，不提供运行时的检查来确保转换的安全性。主要在以下几种场合中使用：

1. 用于类层次结构中，父类和子类之间指针和引用的转换；
   - 当进行上行转换，也就是把子类的指针或引用转换成父类表示，这种转换是安全的；
   - 当进行下行转换，也就是把父类的指针或引用转换成子类表示，这种转换是不安全的，也需要程序员来保证；
2. 用于基本数据类型之间的转换，如把`int`转换成`char`，把`int`转换成`enum`等等，这种转换的安全性需要程序员来保证；
   - **static_cast可以转换对象。**
     - 转换对象的前提是：
       - 基础类型之间：提到过比如`int`换成`char`
       - **有继承关系之间的对象。且由于是对象，只能进行上行转换。也就是子类对象转为父类对象。父类对象转为子类对象不可能的。**因为只能往小切，不能往大扩。多出来的内存空间不知道用来作什么。
       - **可被转换（如拥有转换(构造)函数）的对象**
3. 把void指针转换成目标类型的指针，是及其不安全的；

-  **static_cast不能转换掉表达式的const、volatile和__unaligned属性。**

## `dynamic_cast`

```c++
dynamic_cast <type-id> (expression)
```

将expression转换为type-id类型

- **dynamic_cast转换仅适用于指针或引用。**

- **type-id必须是类的指针、类的引用或者是void *；如果type-id是指针类型，那么expression也必须是一个指针；如果type-id是一个引用，那么expression也必须是一个引用。**

dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；**在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。在多态类型之间的转换主要使用dynamic_cast，因为类型提供了运行时信息。**就像我在虚表那一章节说的。虚表头还有一块东西就是RTTI，表明了当前类的类型信息。

**一般来说，dynamic_cast 用于下行转换的时候，只能用于有虚函数表的类。因为dynamic_cast依赖于RTTI的type_info，然而这个信息储存在虚函数表的头部。**

这个`dynamic_cast`是怎么用的呢？我们父类指针指向子类对象的时候，限制了指针仅可以读取子类对象的父类部分。我们进行`dynamic_cast`的时候，会使用RTTI信息。这个信息是储存在虚函数表的头部。也就是编译器找到了虚函数表指针（子类对象的虚函数表指针一定指向自己的虚函数表，所以RTTI信息类型也是子类），然后问RTTI：”这人想要让我转换成子类，也就是多读点儿子类的东西，你帮我看看我指向的对象到底是不是子类，多读的那部分被正确初始化了没有？合法不合法？“。RTTI看了一眼回答：”哦，你指向的部分实际类型确实是一个子类的类型，因为他`new`的时候`new`的是一个子类对象。我检查了，都初始化了，也合法，那你就多读点儿吧“。这就是`dynamic_cast`和RTTI的联系。

**有一个实际问题，当我们需要判断该指针实际指向的类型的时候，假如我们加了一堆ifelse然后用dynamic cast判断，这非常慢，尤其是继承非常复杂的时候，效率非常低。需要注意。所以很多引擎的RTTI是自己的。**

**`dynamic_cast` 在传入引用和指针的时候不一样。**

- 使用指针的时候，如果可以转换则传回真正的地址。
- 如果不可以则会返回0（`nullptr`）表示转换失败

但是使用引用的时候却不可以这样。首先，引用不能像指针那样设置为0。设置为0代表着有一个临时对象产生出来，然后这个临时对象初始值为0，然后这个引用成为了这个临时对象的别名。（右值相关，对吧。）

- 所以使用引用的时候，如果可以转换则会把对象引用至正确的子类。
- 但是如果失败，由于引用不可以传0，则会抛出一个`bad_cast_exception`

# 关于`const_cast`

## 给一般读者：

- 常量指针（指向常量的指针）被转化成非常量的指针，并且仍然指向原来的对象；
- 常量引用被转换成非常量的引用，并且仍然指向原来的对象；

我们来看代码：

```c++
using namespace std;
class multiple{
    public:
    multiple():valc(0){}
    multiple(int x, int y, int z):vala(x), valb(y), valc(z){}
    int vala;
    int valb;
    const int valc;

};

int main()
{
    multiple p(1,3,5);
    const multiple* const_ptr = &p; 					//指向常量的指针
    //---------------------------------------------------------------------
    const_ptr = const_cast<multiple*> (const_ptr);		//进行const cast
    const_ptr->vala = 100;								//不可以, 必须要赋值给新的指针。
    const_cast<multiple*> (const_ptr)->vala = 100; 		//可以

    //---------------------------------------------------------------------
    multiple* ptr = const_cast<multiple*> (const_ptr);	//赋值给新指针
    ptr->vala = 10;										//可以
    ptr->valc = 100;									//不可以。因为valc是常量。
}
```



### 具体使用场景

### 1. **一个函数的形参不是const指针/引用，并且编程者事先已经知道在这个函数中不会对参数进行修改，但需要传递的实参却是已经定义好的const对象。为了成功调用这个函数，就需要利用到const_cast在实参传递前对其进行处理，从而使函数能够成功接收这个实参**

代码：

```c++
void Function(int &val){
    cout<<val<<endl;
}
int main(){
    const int value=21;
    Function(value);					//不可以
    Function(const_cast<int&>(value));	//转换为常量引用，可以
    return 0;
}
```





### 2. **如果我们定义了一个非const的变量，却使用了一个指向const对象的指针来指向它，而在程序的某处希望改变这个变量时发现只有指针可用，此时就可以const_cast进行处理**

```c++
int main(){
    int value=26;
    const int* const_ptr=&value;
    *const_ptr=3;							//不可以
    int* ptr=const_cast<int*>(const_ptr);	//转换为非常量指针。可以
    *ptr=3;
    return 0;
}
```



- **使用const_cast去除const限定的目的绝对不是为了修改它的内容，只是出于无奈**

## 给能思考的读者。因为这里我还没有完全弄明白，可能存在错误

我们直接看代码

```c++
class multiple{
    public:
    multiple():valc(0){}
    multiple(int x, int y, int z):vala(x), valb(y), valc(z){}
    int vala;
    int valb;
    const int valc;

};
int main()
{
    const multiple np(2,4,6);					//常量对象
    multiple ucnp = const_cast<multiple&>(np);	//这里下面会解释
    ucnp.vala = 10;
    //---------------------------------------------------------
    cout << ucnp.vala<< endl;						//输出10
    cout << ucnp.valb<< endl;						//输出4	
    cout << ucnp.valc<< endl;						//输出6
    //---------------------------------------------------------
    cout << np.vala<< endl;						//输出2
    cout << np.valb<< endl;						//输出4	
    cout << np.valc<< endl;						//输出6
}


```

**这里面我们进行`const_cast`的时候返回值并没有使用引用来接受。这是可以的。这里会产生一个临时变量做为中间值传给了结果值**

**有没有注意到问题，我们的`np`不是引用，是个对象。可能无法直观感受，我们接着看**  

这句话不知道对不对。来自：https://www.cnblogs.com/dracohan/p/3417842.html

下面有更狠的。

我们把`ucnp`换成引用。看看结果如何

```c++
int main()
{
    const multiple np(2,4,6);					//常量对象
    multiple& ucnp = const_cast<multiple&>(np);	//注意这里
    ucnp.vala = 10;
    //---------------------------------------------------------
    cout << ucnp.vala<< endl;						//输出10
    cout << ucnp.valb<< endl;						//输出4	
    cout << ucnp.valc<< endl;						//输出6
    //---------------------------------------------------------
    cout << np.vala<< endl;						//输出10
    cout << np.valb<< endl;						//输出4	
    cout << np.valc<< endl;						//输出6
}

```

**好像没什么问题啊？确实是这样的嘛。常量引用转换成非常量引用，有啥问题？**

**你再仔细看一眼。`np`是什么？是对象啊。这是个常量对象啊，我们修改了常量对象啊！**

我们可以来一个更明显的例子：

```c++
int main{
    
    multiple p(1,3,5);
    cout << p.valc << endl;					//输出5
    int& wtf = const_cast<int&>(p.valc);	//修改常量。
    wtf = 1000;
    cout << p.valc << endl;					//输出1000
    return 0;
}
```

**我们的`valc`是一个`const int`。但是这里我们修改了一个对象里的常量。**

**以上操作，编译器没有任何警告。但是这应该是一个未定义行为。需要避免修改任何已经声明为常量的对象。`const_cast`只能正确转换顶层（引用，指针）的常量性质，但是无法正确转换底层（引用的本体，指针指向的对象）的常量性质。强行转换会导致未定义行为。**



# eplicit 和 隐式类型转换

叽叽歪歪一大堆没意思。先看一个关键知识点

**当一个构造函数只有一个参数，而且该参数又不是本类的`const`引用时（这里存在不同说法。一说是只要不是本类类型即可），这种构造函数称为转换构造函数，即转换构造函数为单参构造函数的一种，又是类型转换函数的一种**。这里的只有一个参数可以拆分为，**只有一个形参**，或，**形参中只有一个没有默认值。**

- **注意了。这里提到的是转换构造函数。下面提到的`operator`开头的叫用户定义转换函数。**

**explicit只能限制住拷贝初始化，并不能限制直接初始化（杂记1拷贝初始化那段里面有原因）。我们下面提到了四种隐式转换的条件。**

啥意思？

## 只有一个形参

```c++
class A
{
public:
    A(int i):a(i){} 		//单参构造函数
    int getValue()
    {
        return a;
    };
private:
    int a;
};
```

```c++
int main(){
    A a = 10;			//case1
    A a(10);			//case2 注意这是直接初始化，不会受到explicit限制。
    A a;				//case3
    a = 10;
    return 0;
}
```

case1中，我们没有临时对象。而是直接把10作为参数传递给类型转换构造函数。使用了拷贝初始化（先调用默认构造，再调用拷贝构造）这虽然使用了"="，但是实际上我们在创建新对象。创建新对象的时候一律是拷贝构造而不是拷贝赋值。因为对象还不存在

case2中，我们没有临时对象，使用直接初始化调用默认构造。

case3中，我们有临时对象。编译器执行 `a = 10;`的时候相当于先使用 `A(10);`在栈中创建了一个临时对象。然后再调用对象`a`的拷贝赋值 `a(10)` 给`a`初始化（因为对象a已经存在）。然后临时对象销毁。这就是编译器做的隐式转换工作。

也就是说，如果我们使用了`explicit`，这里将会变成：

```c++
A a;
a = A(10); 	//显式调用构造函数 禁止隐式转换
```

## 多个形参但是只有一个没有默认值

```c++
class A
{
public:
    A(int i, int j = 5):a(i),b(j){} 		//单参构造函数
    int getValue()
    {
        return a;
    };
private:
    int a;
    int b;
};
```

原理和上面一样。但是有一个知识点：函数默认值假如第N个参数有，那么N后面的参数必须全都有。

## 发生隐式转换的条件

注意！四种情况会发生隐式转换：

- 混合类型的算数运算表达式。

```c++
int a = 3;
double b = 4.5;
a + b; // a将会被自动转换为double类型，转换的结果和b进行加法操作
```

- 不同类型的赋值操作。（这里包含拷贝初始化）

```c++
int a = true ; ( bool 类型被转换为 int 类型)
int * ptr = null;（null被转换为 int *类型）
```

- 函数参数传值

```c++
void func(double a);
func(1); // 1被隐式的转换为double类型1.0
```

- 函数返回值。（此处例子）

```c++
double add( int a, int b)
{
    return a + b;
} //运算的结果会被隐式的转换为double类型返回

```

针对第四种我们举个例子。看代码：

```c++
class tmp{
    public:
    string _text;
    tmp(string c): _text(c) {}			//单参构造，可以看做转换构造

};
class test{
    public:
    string _text;
    test(string a): _text(a){}		//单参构造，可以看做转换构造
    test(tmp s): _text(s._text){}  //单参构造，可以看做转换构造。此处入参是tmp类型，return一个test类型，可以看成tmp可以转为test
};
class twonumber{
    public:
    test ret(){
        test(tmp("cde"));
        return(tmp("abc")); //此处返回的对象是一个tmp，但是函数头的返回类型却是test。可以运行。这里使用了构造函数的隐式转换。使用了临时对象
        return(test(tmp("abc"))); //如果设置了explicit，则需要这样进行显式转换。
    }
    //!由于return语句内是隐式转换，所以对应的构造函数如果有explicit关键字则无法进行隐式转换。即便这里看起来像拷贝初始化。

};
int main(){
    twonumber ttt;
    test rrr = ttt.ret();
    cout << rrr._text << endl;
    return 0;
}
```

### 隐式类型转换都会创建临时对象

我们在上面看到了，为什么下面的类型转换是OK的？

```c++
test ret(){
        test(tmp("cde"));
        return(tmp("abc")); 
}
```

因为虽然我们要返回`test`对象，而且我们实际把一个`tmp`对象塞进去了，但是`test`类有一个使用`tmp`对象为形参的构造函数。编译器此时会调用`test`类的形参为`tmp`的构造函数，生成一个临时对象。然后再把这个`test`类型的临时对象return出去（赋值回去）。

这里比较特殊是做为函数返回值了。可能有NRV优化。但是正常的隐式转换就是这个样子，调用对应类型和入参的构造函数构造临时对象，再赋值。

显式类型转换无非就是手动调用了构造函数。

### 为什么引用传参不会发生隐式类型转换从而产生临时对象？

假设我们有一个函数

```c++
void changesomething(string& s){
    //改变一些东西
}
```

如果此时有隐式类型转换，则一定会有临时对象。那么我们修改的其实是那个临时对象。传入的那个字符串并没有被修改。所以这会引起错误。

**所以c++禁止为非常量引用产生临时对象，而常量引用没所谓。以为常量引用保证了对象不会被修改。注意这个和拷贝没啥关系**

## 说到底，我们啥时候想禁用呢？

- 当类中同时存在“non-explicit-one-argument 构造函数和类型转换函数的时候。有可能产生二义性。所以需要对“non-explicit-one-argument构造函数前加explicit防止编译器隐式自动转换类型
- **explicit可以理解为，在拷贝初始化的时候，尝试去对等号右侧对象进行一个隐式转换以满足等号左侧的类型要求。但是explicit会让隐式转换序列中，忽略掉explicit标注的类型转换函数（转换构造函数或用户定义的类型转换函数）。所以他会找不到对应的转换方式所以约等于禁止隐式转换了。**



**再次重申，explicit只限制拷贝初始化，不限制直接初始化。而且对象类型不可以为本类类型。因为如果是本类类型那还转换个屁。**

```c++
A a(5);		//可以。直接初始化
A a = 5;	//不可以，拷贝初始化。
A b(a);		//可以。对象类型为本类，不属于类型转换。不发生隐式转换。
A b = a;	//可以。对象类型为本类，不属于类型转换。不发生隐式转换。
```



- 可以进行多种构造函数的搭配自由使用


```c++
class obj{
    public:
        obj(){};
        obj(int a):val1(a){};
        explicit obj(int a, int b):val1(a), val2(b){};
    int val1;
    int val2;
};

int main(){
    obj t1; //可以，有默认构造函数
    obj t2(10,20); //可以，explicit只能限制拷贝初始化。这里是直接初始化。
    obj t3 = (10,20);//不可以，禁止隐式类型转换。
    obj t4 = obj(10,20);//可以，显式类型转换。
    obj t5 = (20); //可以。因为这个构造函数没有被explicit修饰
    
    vector<obj> myvec{obj(10,20), (20)}; //可以这样搭配使用。

    return 0;
}
```







# 对于类来说，直接在类型后面加上括号，就是调用构造函数

类型后面+名字再+括号只不过是给了个名字而已。

```c++
class p{
    public:
    int a;
    int b;
    p(){}
    p(int x, int y):a(x),b(y){}

};
int main(){
    p t1;
    t1.a(5); //这是啥东西？构造函数怎么能构造出来对象的变量而不是对象本身呢？怎么可以通过构造函数给变量赋值？
    t1.a = 5;//对了
    
	
}
```

# 类型转换函数 （用户定义转换函数）

我们提到过：**当一个构造函数只有一个参数，而且该参数又不是本类的`const`引用时（这里存在不同说法。一说是只要不是本类类型即可），这种构造函数称为转换构造函数，即转换构造函数为单参构造函数的一种，又是类型转换函数的一种**。

- 所以类型转函数还有一个单独的函数。也就是`operator type（）`。他的作用是把一个类类型转换成另一个类类型。也叫类型转换函数或用户定义转换函数。注意和转换构造函数区别开。

基础语法：

```c++
class Type{
    
    operator OtherType{
        
        OtherType obj;
        //....
        
        return obj;
    }
}
```

**此处，我们的目的是把Type转换为OtherType**

所以可以有这样的类型转换调用（隐式）：

```c++
int main(){
    OtherType obj = Type();
    return 0;
}
```

来看进阶例子。此处是把other转换为test



```c++
class test{
    public:

    int val_1;
    int val_2;
    test(int x = 4, int y = 5):val_1(x), val_2(y){}
};

class other{
    public:
    int val1;
    int val2;
    other(int x = 10, int y = 100):val1(x), val2(y){}
    operator test(){   //用来把other转换为test。
        test obj;
        obj.val_1 = val1;
        obj.val_2 = val2;
        return obj;
    }
};


int main(){
    other O;
    test T;
    cout << T.val_1 << endl;
    T = O;              //other转化为test
    T = (test)O;        //显式
    
    test obj1(other()); //不行，语法不对，会被当成函数。必须要用花括号
    test obj1(other{}); // OK 因为有类型转换。
    
    cout << T.val_1 << endl;
    return 0;
}
```

**类型转换函数会为我们提供隐式类型转换。所以会产生临时对象。**其实代码中就体现出来了。因为我们单独创建了一个对象。

**注意这里我们`test`类没有写自己的拷贝构造。所以编译器默认生成了。当我们执行`test obj1(other{});`的时候，转换函数内部先生成`test`类对象（构造），然后拷贝出来（拷贝构造）然后再使用拷贝出来的`test`临时对象去调用拷贝构造去构造`obj1`（第二次拷贝构造）。[没有编译器优化的时候]**





- **用户自定义的转换函数还可以是虚函数，但是只有从基类的引用或指针进行派发的时候才会调用子类实现的转换函数**

```c++
struct D;
struct B {
    virtual operator D() = 0;
};
struct D : B
{
    operator D() override { 
        cout << "D" << endl;
        return D(); 
    }
};
 
int main()
{
    D obj;
    D obj2 = obj; // 不调用 D::operator D()
    B* br = new D;
    D obj3 = *br; // 通过多态调用 D::operator D() 
}
```



- **用户定义转换函数不能是类的静态成员函数。**





# 隐式转换序列

## 转换构造函数

上文explicit提到过

## 类型转换函数

就在上面。



**对于需要进行隐式转换的上下文，编译器会生成一个隐式转换序列：**

1. 零个或一个由标准转换规则组成的标准转换序列，叫做初始标准转换序列
2. 零个或一个由用户自定义的转换规则构成的用户定义转换序列
3. 零个或一个由标准转换规则组成的标准转换序列，叫做第二标准转换序列

**对于隐式转换发生在构造函数的参数上时，第二标准转换序列不存在。**

## 初始标准转换序列：

初始标准转换序列很好理解，在**调用用户自定义转换前**先把值的类型处理好，比如加上cv限定符：

```c++
struct A {};
struct B {
    operator A() const;
};
 
const B b;
const A &a = b;
```

初始标准转换序列会把值先转换成适当的形式以供用户转换序列使用，在这里`operator A() const`希望传进来的this是`const B*`(this)类型的，而对b直接取地址只能得到`B*`，正好标准转换规则里有添加底层const的规则，所以适用。

如果值的类型正好，不需要任何预处理，那么初始标准转换序列不会做任何多余的操作。

**如果第一步还不能转换出合适的类型，那么就会进入用户定义转换序列。**

## 用户定义转换序列

- **如果类型是直接初始化（参考杂记1），那么只会调用转换构造函数**
- **如果是复制初始化或者引用绑定，那么转换构造函数和用户定义转换函数会根据重载决议确定使用谁(忽略掉explicit标注的转换函数）。**另外如果转换函数不是`const`限定的，那么在两者都是可行函数时优先选择转换函数，比如`operator A();`这样的，否则会报错有歧义（GCC 10.2上测试显示有歧义的时候会选择转换构造函数，clang++11.0和标准描述一致）。这也是我们复习了几种初始化有什么区别的原因，因为类的构造形式不同结果也可能会不同。

**选择好一个规则后就可以进入下一步了。**

**如果是在构造函数的参数上，那么隐式转换到此就结束了。除此之外我们需要进行第三步。**

## 第二标准转换序列

这是针对用户转换序列处理后的值的类型做一些善后工作。之所以不允许在构造函数的参数上执行这一步是因为防止过度转换后和用户转换规则产生循环。



```c++
struct A
{
    operator int() const;
};
 
A a;
bool b = a;
```

在这里a只能转换成int，而为了偷懒我们直接把a隐式转换成bool，问题来了，初始标准转换序列把`A*`转换成了`const A*`（作为this，类方法的隐式参数），用户转换序列把`const A*`转换为了int，int和bool是完全不同的类型，怎么办呢？

这就用上第二标准转换序列了，这里是数值转换，int转成bool。

不过上面只是个例子，请不要这么写，因为在实际代码中会出现问题：

```c++
template <typename T>
struct SmartPointer {
    //...
    T *ptr = nullptr;
    operator bool() {
        return ptr != nullptr;
    }
 
    T& operator*() {
        return *ptr;
    }
};
 
auto ptr = get_smart_pointer();
if (ptr) {
    // ptr 是int*的包装，现在我们想取得ptr指向的值
    int value = ptr;
    // ...
}
```

上面的代码不会有任何编译错误，然而它将引发严重的运行时错误。

为什么呢？因为如注释所说我们想取得指针指向的值，**然而我们忘记解引用了**！实际上因为要转换成int，隐式转换序列里是这样的：

1. 初始标准转换序列 -----> 当前类型已经满足调用用户转换序列的要求了，什么都不做
2. 用户定义转换序列 -----> 和int最接近的有转换关系的类型只有bool了，调用这个
3. 第二标准转换序列 -----> 得到了bool，目标的int，正好有规则可用，进行转换

因此你的value只会有两种值，0和1。这就是隐式转换带来的第一个大坑，而上面代码反应出的问题叫做“安全bool（safe bool）”问题。

我们可以用`explicit`把它踢出转换序列。

```c++
template <typename T>
struct SmartPointer {
    //...
    T *ptr = nullptr;
    explicit operator bool() {
        return ptr != nullptr;
    }
};
```

https://www.cnblogs.com/apocelipes/p/14415033.html#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2



- **注意引用和隐式类型转换的坑。查看下面的引用和指针的区别。**



# 临时对象：

一般来说临时对象有三种情况产生：

1. 以值的方式给函数传参

2. 隐式类型转换

3. 函数返回一个对象时

# 析构函数和构造函数中的异常

- 构造函数中抛出的异常会导致析构函数无法被调用。因为被视为对象没有成功构造。会存在内存泄漏风险
- 在析构函数中是可以抛出异常的，但是这样做很危险，请尽量不要这要做。原因在《More Effective C++》中提到两个：

（1）如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。

（2）通常异常发生时，c++的异常处理机制在异常的传播过程中会进行栈展开（stack-unwinding），因发生异常而逐步退出复合语句和函数定义的过程，被称为栈展开。在栈展开的过程中就会调用已经在栈构造好的对象的析构函数来释放资源，此时若其他析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃。

# inline与宏区别?

- inline：
  - 编译期进行展开。
  - 是函数
  - 嵌入到目标代码
  - 可以进行安全检查，语句正确等编译功能
- 宏：
  - 预处理期进行替换。
  - 不是函数
  - 只是文本替换
  - 不能进行安全检查等。

# inline函数与普通函数区别？

当普通函数在被调用时，系统首先跳跃到该函数的入口地址，执行函数体，执行完成后，再返回到函数调用的地方，函数始终只有一份。

而内联函数则不需要进行一个寻址的过程，当执行到内联函数时，此函数展开（很类似宏的使用），如果在 N 处调用了此内联函数，则此函数就会有 N 个代码段的拷贝。空间换时间。

# inline 额外的区别

- `inline` 只意味着在程序中函数的定义可以出现很多次。

**直接转载至此处**

作者：吼姆桑
链接：https://www.zhihu.com/question/24185638/answer/2404153835
来源：知乎

### 前言

我曾在很长一段时间对inline关键字的认识都维持在相当朴素的程度：用来建议编译器将函数内联展开至调用处。这种理解在早期的C++标准（C++98之前）里问题不大，但在C++98标准以后就完全不对了。首先，现代的编译器在决定是否将函数调用进行内联展开时，几乎不参考函数声明中inline修饰符；其次，inline关键字不仅能修饰函数，也可修饰变量（C++17以后），甚至能修饰命名空间（C++11以后）；此外，inline更为关键的作用是允许同一个函数或变量的定义出现在多个编译单元之中；最后，修饰命名空间的inline关键字为程序库的版本控制提供了语言层面上的支持，这与最初的函数内联的含义更是相去甚远。

## inline函数

- **我们知道，若一个非static函数在多个编译单元中被重复定义，那么在链接阶段会发生multiple definition的错误，这是因为面对同一符号的多个定义，链接器并不知道使用哪个。但是对于header-only的程序库来说，所有的函数定义都位于头文件，若不加特殊处理被多个源文件包含，则一定会发生multiple definition的错误。解决这个问题的方法是在函数声明处加上inline修饰，这样的话编译器在处理该函数时就会认为它是一个弱符号，链接器在面对多个名字相同的弱符号时只会保留其中一个的定义（具体的保留规则视编译器而定）。**我用一个例子来说明inline函数的编译行为：inline函数`foo`定义在头文件foo.h中，且函数内部定义了[局部静态变量](https://www.zhihu.com/search?q=局部静态变量&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2404153835})`factor`；源文件bar1.cc和bar2.cc分别包含了foo.h，并在`bar1`和`bar2`函数中都调用了`foo`函数；最后，源文件main.cc中的`main`函数调用了`bar1`和`bar2`函数：

```cpp
/* foo.h */
inline int foo(int x) {
    static int factor = 1;
    return x * (factor++);
}

/* bar1.cc */
#include "foo.h"
int bar1() {
    return foo(1);
}

/* bar2.cc */
#include "foo.h"
int bar2() {
    return foo(2);
}

/* main.cc */
int Bar1(), Bar2();
int main() {
    return Bar1() + Bar2();
}
```

用gcc编译这三个源文件并链接生成可执行文件main，链接过程中并不会发生multiple definition的错误，并且[main函数](https://www.zhihu.com/search?q=main函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2404153835})的返回值表明两次调用使用了同一个局部静态变量factor。

```bash
g++ -c main.cc bar1.cc bar2.cc -fno-gnu-unique  # ok
g++ -o main main.o bar1.o bar2.o    # ok
./main; echo $? # 5
readelf -s main
```

最后我们用readelf查看输出的可执行main文件的符号表，可以发现main中确实只有一份符号Foo的定义，同时Foo中的静态变量factor也同样只保留了一份。此时函数Foo和内部定义的局部静态变量factor都是weak符号。

```text
Num:    Value          Size Type    Bind   Vis      Ndx Name
...
49: 0000000000004010     4 OBJECT  WEAK   DEFAULT   23 _ZZ3FooiE6factor
...
53: 000000000000115f    32 FUNC    WEAK   DEFAULT   14 _Z3Fooi
...
```

当然，没有规定强制多个编译单元中的同名inline函数的定义必须一致，链接器并不会对这种定义不一致的行为报错，但你却无法保证生成的可执行文件中调用了哪个版本。

```cpp
/* bar1.cc */
inline int Foo(int x) {
    static int factor = 1;
    return x * (factor++);
}
int Bar1() {
    return Foo(1);
}

/* bar2.cc */
inline int Foo(int x) {
    static int factor = 2;
    return x * (factor++);
}
int Bar2() {
    return Foo(2);
}

/* main.cc */
int Bar1(), Bar2();
int main() {
    return Bar1() + Bar2();
}
```

对于上述例子，9.3.0版本的gcc面对这种情况很可能是根据源文件的编译顺序而决定使用哪个Foo：

```bash
g++ -o main main.cc bar1.cc bar2.cc -fno-gnu-unique # ok
./main; echo $? # 5
g++ -o main main.cc bar2.cc bar1.cc -fno-gnu-unique # ok
./main; echo $? # 8
```

所以面对这种其它编译单元可能定义了同名inline函数的情况，不要轻易定义该名字的inline函数，因为你既无法保证对方的定义与你相同，也无法保证链接器最终选择的定义。如果非要定义，应该将其声明为static或者将其声明定义在另一个不冲突的命名空间中。当然，不使用任何关键字修饰该函数也不行，因为这时你定义的版本对应的符号是全局的强符号，链接器在面对多个弱符号和一个强符号时一定会采用强符号对应的定义，因此你定义的版本会覆盖其它单元所定义的inline版本。除非你知道这样的后果是你所需的（确实我们有时候会这么做，例如覆盖掉程序库提供的默认版本），否则不要这样做。

## inline变量

inline用于修饰变量定义是在C++17之后的事情。当inline用于修饰变量定义时，你很难说它具有[内联展开](https://www.zhihu.com/search?q=内联展开&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2404153835})的作用，因为将变量的定义内联展开到引用处没有意义，它更多地只是允许在多个编译单元对同一个变量进行定义，并且在链接时只保留其中的一份作为该符号的定义。当然，同时在多个源文件中定义同一个inline变量必须保证它们的定义都相同，否则和inline函数一样，你没办法保证链接器最终采用的是哪个定义。inline变量除了允许我们在头文件中定义全局变量，也允许我们在类定义中直接初始化静态数据成员：

```cpp
/* foo.h */
struct Foo {
    inline static int foo = 1;
};
/* bar1.cc */
#include "foo.h"
int Bar1() { return Foo::foo + 1; }
/* bar2.cc */
#include "foo.h"
int Bar2() { return Foo::foo + 2; }
/* main.cc */
int Bar1(), Bar2();
int main() {
    return Bar1() + Bar2();
}
```

我们用gcc编译上述文件

```bash
g++ -std=c++17 -c main.cc bar1.cc bar2.cc # ok
g++ -std=c++17 -o main main.o bar1.o bar2.o # ok
```

并用readelf分别查看各个目标文件，我们会发现这个内联的静态数据成员在bar1.o和bar2.o中都以[弱符号](https://www.zhihu.com/search?q=弱符号&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2404153835})的形式单独存在于一个段中，在链接后main只会包含一个foo符号，并且该符号对应的数据被合并到了.data段：

```text
# 以下为 readelf -sS bar1.o | grep foo 和readelf -sS bar2.o的内容 
Section Headers:
[Nr] Name               Type             Address           Offset
...
[ 6] .data._ZN3Foo3fooE PROGBITS         0000000000000000  0000005c
...
Symbol table '.symtab' contains 13 entries:
Num:    Value          Size Type    Bind   Vis      Ndx Name
...
11: 0000000000000000     4 OBJECT  WEAK   DEFAULT    6 _ZN3Foo3fooE
# 以下为readelf -s main | grep foo
Num:    Value          Size Type    Bind   Vis      Ndx Name
...
0000000000004010     4 OBJECT  WEAK   DEFAULT   23 _ZN3Foo3fooE
```

可以看见在bar1.o和bar2.o中内联的静态数据成员被单独放到了名为.data._ZN3Foo3fooE的段中，这种将内联变量单独放置一个段的原因主要是为了在链接时消除重复代码，在链接合并段的时候面这些特殊的同名段会选择性地保留其中一个。

## inline命名空间

inline命名空间是C++11标准中引入的关键词，对于一个用inline修饰的内嵌命名空间而言，它所包含的成员在可见性上如同声明在外围[命名空间](https://www.zhihu.com/search?q=命名空间&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2404153835})中一样，所以inline之于命名空间更具有字面上的含义：将内嵌命名空间在外围命名空间中“展开”。inline命名空间最主要的用途是为**程序库的版本控制提供语言上的支持**，有点类似于共享库中的[符号版本控制](https://zhuanlan.zhihu.com/[SymbolVersioning - GCC Wiki (gnu.org)](https://gcc.gnu.org/wiki/SymbolVersioning))（将程序使用的接口版本信息记录到可执行文件，[动态链接](https://www.zhihu.com/search?q=动态链接&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2404153835})时再根据这些版本信息从[共享库](https://www.zhihu.com/search?q=共享库&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2404153835})调用正确版本的接口），一般来说库的作者会为不同的版本放置到专属的命名空间，再用一个与版本无关的外围命名空间将它们包含，并通过[预编译指令](https://www.zhihu.com/search?q=预编译指令&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2404153835})选择性地将开发环境支持的库版本对应的命名空间暴露给用户。例如下面的例子中库`libfoo`根据宏`some_predefined_macro`的值将不同版本的接口暴露给用户程序：

```cpp
#define some_predefined_macro   2022L

namespace libfoo {
#if some_predefined_macro >= 2022L
    inline
#endif
    namespace libfoo_2022 {
        int foo(int);       // better foo
        float foo(float);   // new foo
    }
#if some_predefined_macro >= 2019L && some_predefined_macro < 2022L
    inline
#endif
    namespace libfoo_2019 {
        int foo(int);   // old foo
    }
// other versions ...
}

using namespace libfoo;
int main() {
    printf("foo(5) = %d\n", foo(5));    // refer to int libfoo::libfoo_2022::foo(int);
    // ...
}
```

当然，这种选择性地暴露内嵌命名空间成员乍一看也可以通过using namespace来完成，在C++11之前库的版本控制就是通过它来实现的。但用这种方式实现库的版本控制是有两个明显的缺陷：（1）在内嵌命名空间声明的模板无法在外围命名空间中进行特化，（2）不支持[ADL](https://zhuanlan.zhihu.com/[Argument-dependent lookup - cppreference.com](https://en.cppreference.com/w/cpp/language/adl))。一般来说库作者都不希望将版本相关的命名空间暴露给用户，而缺陷（1）又要求用户必须在模板所在的命名空间中对其进行特化，例如说下面这段代码就不行：

```cpp
namespace libfoo {
    namespace libfoo_2022 {
        template <typename T>
        T &foo(T &);
    }
    using namespace libfoo_2022;
}

namespace libfoo {
    template <>
    float &foo<float>(float &); 
}
```

ADL的意思是在函数名字查找时自动将调用参数所属的命名空间包含进来，这样在函数调用时便无需显示指定作用域。那缺陷（2）意思是用内嵌命名空间的类型变量作为参数调用外围命名空间的函数，或者用外围命名空间的类型变量作为参数调用内嵌命名空间的函数是行不通的，例如下面这段代码也不行：

```cpp
namespace libfoo {
    class Bar1 {};
    namespace libfoo_2022 {
        void foo1(Bar1);
        class Bar2 {};
    }
    using namespace libfoo_2022;
    void foo2(Bar2);
}

int main()
{
    libfoo::Bar1 bar1;
    libfoo::Bar2 bar2;
    (void)foo1(bar1);    // compile error
    (void)foo2(bar2);    // compile error
    ...
}
```

inline命名空间可以解决using namespace在实现库版本控制时的缺陷，inline与using的区别在于用inline修饰的内嵌命名空间的成员表现得更像声明在外围命名空间：你不仅可以在外围命名空间中对inline的内嵌命名空间的模板进行特化，而且ADL也会将参数类型所在命名空间所包含的inline命名空间，以及自身作为inline命名空间所在的外围命名空间一并考虑进来：

```cpp
namespace libfoo {
    class Bar1 {};
    inline namespace libfoo_2022 {
        void foo1(Bar1);
        class Bar2 {};
        template <typename T>
        T &foo(T &);
    }
    void foo2(Bar2);
}

namespace libfoo {
    template <>
    float &foo<float>(float &);
}

int main() {
    libfoo::foo(3.2);       // call specialized libfoo::libfoo_2022::foo
    libfoo::Bar1 bar;
    libfoo::Bar2 bar2;
    foo1(bar1);             // call lib::libfoo_2022::foo1
    foo2(bar2);             // call lib::foo2
    ...
}
```

inline在修饰命名空间时还有一些别的特点，比如若inline命名空间与外围命名空间包含了名字重复的符号时，使用外围命名空间作为作用域对该符号进行引用将会导致编译错误，因为编译器无法确定你究竟引用了哪个命名空间的符号。但如果使用using namespace的话上述情况则总是指向外围命名空间中的符号。此外inline命名空间还具有传递性，这些具体的特性详见[cppreference](https://zhuanlan.zhihu.com/[Namespaces - cppreference.com](https://en.cppreference.com/w/cpp/language/namespace#Inline_namespaces))，但我认为inline修饰符引入到命名空间最主要的作用是在库版本控制时解决ADL和命名空间外模板特化的问题。

# typedef和define（宏）有什么区别

- 用法不同：typedef用来定义一种数据类型的别名，增强程序的可读性。define主要用来定义常量，以及书写复杂使用频繁的宏。
- 执行时间不同：**typedef是编译期处理**，有类型检查的功能。define是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。
- 作用域不同：typedef有作用域限定。define不受作用域约束，只要是在define声明后的引用都是正确的。
- 对指针的操作不同：typedef和define定义的指针时有很大的区别。

注意：typedef定义是语句，因为句尾要加上分号。而define不是语句，千万不能在句尾加分号。

# 如何加深理解移动构造和拷贝构造

```c++
class myobj{
    public:
        myobj(int x):val(new int(x)){}
        int& getval(){
            return *val;
        }
        myobj(const myobj& obj){						//拷贝构造
            val = new int(*obj.val);					
        }
        myobj& operator=(const myobj & rhs){			//拷贝赋值
            if(this == &rhs){
                return *this;
            }
            delete this->val;
            val = new int(*rhs.val);
            return *this;
        }
        myobj(myobj&& obj){								//移动构造
            cout <<"mv" << endl;
            val = obj.val;
            obj.val = nullptr;
        }
        myobj& operator=(myobj&& rhs){					//移动赋值
            cout <<"mv=" << endl;
            if(this == &rhs){
                return *this;
            }
            if(this->val != nullptr){
                delete val;
            }
            val = rhs.val;
            rhs.val = nullptr;
            return *this;

        }
        ~myobj(){
            delete val;
            val = nullptr;
        }


        int* val;
        
};

int main(){
    myobj a(5);
    myobj b(10);
    cout << a.getval() << endl;					
    myobj c(a);							//拷贝构造
    cout << c.getval() << endl;
    myobj d = c;						//拷贝构造。因为d对象之前不存在。
    cout << d.getval() << endl;
    d = b;								//拷贝赋值
    cout << d.getval() << endl;
    myobj e = move(a);					//移动构造。因为e对象之前不存在。在这之后不可访问a，因为a所有权已被转移
    cout << e.getval() << endl;
    d = move(b);						//移动赋值。在这之后不可访问b,因为b所有权已被转移
    cout << d.getval() << endl;
    return 0;
}
```

首先我们要强化记忆，什么叫构造函数。构造函数就是创建对象的时候调用的。我们这里有一个类，里面有一根指针。首先，我们既然是构造，那么拷贝构造和默认构造都要对变量（指针）初始化（分配内存）。所以这里拷贝构造和默认构造都是`new`的。因为我们都是**无中生有**

那么移动构造和拷贝构造的区别在哪呢？

什么时候我们想要移动？假如我们要**转移所有权**，我们这时候会调用移动构造。也是无中生有。但是由于转移所有权，所以我们**不需要new**。我们只需要把原来指针指向的地址赋值给我们新变量的对应变量上即可。**移动之后，因为我们的目的是转移所有权，所以应当对原对象的对应指针变量置空。**



拷贝赋值和移动赋值。

- 拷贝赋值我们首先要检测自我赋值。通过地址来判断。如果是一个地址互相赋值，那么什么都不做。然后我们首先把自己的东西清理掉，也就是自己指针指向的资源释放掉。然后，由于我们是拷贝，不是移动。所以我们依旧要**开辟新空间，把原来对象的指针指向的值复制过来。**

- 移动赋值，我们首先也要检测自我赋值。然后也要先把自己的东西清理掉，也就是自己指针指向的资源释放掉。然后，由于我们是**移动**，所以我们直接复制指针而不是指针指向的值。然后把**源对象的指针置空，因为我们是转移所有权。**

- 返回值：

  - **构造函数，无论是默认构造，拷贝构造还是移动构造，函数都无返回值。**

  - 赋值操作符，无论是拷贝赋值还是移动赋值，**我们为了链式调用，也避免不必要的拷贝**，都应该返回对象的引用。

- 形参：

  - 拷贝构造和拷贝赋值，应该接受对象的常引用。

  - 移动构造和移动赋值因为涉及到对源对象的修改，即 对源成员变量（指针）置空，所以不能是常量。而且要接收右值。因为是移动。

- 什么时候该触发移动构造呢？

  - 如果临时对象即将消亡，并且它里面的资源是需要被再利用的，这个时候我们就可以触发移动构造。
    - 比如`vector.push_back(obj(8));`这就是往容器添加一个临时对象。这时候如果此临时对象有移动构造，则调用完默认构造后，直接触发移动构造进行搬移省去一次内存分配。否则需要调用拷贝构造。
  
  - 移动构造在使用vector的情况下，一般是vector扩容的时候重新分配内存的时候使用，如果元素的自定义类型有移动构造就会用移动构造。没有就是拷贝构造。**这里的移动构造必须是`noexcept`**



## 针对自定义类强制生成移动构造

针对自定义类强制生成移动构造会满足member-wise move。也就是移动。它会帮我们调用每一个成员的移动构造。

```c++
class myobj{
    public:
        int val; //基本数据类型
        string str; //自定义类型可移动
        unique_ptr<int>u_ptr = nullptr; //智能指针，也算自定义类型可移动

        myobj(int x, const string& rhsstr, int num): val(x), str(rhsstr), u_ptr(make_unique<int>(num)){
            cout << "const" << endl;
        }
        myobj(myobj&& rhs) = default; //强制生成移动构造。
};
int main(){
    myobj obj(4, "abc", 22);
    cout << *obj.u_ptr << endl;
    cout << obj.str << endl;
    return 0;
}
/*
输出
const
22
abc
*/
```

如果决定移动它：

```c++
int main(){
    myobj obj(4, "abc", 22);
    cout << *obj.u_ptr << endl;
    myobj obj1(move(obj)); //移动后
    if(obj.u_ptr != nullptr){
        cout <<"not null" << endl;
    }
    else{
        cout <<"null" << endl;
    }
    cout << obj.str << endl;
    return 0;
}
/*
输出
const
22
null
(这行是空字符串)

*/
```

- 我们看到，`unique_ptr`和`string`都被正确移动了。原对象的智能指针为空，字符串也为空。



#### **但是，裸指针（指针类型）并没有移动构造，所以必须写出我们自己的移动构造。包括两个部分，一个部分是设置为`default`强制生成构造函数可以帮我们完成的member wise move。另一个部分是给原始指针进行置空**

```c++
class myobj{
    public:
        int val; //基本数据类型
        string str; //自定义类型可移动
        int* ptr = nullptr; //注意此处替换为原始指针

        myobj(int x, const string& rhsstr, int* num): val(x), str(rhsstr), ptr(num){
            cout << "const" << endl;
        }
        myobj(myobj&& rhs) = default;
        ~myobj(){
            delete ptr;
            ptr = nullptr;
        }
};
int main(){
    myobj obj(4, "abc", new int(22));
    cout << *obj.ptr << endl;
    if(obj.ptr != nullptr){
        cout <<"not null" << endl;
    }
    else{
        cout <<"null" << endl;
    }
    cout << obj.str << endl;
    return 0;
}
/*
输出
const
22
notnull
abc
*/
```

如果我们决定移动它：

```c++
int main(){
    myobj obj(4, "abc", new int(22));
    cout << *obj.ptr << endl;
    myobj obj1(move(obj));
    cout << *obj1.ptr << endl;
    if(obj.ptr != nullptr){
        cout <<"not null" << endl;
    }
    else{
        cout <<"null" << endl;
    }
    cout << obj.str << endl;
    return 0;
}
/*
输出
const
22
22 //此行为obj1的输出。也是22
notnull
(这行是空字符串)
*/
```

- **我们看到，`string`被正确移动了。原对象的字符串为空。但是由于原始指针没有自己的移动构造，所以编译器只能帮助我们进行member wise move，无法帮助我们给原始指针进行置空。**

所以我们要这么写：

```c++
myobj(myobj&& rhs): 
    val(move(rhs.val)), //基本数据类型，这么写永远不会错。虽然没什么用。
    str(move(rhs.str)),
    ptr(move(rhs.ptr)){ //原始指针类型，这么写永远不会错。虽然没什么用。
        rhs.ptr = nullptr;
}
```

于是就会有正确结果：

```c++
int main(){
    myobj obj(4, "abc", new int(22));
    myobj obj1(move(obj));
    cout << *obj1.ptr << endl;
    if(obj.ptr != nullptr){
        cout <<"not null" << endl;
    }
    else{
        cout <<"null" << endl;
    }
    cout << obj1.str << endl;
    return 0;
}
/*
输出
const
22 //此行为obj1的输出。也是22
null //obj的指针已经空了。
abc //此行为obj1的字符串。正确移动了。
*/
```



https://youtu.be/St0MNEU5b0o





# for循环

```
for ( init; condition; increment )
{
   statement(s);
}
```

for循环的更新条件（第三个条件）是迭代之后执行的，也就是最后执行的。 

## 重要优化 for循环的判断表达式（第二个条件）是每一次循环都会执行。如果判断表达式中有函数调用则每次都会调用

如下面代码，for循环调用了五次，则`func`函数也会被调用5次。

```c++
int func(int x) {
    cout <<"call" << endl;
    return 5;
}
int main() {

    for (int i = 0; i < func(i); i++) {
        cout << "for" << endl;
    }
    return 0;
}
```



# i++和++i

- ++i 
 ++i 先自加，再赋值。

```c++
#include<stdio.h>
int main()
{
    int i = 0;
    int j = ++i;    
    cout << i << j <<endl;
    return 0;
}
```

此时输出 i=1 j=1 

- i++ 

​		i++ 先赋值，再自加。

```c++
#include<stdio.h>
int main()
{
    int i = 0;
    int j = i++;
    cout << i << j <<endl;
    return 0;
}
```

此时输出 i=1 j=0 

**i++是右值，++i是左值**

在内置类型的情况下

```c++
int a = i++;
```

这句话在编译器眼里是下面这样的两句话：

```c++
int a = i;
i++;
```

而

```c++
int a = ++i;
```

在编译器眼里则是这样：

```c++
i++;
int a = i;
```







**i++和++i在非自定义类型的情况下，只要不发生赋值，则原理没有差别。但是性能有差别。**





我们深入看一下**自定义类型的情况**

```c++
struct mybase
{
    // 前置++
    mybase& operator++()
    {
        data++;
        return *this;
    }

    // 后置++
    mybase operator++(int)
    {
        auto tmp = *this;
        // 执行++有两种选择, data++或者调用上面的前置++
        data++;

        return tmp; //注意这里返回的是局部变量！！
    }

    int data = 0;
};
```

注意这里后置的++我们有一个非常奇怪的写法。我们用一个临时变量保存了自己，然后再把自己的值+1，然后返回一个自己的拷贝。**不能返回引用！因为这里的temp是临时变量，返回引用就炸了**

这也就是为什么i++先赋值再自增了。因为我们赋值过去的是一个没有自增的自己。

这也是为什么i++是一个右值。因为他符合了右值的定义之一：返回了一个非引用类型的 函数调用。因为++本身也可以重载，也是函数调用。他返回了一个临时对象的自己。



所以++i反而看起来非常简单。我们先给自己+1然后返回自己的引用。这也是为什么++i是先自增再赋值，也是为何++i是左值。



## 性能区别

- 内置类型（比如`int`)：

  - 编译器会优化，所以前置++和后置++性能无差别。

- 自定义类型（STL迭代器）：

  - 前置++操作的性能优于后置++

  ```c++
  __normal_iterator& operator++(){  // 前置操作
      ++_M_current;
      return *this;
  }
  
   __normal_iterator operator++(int){ // 后置操作
       return __normal_iterator(_M_current++); 
   }
  ```

  - 上面是STL中iterator的源码。从上面代码可以看出，迭代器的前置和后置操作主要有以下两个区别：
    - 返回值：前置操作返回对象的引用，后置操作返回类型为对象，
    - 拷贝：前置操作无拷贝操作，后置操作存在一次对象拷贝
  - 正因为这两个原因，前置操作符就地修改对象，而后置操作符将导致创建临时对象，调用构造函数和析构函数（某些情况下编译器会做优化，此处不做讨论），导致了前置操作和后置操作的性能差异。

- 其他自定义类型：

  - 前置++操作的性能优于后置++。

# 编译过程

记住ISO即可

.h/c/cpp通过 预处理器处理为.i的预处理代码

.i的预处理代码通过编译器处理为.s的汇编代码

.s的汇编代码通过汇编器处理为.o的目标代码（可重定位二进制）

.o的目标代码通过链接器生成可执行文件.exe/.out （如果没有外部代码或者dll/lib库文件就直接生成可执行文件）

# 从cpp源代码到可执行程序经过了哪些过程?

A: 在Linux系统下从.cpp开始, 经过

1.预处理阶段, 在这部分主要处理include的文件包含关系, 还有宏的替换, 做完.cpp变为.i
2.编译阶段会做语法分析还有优化之类的, 将代码转换为汇编, 做完.i变.s
3.汇编阶段会把前面得到的汇编代码转换为二进制的机器代码, 做完.s变.o
4.最后运行链接器将所有可重定位文件合并为一个可执行文件, 做完.o变prog. 对于可执行文件可以调用系统中被称为加载器的函数来将文件复制到内存并开始执行.

其中自己了解较多的是最后的链接阶段. 链接器为了将输入的多个可重定位文件组合为一个可执行文件, 要做的事主要有两个, 一是符号解析, 二是重定位. 其中符号解析意思是说一个文件里会有很多对符号的定义和引用, 所谓符号就是全局变量,函数和静态变量这些. 然后符号解析就是将每个符号引用与一个符号定义关联起来. 而重定位做的事是把每个符号定义与一个内存地址关联起来, 然后将所有对这个符号的引用都指向这个地址.

详细说符号解析的话需要先说链接器的输入, 也就是可重定位文件的文件格式. 虽然它是二进制文件, 但实际上是有各种分段的, 比如有个固定的头部, 描述了文件类型, 机器类型等等一些主要信息. 还有放机器代码的段, 再往下还有放全局变量的段等等. 而文件中会有一个放符号表的段, 其中存放了这个文件定义和引用的全局变量以及函数这些信息. 

符号表中有三类不同的符号主.分别是1.由当前文件定义的全局符号(定义的全局变量,函数等) 2.引用的其他文件定义的全局符号, 3.只被当前文件定义和引用的符号(static全局变量和函数). 每个符号条目并不是只有一个名字, 而是有一个固定的格式结构. 这个结构会标明符号名字, 大小, 类型(变量还是函数), 链接性(全局变量是GLOBAL, static全局变量大概会是LOCAL)等等.(之前看到过一个问题是说为什么static全局变量可以把作用域限制在本文件, 讲到这里就可以回答这个问题了. 因为static符号被单独分了一类, 链接器不会拿static符号去跟别的文件做解析.)

符号解析就是利用这些符号表信息去做解析的. 对于那些定义和引用都在同一文件的符号解析很简单. 但是本文件引用了其他文件定义的符号就会复杂一些. 编译器会把这样的只有引用的符号交给链接器, 由链接器去其他文件找这个符号的定义, 如果找不到就会报错. 符号解析还有一个问题是重名问题, 编译器在编码符号的时候会给他一个强弱属性, 已初始化的全局变量就是强, 未初始化的就是弱. 然后如果重名, 链接器去选择的时候会优先选择强符号, 如果都是弱符号, 那就随便选一个. 但如果两个重名符号都是强那会直接报错.

符号链接还可以跟静态库链接(静态库就是提前写好的一些函数文件打包为一个单独文件, 可以用它来当作链接器输入). 在链接静态库的时候, 链接器会维护三个列表: 1.可重定位文件的列表, 2.未解析的符号(有引用但还没定义的符号) 3.已定义的符号. 链接器会从左向右扫描文件然后用这三个表来做符号解析. 这其中要注意的问题是文件的顺序很重要, 顺序不对了解析会失败.

上面就是符号解析的说明了, 接下来是重定位部分. 重定位要做的就是把文件合并一下,然后给每个指令和符号分配内存地址. 再然后就是把对符号的引用指向刚才分配好的地址.

重定位做完就可以得到一个可执行的目标文件.文件由三个大部分组成: 1.只读代码段, 2.读写数据段, 3.不加载进内存的符号表和调试信息这些. 而将一个可执行文件加载到内存后所呈现的布局主要有四个大的部分. 从下到上分别是:1.只读代码段, 2.读写数据段(用来放全局变量, 细分为已初始化和未初始化的两部分), 3.堆, 4.栈. 然后在堆栈之间还有预留给动态库的内存映射区域. 最后在栈的上面还有用户不可见的内核内存.

# 整数相除

两个整数相除，无论用什么接都是整数。因为会自动窄化。所以想要让两个整数相除保留小数点，则必须转换成double或float再进行除法操作

```c++
int a = 3;
int b = 6;
double c = a/b;
// C = 0;
double a = 3;
double b = 6;
double c = a/b;
// C = 0.5
```

# 函数默认参数的继承

- c++的函数的默认参数是不可以被继承的。因为是静态绑定。这里的不可以被继承不是编译不通过。而是会有奇怪调用。 我们看下面的例子

   ```c++
   class IServer
   {
       public:
           virtual ~IServer(){};
           virtual int listen(int backlog = 1) = 0;
   };
   class CRPCServer: public IServer
   {
       public:
           ~CRPCServer(){};
           int listen(int backlog = 2)
           {
               printf("IRPCServer listen backlog: %d\n", backlog);
               return 0;
           }
   };
   class CHTTPServer: public IServer
   {
       public:
           ~CHTTPServer(){};
           int listen(int backlog = 3)
           {
               printf("CHTTPServer listen backlog: %d\n", backlog);
               return 0;
           }
   };
   
   int main(int argc, char *argv[])
   {
       IServer *irpcserver = new CRPCServer;
       IServer *ihttpserver = new CHTTPServer;
   
       irpcserver->listen(); //输出IRPCServer listen backlog: 1
   
       ihttpserver->listen(); //输出CHTTPServer listen backlog: 1
       
       delete irpcserver; irpcserver = NULL;
       delete ihttpserver; ihttpserver = NULL;
       
       return 0;
   }
   ```

   我们采用了多态调用，即父类指针指向子类对象（IServer指针指向CRPCserver和CHTTPServer） 但是我们这两个调用的输出很奇怪：参数是父类函数的默认参数，但是多态调用却调用了子类函数。 所以

   1. **当父类虚函数参数没有默认值，子类有的时候，编译报错** 
   2. **当父类虚函数和子类虚函数参数都有默认值，但是值不同的时候，会忽略子类默认值，使用父类默认值，但是实际调用的是子类函数。**也就是在使用父类指针指向的对象调用虚函数时，函数会按实际指向的对象调用对应的成员函数（动态绑定的结果），而函数的默认参数依旧为父类对象中的默认参数（静态绑定的结果） 所以永远不要重新定义一个继承而来的默认参数值，因为默认参数值是静态绑定的，而虚函数——你应该重新定义的唯一的函数——是动态绑定的。effective C++ 37条 (已编辑)

   

# 类(对象）内存模型：

## 大小

- 类内存大小有关的：

  - 非静态数据成员（包括常量）。也就是常量会对类大小有影响。

  - 虚函数表指针（虚函数产生）

  - 虚基表指针（虚继承产生）

- 类内存大小无关的：

  - 成员函数
  - 静态成员函数
  - 静态数据成员
  - 静态常量数据成员

- 空类大小为1，为了分配一个内存起始地址

  - 空类被继承后，会有空基类优化，所以空基类的占用大小会变成0。前提是当前继承空基类的类不是空类。
  
  ```c++
  class x {};
  class y:public x{
      int a;
  };
  //sizeof(x) = 1
  //sizeof(y) = 4
  ```
  
  - 类内如果含有空类的对象，则空类对象大小依旧会被算为1。
  
  ```c++
  class x {};
  class y:public x{
      x obj
      int a;
  };
  //sizeof(x) = 1
  //sizeof(y) = 8
  //基类对象 1 + int 4 + 补齐 = 8
  ```
  
  - 如果是链式空基类继承，则所有的空类大小都为1。
  
  ```c++
  class x {};
  class y:public x{};
  class z:public y{};
  //sizeof(x) = 1
  //sizeof(y) = 1
  //sizeof(z) = 1
  ```
  
  

## 内存对齐

C++类成员变量的内存分布是：按照声明顺序，**从上到下**，按照**内存对齐**的原则进行分布的。

1. 内存分配的顺序是按照声明的顺序。
2. 每个变量相对于起始位置的偏移量（offset）必须是该变量类型大小的整数倍，不是整数倍则空出内存（padding），直到偏移量为整数倍为止。
3. 最后整个类的大小必须是里面变量类型大小最大值的整数倍。

举例：

```c++
class A {
  char a;
  int b;
  double c;
};

class B {
  char a;
  double b;
  int c;
};

int main() {
  cout << sizeof(A) << endl; //16
  cout << sizeof(B) << endl; //24
}
```

A类的大小：

1. `char a`占1个字节，偏移值为0，目前A类占1字节。
2. `int b`占4个字节，根据内存对齐原则的第二条，b起始位置的偏移量应该4的整数倍，所以b要在a后面空3个字节，然后放入，因此偏移值为4，目前为止A类占用8个字节（3个padding）。
3. `double c`占8个字节，可以直接从b后的第一个字节开始放入，偏移值为8。此时A类占用16字节，符合内存对齐的第三条原则，整个类的大小（16）是成员变量类型大小最大值（8）的整数倍，因此不需要补齐。所以A类总共占用16字节。

同理，B类的大小：

1. `char a`占1个字节，偏移值为0，目前B类占1字节。
2. `double b`占8个字节，根据第二条规则，b要在a后面空7个字节，然后开始放入，因此偏移值为8，目前为止B类占用16个字节（7个padding）。
3. `int c`占4个字节，可以直接从b后的第一个字节开始放入，偏移值为16，此时B类占用20个字节。根据内存对齐的第三条原则，整个类的大小应该是成员变量类型大小最大值（8）的整数倍，因此需要补齐3个字节到24字节。所以B类总共占用24字节。

**带有虚函数的情况：**

```c++
class D {
public:
  virtual void funA();

private:
  char a;
  int b;
  double c;
};

int main() {
    cout << sizeof(D) << endl; //24
}
```

1. `vptr`占8个字节，偏移值为0，目前D类占8字节
2. `char a`占1个字节，偏移值为8，目前D类占9字节
3. `int b`占4个字节，根据内存对齐原则的第二条，b起始位置的偏移量应该4的整数倍，所以b要在a后面空3个字节，然后放入，因此偏移值为12，目前为止D类占用16个字节（3个padding）。
4. `double c`占8个字节，可以直接从b后的第一个字节开始放入，偏移值为16。此时D类占用24字节，符合内存对齐的第三条原则，整个类的大小（24）是成员变量类型大小最大值（8）的整数倍，因此不需要补齐。所以D类总共占用16字节。

**所以在某种极端情况，如这样**

```c++
class a{
    char a;
    int b;
    char c;
    int d;
    char e;
    int f;
    char g;
    int h;
};

class b{
    char a,b,c,d;
    int e,f,g,h;
};


int main() {
    cout << sizeof(a) << endl; 	//32
    cout << sizeof(b) << endl;	//20
    return 0;

}
```

因为根据规则，a的每一个char后都需要补3位为了满足每一个变量的起始偏移地址必须为该变量大小的整数倍。这里int是4，所以必须要补到4这样是1倍。所以每一个char都占据了一个int空间。所以整个class相当于是4*8 = 32。

然而b的四个char连续防治。1是1的整数倍所以不需要补齐操作。所以只有4+4*4 = 20。

由此可见，变量的声明顺序会极大地影响类的内存布局和类对象的大小。

### 出现在派生类中的 base class subobject 有其完整原样性

无论是否是多继承下，每一个继承的类，会先进行对齐，然后再进行下一个继承。

假设类A是（8+1）9 + 补齐 = 16，类B也是9 + 补齐 = 16， 类C继承了类A和类B，所以类C是32  （多继承）

假设类A是（4+1）5 +补齐 = 8，类B继承了类A但是类B自己也是5，则会变成类A的8 + （4+1）+ 补齐的3 = 16， 类C继承了类B然后自己是4，就是 16 + 4 = 20。

**因为C++ Standard 保证：“出现在派生类中的 base class subobject 有其完整原样性！” 子类会被放在父类的对齐空白字节之后，因为父类的完整性必须得以保证，父类的对齐空白字节也是父类的一部分，也是不可分割的。所以会保持继承->对齐->继承第二个->对齐....** 深入探索C++对象模型 

### 类内函数内声明的变量（局部变量）作用域是函数而不是类

**所以类的函数内的变量不会算作类的大小。**

```c++
class test{
    public:
    void funcs(){
        int val;
    }
};
```

大小一定是1。

# NRV优化

NRV优化一句话就是，在函数返回值是值传递的时候，按理来说需要有临时变量调用拷贝构造。编译器对这些事情有优化。

## 内置类型：

如`int` `double` ,指针等内置类型，使用eax寄存器直接储存，然后访问

## 自定义类型：

一句话：编译器会把函数返回值当成形参，然后直接写回。

举例：

```c++
void myfunc(solution& ret, solution& a, solution& b);

solution myfunc1(solution&a, solution& b);
```

我们的`myfunc`和`myfunc1`起到了同样作用，只不过我们人为写成两种形式，一种是返回值，一种是写回。编译器也是优化成了这样，把我们外部接着返回值的变量以**引用（这样才能写回）**方式当做函数形参，然后函数仅需写回即可。

举例：

原函数和调用代码

```c++
Vector add(Vector& a, Vector & b)
{
    Vector v;
    v.x = a.x + b.x;
    v.y = a.y + b.y;
    return v;
}
int main(){
    Vector a, b;
	Vector c = add(a, b);
    return 0;
}
```

编译器优化过的函数和调用代码：

```c++
void add(Vector& __result, Vector& a, Vector & b)
{
    __result.x = a.x + b.x;
    __result.y = a.y + b.y;
    return;
}
int main(){
    Vector a, b;
    Vector c;
    add(c, a, b);
    return 0;
}
```



https://www.cnblogs.com/autosar/archive/2011/10/09/2204181.html

# 类的私有静态变量可以通过作用域访问运算符直接访问

# main函数结束也会为栈对象调用析构，但是不会为堆对象调用。

# 类内函数内声明的变量（局部变量）作用域是函数而不是类

所以类的函数内的变量不会算作类的大小。



# 指针和引用的区别：

- 可以把引用看成一个const指针。因为是const指针所以必须定义时初始化，也不能更改指向。**但是这个并不全对。比如**

  - ```c++
    double p = 3.33;
    int& ref = p; //错误
    int&& ref = p;//可以。
    ```
    
  - 我们上面提到了。隐式类型转换会创建临时对象。这里就是调用了`int`的形参为`double`的构造函数创建了一个临时对象。临时对象是右值。右值没有地址。我们这里用的又是左值引用，自然会产生错误。

  - 所以我们注意到了，隐式转换的临时变量是右值。所以可以用右值引用去接。**但是！！这时候这个ref并不是p的引用，而是一个临时变量的引用。ref此时代表的并不是p而是一个临时对象！**

- 指针是一个单独的实体，引用则是别名

  - 所以指针有地址
  - 引用虽然（可能）也有地址（也分配内存），但是引用和引用所引用的变量共用一块内存空间。当然了，引用本身确实有自己的内存空间，和指针一样。但是经过编译器处理后，访问这块内存时将直接转而访问其指向的内存。因此在程序中无法读取到这块内存本身。（依靠实现）

- 引用不可以赋值，所以引用只能在定义时初始化一次，之后不可更改。指针可以更改该并且可以把定义和初始化分开。

- 引用不能为空，指针可以为空。

- `sizeof`指针的大小是指针自己的大小。`sizeof`引用是对象的大小。

- 没有引用的引用，没有引用数组，也没有指向引用的指针。

- 指针有自增操作。

- **引用不可以重新赋值（不能更改指向）**

```c++
int main(){
    int a = 10;
    int b = 20;
    int c = 30;
    int& aref = a;
    cout << aref << endl; //10
    aref = c; //注意这里！
    cout << aref << endl; //30
    cout << a << endl; //30
    return 0;
}
```

**我们看到`aref`是`a`的引用，也就是它俩是一个东西。执行`aref = c`的时候，并不是把`aref`变成`c`的引用，而是把`c`的值赋给`aref`也就是赋给`a`的引用。所以最后`a`和`aref`都会变成30。**

## 引用的可能实现

C++ 标准只说明它应该如何表现，而不是它应该如何实现。

一般来说编译器会把引用实现为指针。并采用特殊优化。比如`int& i = j`。编译器在编译的时候会把所有遇到`i`的地方替换为`j`的内存地址。也就是在符号表内添加类似注释的东西通知`i`是`j`的别名。所以在底层，引用确实可能会被分配内存，也可能不分配。









# 继承权限和访问权限

![QQ截图20220828052432](/assets/blog_res/2022-07-24-%E6%9D%82%E8%AE%B02.assets/QQ%E6%88%AA%E5%9B%BE20220828052432.png)

# 函数指针和成员函数指针

```c++
//静态的成员函数指针语法:
void (*ptrStaticFun)() = &ClassName::staticFun;
//成员函数指针语法:
void (ClassName::*ptrNonStaticFun)() = &ClassName::nonStaticFun; //必须加作用域
```

我们来通过具体例子来说明其中的坑。


```c++


void normal_func(){
    cout << "func" <<endl;
}

void call_back_test(int& a, int& b){
    cout << a + b << endl;
}


class test{
    public:
        int val = 5;
        void class_nonstatic_func(){
            cout << "class_nonstatic_func" <<endl;
        }
        static void class_static_func(){
            cout << "class_static_func" <<endl;
        }
        void callback(void(*ptr)(int&, int&), int& a, int& b){
            ptr(a, b); //普通函数调用
            void(*normal_funcptr)() = &normal_func; //类内获取全局函数指针。注意全局函数必须写在这一行的前面。
            normal_funcptr(); //调用 语法糖
            (*normal_funcptr)(); //调用


            void(test::*class_nonstatic_func_ptr)() = &test::class_nonstatic_func; //类内获取类非静态成员函数指针
            (this->*class_nonstatic_func_ptr)(); //调用。调用类成员函数指针必须加*解引用。而且需要绑定对象。类内就是用this。

            void(*class_static_func_ptr)() = &test::class_static_func; //类内获取类非静态成员函数指针
            class_static_func_ptr();    //调用 语法糖
            (*class_static_func_ptr)(); //调用


        }
};


int main(){
    void (*normal_funcptr)() = &normal_func;          //普通函数指针
    void (*normal_funcptr1)() = normal_func;          //也可以不取地址。语法糖。

    normal_funcptr(); //调用方式，不解引用也可以，语法糖
    normal_funcptr1();

    (*normal_funcptr)();    //解引用，正确方式。应该这么写，更加清晰。
    (*normal_funcptr1)();

    test classobj;
    test* classobj_ptr = new test();
    void (test::*class_nonstatic_func_ptr)() = &test::class_nonstatic_func; //获取类非静态成员函数指针，必须取地址
    //获取类获取类非静态成员函数指针 必须在指针名字前面加类作用域，用来辨别。
    (classobj.*class_nonstatic_func_ptr)(); //对象调用。调用类成员函数指针必须加*解引用。而且需要绑定对象。
    (classobj_ptr->*class_nonstatic_func_ptr)(); //指针调用。调用类成员函数指针必须加*解引用。



    void(*class_static_func_ptr)() = &test::class_static_func; //获取类静态成员函数指针 ，必须取地址
    //获取类获取类静态成员函数指针 不需要指针名字前面加类作用域。因为静态成员函数可以理解为在类作用域内的全局函数。
    //所以取地址还要加作用域，函数名字不需要。
    class_static_func_ptr(); //直接调用。语法糖
    (*class_static_func_ptr)(); //直接调用。解引用

    //!(classobj.*class_static_func_ptr)();     //对象调用错误
    //!(classobj_ptr->*class_static_func_ptr)();//指针调用错误


    return 0;
}
```



- 声明
  - 普通函数指针
    - 直接取名字即可
  - 类成员函数指针
    - 必须在指针名字前面加类作用域，用来辨别。
  - 类静态成员函数指针
    - 和普通函数指针一样，不需要加作用域。因为静态成员函数可以理解为在类作用域内的全局函数。（所以赋值依旧需要取地址+作用域）

- 赋值
  - 普通函数指针
    - 可以直接用函数名赋值。语法糖。
    - 也可以取地址
  - 类成员函数指针和类静态成员函数指针
    - 赋值必须要加作用域解析运算符并且取地址

- 调用
  - 普通函数指针
    - 直接调用。语法糖
    - 解引用调用。注意解引用必须加括号。
  - 类成员函数指针
    - 不可以直接调用，必须解引用。同时必须绑定对象使用对象调用或对象指针调用
    - 类内必须使用this用来充当绑定对象。
  - 类静态成员函数指针
    - 和普通函数指针一样。
    - 直接调用。语法糖
    - 解引用调用。注意解引用必须加括号。

# 为构造函数提供默认值

两种方式。第一种是用构造函数初始化列的方式：

```c++
class test{
    public:
        test(int x = 5, int y = 10):_x(x), _y(y){};
        int _x, _y;
};
int main(){
    test t;
    cout << t._x << endl;
}
```

第二种是常规方式

```c++
class test{
    public:
        test(int x = 5, int y = 10){
            _x = x; 
            _y = y;
        }
        int _x, _y;
};
int main(){
    test t;
    cout << t._x << endl;
}
```



# 指针名称解读

## 顺序系列

- `int* p[10] `意思是`p`是一个大小为`10`的储存`int*`类型指针的数组 。
  - 它是一个指针数组
- `int (*p)[10]`意思是有一个指针`p`指向一个大小为`10`的储存`int`类型的数组。
  - 它是一个指向数组的指针
- `int* p(int) `是一个名为`p`的函数，这个函数返回`int*`，入参是`int `。
  - 它是一个函数
- `int (*p)(int)`是一个名为`p`的函数指针，这个函数指针指向的函数返回值为`int`，入参为`int`。
  - 它是一个函数指针

## const系列 const关键字总是优先作用于左侧的东西，除非左侧没东西。

- `const int *ptr; = int const *ptr; = const int* ptr; = int const* ptr`
  - 把`*`念成指向, 这句话翻译过来就是：指针`ptr`指向`const int`
  - 这是一个常量指针。
- `int* const ptr`
  - 把`*`念成指向 这句话翻译过来就是：`const`指针`ptr` 指向`int``
- ``const int* const ptr`
  - 把`*`念成指向 这句话翻译过来就是：`const`指针`ptr`指向`const int`

# 指针计算

## 指针A给指针B赋值的意思是将指针A指向的地址赋给指针B

```c++
int digit = 5;
int* a = &digit;
int* b = a; //指针a指向的地址赋给指针b 没有新对象产生所以不会调用拷贝构造。
int* c = &*a; //等同于将指针a先解引用（*a = 5），得到指针a指向的的值。然后把这个值取地址(&*a)赋值给指针c。

cout << b << endl; //打印b储存的地址。也就是b指向的地址。 等同于&digit和*&b
cout << *b << endl; //解引用b 打印b指向的地址的值。
cout << &b << endl; //打印b自己的地址。
cout << &digit << endl; //打印变量地址。

```

再来个例子：

```c++
int a = 5;
int* ptr = &a;

cout << &a <<endl;      //打印a的地址。0x61fe1c
cout <<ptr << endl;     //打印指针ptr储存的值，也就是a的地址。0x61fe1c
cout <<&ptr << endl;    //打印指针ptr自己的地址。0x61fe10
cout <<*&ptr << endl;   //打印指针ptr储存的值。也就是a的地址。0x61fe1c
// *&ptr = ptr = &a;
```

![QQ截图20220905085526](/assets/blog_res/2022-07-24-%E6%9D%82%E8%AE%B02.assets/QQ%E6%88%AA%E5%9B%BE20220905085526.png)





## 指针加法

### 指针直接和数字相加：意思是指针当前指向的地址 + 对应指针类型的大小 * 数字。

举例：

```c++
int * p;
p = (int*)malloc(100); //分配100字节。
cout << p<< endl; //打印p储存的地址。也就是指针指向的地址。是内存首地址。此处输出 0x771410
auto y = p + 1; //把p指向的地址偏移4位（因为int是4字节）后赋值给y。
printf("%#x",y); //打印y储存的地址。也就是指向的地址。此处输出 0x771414
```

**也就是说指针直接和数字相加，可以理解为用指针操作数组。加几就是将指针往后移动几位。具体偏移量也就是对应对象的大小*移动位数。**



### 如果想要指定一个具体的偏移量应该怎么办？

首先，可以使用转型将指针转换为对应类型。然后再加数字。

举例：

```c++
obj* p;
p = (obj*)malloc(sizeof(int) * 10);
cout << p<< endl; //打印p储存的地址。也就是指针指向的地址。是内存首地址。 此处输出 0x771410
auto x = (char*)p + 1; //把p指向的地址偏移1位后赋值给x。因为char是1位。
printf("%#x\n",x); //打印x储存的地址。也就是指向的地址。此处输出 0x771411
auto y = (obj*)p + 1; //把p指向的地址偏移8位后赋值给x。因为obj是指针类型。8位。
printf("%#x\n",y); //打印y储存的地址。也就是指向的地址。此处输出 0x771418
```

**注意：指针类型转换指的是指针转换为对应类型的指针。**

**此处不要使用`cout`**

`auto x = (char*)p`的意思是把指针`p`转为`char*`类型的指针。不可以`auto x = (char)p`。 这样做的意思是直接转换成了`char`。当然，所有的指针都是8字节。记住，指针类型指的是告诉指针应该读取指针指向的地址之后多大的数据。

怎么理解这个操作呢。我们可以想一下。如果 `a`是`int*`类型，也就是`int`类型指针。意思是指针`a`指向的数据是`int`，所以需要以`4`字节为一段进行读取。也就是一次读取四个字节。那么`a+1`其实是对地址进行了`+4`操作。因为指针+1的意思是将指针往后移动一个**对象位。也就是指针当前指向的地址 + 对应指针类型的大小（此处为4） * 数量（此处为1）**。但是我们如果想要对地址`+1`的话怎么办？我们可以把指针`a`转换为`char*`类型也就是`char`类型指针。而不是`int`类型指针。这样相当于告诉编译器，指针`a`指向的数据是`char`。所以需要以1字节为一段进行读取。也就是一次读取一个字节。所以此时`a+1`就是对地址进行了`+1`操作。**也就是指针当前指向的地址 + 对应指针类型的大小（此处为1） * 数量（此处为1）。**

移动一个对象位也就是移动的偏移量为对象大小。



```c++
int digit = 5;
int* a = &digit;
cout << a << endl;
auto x = (char*)a + 1;
printf("%#x\n",x);
```

**注意！`(char*)a + 1`往后移动1位的时候，`(char*)a`的意思是把指针a看成指向`char`类型的指针（告诉编译器一段是1）。所以`(char*)a + 1`不是+2，还是+1。因为指针`a`指向的地址根本没变。仅仅是看成了`char`类型的指针后+1**





# 关于`const`函数重载。修饰（成员）函数的`const`算作函数签名的一部分



## `const`修饰函数参数**一般**不作为函数签名的一部分。除非修饰的参数是指针或引用。

- `const`修饰的函数参数是值的时候不可以进行重载。如下代码编译错误。

```c++
class myobj{
    public: 
        myobj(int x):cal(x){}
        int cal;
};
void func1(myobj a){
        cout << "non const" << endl;
        }
void func1(const myobj  a){
    cout <<"const" << endl;
}
```

- **`const`修饰的函数参数是指针或引用的时候可以进行重载。**

- 以上例外`const`必须修饰的是指针指向的内容， 即ponter-to-const;
  - 如果是指针本身是`const`的，则不能重载
  

```c++
//指针
void func(myobj* a){
        cout << "non const" << endl;
        }
void func(const myobj* a){
    cout <<"const" << endl;
}
//引用
void func1(myobj& a){
        cout << "non const" << endl;
        }
void func1(const myobj& a){
    cout <<"const" << endl;
}


int main(){
    myobj* a = new myobj(10);
    const myobj* b = new myobj(20);
    func(a); //输出non const
    func(b); //输出const


    myobj obj(10);
    myobj& refa = obj;
    const myobj& refb = obj;

    func1(refa); //输出 non const
    func1(refb); //输出 const


    return 0;

}
```



- const引用可以绑定到非const对象，但是非const引用不可绑定const对象。因为不能保证其不被修改。

```c++
string t = "234"; //非const对象
const string& y = t; //可以 const引用

const string s = "234"; //const对象
string& b = s; //不可以 非const引用

```

- 所以函数入参为引用的时候，非const对象可以传入const参数。也就是const引用绑定到非const对象。比如作用是防止修改。但是const对象不可传入非const参数。也就是非const引用不可以绑定到const对象。

```c++
void test(const string& a){
    cout << a << endl;
}

void test2(string& a){
    cout << a << endl;
}
int main(){
    const string str1 = "234";
    string str2 = "234";
    test(str1);
    test2(str1); //不可以。const对象不能传入非const参数
    test(str2);
    test2(str2);

}
```



- **值传递不受影响**



# const如果放在函数后面（修饰成员函数）只能放在类成员函数后面

先看代码

```c++
    public:
    int vala;
    int valb;
    myclass(int x, int y):vala(x), valb(y){}

    void changethis(myclass& obj)const {
        cout <<"const" << endl;
    }
    // void changethis(const myclass* const this, myclass& obj) const{ 
    //     cout <<"non const" << endl;
    // }
    void changethis(myclass& obj) {
        cout <<"non const" << endl;
    }
    // void changethis(myclass* const this, myclass& obj) {
    //     cout <<"non const" << endl;
    // }
};

int main(){
    myclass obj(10,20);
    const myclass obj1(10,20);
    obj.changethis(obj);
    obj1.changethis(obj);
    return 0;
}
```
`const`放在类成员函数后面的意义是，**不可以修改当前调用对象的数据成员的值**。切记注意，入参是否可以被修改是不归函数管的。函数加`const`只是负责**禁止修改调用方**。在这里也就是禁止修改调用方`obj1`的值。



## const修饰成员函数修饰的是什么？是this指针

我们在上面代码段看到了两段被注释掉的函数，里面写出了如果显式`this`指针会是什么样。

- 注意，由于`this`指针不能改变指向，所以`this`指针是一个常量指针。也就是`myclass* const this`。

- 如果我们不想修改一个参数的值，办法就是让这个参数被`const`修饰。在这里就是把this指针也用`const`修饰。则会变成`const myclass* const this`。这也说明了为什么`const`只能修饰成员函数，因为非成员函数没有this指针。


- 又由于this指针会被编译器根据对象来隐式传入。所以const对象的this指针必然是也是常量指针。所以自然const对象无法调用非const函数。因为this指针的不匹配。const可以被隐式（函数调用）加上但是不能被去除。也就是权限的缩紧是可以的，放松是不可以的。

- 简单理解就是因为const成员无法进行修改。如果const成员变量调用了非const函数，函数不能保证不修改const成员，如果修改了会报错，所以直接加以限制。当然了非const成员因为可以修改也可以不修改，都不会报错。所以自然可以调用const函数也可以调用非const函数。


- `const`成员函数不能调用非`const`成员函数。因为在`const`成员函数里面的`this`指针被`const`修饰，在`const`成员函数里面调用非`const`成员函数时，相当于将`const`修饰的`this`指针传给非`const`成员函数。
  - 也可以理解为权限的扩张是禁止的。**不可以修改（整体）-> 可以修改（局部）是不可以的。**
- 非`const`成员函数可以调用`const`成员函数的原因是：权限的缩紧是可以的。
  - 也就是：**可以修改（整体）->不可以修改（局部）这样是可以的**



## 注意 this指针并不是对象本身的一部分。

注意 `this`指针并不是对象本身的一部分。也不会影响`sizeof`的结果。它的作用域是在类的内部。`this`指针只不过会在调用非静态函数的时候被编译器隐式加入。





![unknown](/assets/blog_res/2022-07-24-%E6%9D%82%E8%AE%B02.assets/unknown.png)







## 关于const函数重载。`const`算作函数签名的一部分

我们在上面代码可以看到，我们有一个函数重载。因为`const`算作函数签名的一部分。

**但是编译器如何判断我们调用的是哪个函数呢？虽然表面参数一样，但其实隐藏的`this`形参是不同的。**

- 所以如果我们调用方是`const`对象，则会调用`const`版本的函数。如果是非`const`对象就调用非`const`版本的函数。

![unknown (1)](/assets/blog_res/2022-07-24-%E6%9D%82%E8%AE%B02.assets/unknown%20(1).png)



# 为什么返回值类型不能做为函数重载的依据？也就是为什么仅返回值不同的函数不可重载？

- 理论上来说就是函数的返回值不是函数签名的一部分。
- 实际上来说是有二义性。比如

```c++
int func();
string func();

int main(){
    func(); //调用哪个func?
    return 0;
}
```

如上面代码，调用`func`的时候编译器无法确定到底调用哪个`func`。



# 关键字 final

- final关键字的意义是**阻止子类重写自身（父类）的虚函数**。
- 一般不用在父类，因为没有意义。
- **一般用在某个子类防止子类的子类重写子类的虚函数 或者是 禁止继承。**

