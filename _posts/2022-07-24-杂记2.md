---
title: C++杂记 - 2
date: 2022-07-20 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true

---

# C++杂记 - 2

# 关于`delete this`

## 能否在类的析构函数中调用`delete this`?

**不能**

实验告诉我们，会导致堆栈溢出。原因很简单，**`delete`的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存**显然，`delete this`会去调用本对象的析构函数，而析构函数中又调用`delete this`，形成无限递归，造成堆栈溢出，系统崩溃。

## 能否在类的其它函数中调用`delete this`？

**可以，但不可以涉及到任何和this指针（成员变量，成员函数，虚函数）相关的东西。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。**

首先，让我们明确几点概念

- 在类对象的内存空间中，只有数据成员和虚表指针，并不包含代码内容。类的成员函数单独放在代码段中
- 在调用成员函数时，隐含传递一个`this`指针，让成员函数知道当前是哪个对象在调用它。当 调用`delete this`时，类对象的内存空间被释放。在`delete this`之后进行的其他任何函数调用，只要不涉及到`this`指针的内容，都能够正常运行。一旦涉及到`this`指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。

- **`delete this`释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的。这时访问数据成员可能是随机数，访问虚表发生指针无效的概率很高，系统崩溃。**

## 什么时候可以？

`this`指向的实例必须是`new`出来的，不能是`new[] `/`placement new`出来的，也不能是栈上的，也不是全局变量。只能是简单的`new`出来的。

调用了`delete this` 的成员函数（下面称为当事函数）**返回**后，这个实例不可以调用其他任何成员函数（这好理解，涉及到`this`指针，因为实例不存在了）。这个成员函数应当成为这个实例访问的最后一个函数。

调用了`delete this` 的成员函数后（从`delete this`这一行之后开始），这个实例不可以调用任何成员函数和成员变量（这好理解，理由同2）

调用了`delete this`之后，不得以任何形式提及`this`，包括比较、打印、类型转换等（因为this已经不存在了）。



# 什么时候需要虚析构函数

是多态基类的时候。多态一定有虚函数。（effective C++ 第七条)

**多态实现：通过指针+向上转换(子类转父类)(父类指针指向子类对象） + 虚函数 = 动态绑定 、虚机制**

## 为什么如果析构函数不是虚函数的时候，仅仅执行父类析构函数？

很多人可能会有疑问，问我们知道构造顺序是先父类构造再子类构造，析构顺序是先子类析构再父类析构（仅多态情况）。那么为什么我父类析构不是虚析构的时候仅执行父类析构？难道不应该是仅执行子类析构吗？

**因为忘了一点，多态调用必须是虚函数才可以，仅通过父类指针指向子类对象是不会触发虚机制（动态绑定（多态））的。**

**虽然父类指针可以指向子类，但是其访问范围还是仅仅局限于父类本身有的数据，那些子类的数据，父类指针是无法访问的。**

### 类继承是静态绑定，包含虚函数的情况才是动态绑定

```c++
class A{
    public:
    A(){}

};

class B: public A{
    public:
    B(){}
    int bval = 3;
};

class C :public B{
    public:
    C(){}
    int cval = 4;
};

int main(){
    A* a = new C;
    cout << a->bval << endl; //错误。类A没有成员bval
}
```

当定义一个指向子类实例的父类指针的时候，内存中实例化了子类，由于子类继承了父类,因此内存中的子类里包含父类的所有成员。但由于**申明的是父类指针，因此该指针不能够访问子类的成员，而只能访问父类的成员。然而在父类里可以声明纯虚函数和定义虚函数，使用父类指针访问虚函数或纯虚函数的时候，访问到的是子类里重写的函数。当然，对于虚函数，如果子类里没有对其重写的话，仍然访问到父类里定义的虚函数**。



**父类指针指向子类对象，仅可访问子类的父类部分。因为不知道子类的内存布局，所以没法访问子类的部分。也就是说，父类指针指向子类对象会发生隐式转换。所以说它还是个父类类型。**

多态的时候由于有RTTI所以可以在运行时获知子类类型。



**我们提到过，指向虚表的指针`_vfptr`是子类的父类部分。也就是父类指针可以访问的到子类的指向子类自己的虚表的指针`_vfptr`。父类访问这个指针后即可访问子类的虚表。（反复强调虚表一个类只有一个）。访问到这个虚表后，就会查表。即访问对应的虚函数。如果子类有重写，那么这个对应的虚表中的函数会在编译期就从父类的覆盖为子类的。这样就可以执行子类的函数了。如果子类没写，那个虚表里面的函数就还是父类的虚函数。**

所以，如果没有虚析构，则虚表里没有这一条。那么编译的时候发现不是虚函数，就会静态的将父类的析构函数编译过来。如果有了虚析构，则虚表里会有这一条。于是就会执行正常多态析构动作，先调用子类析构，再调用父类析构。也就是根据指向的对象找到对象的虚表指针，找到对象的虚表再调用对应的虚函数。实现多态。



# 运算符的重载，参数的数量怎么确定？在类里面和不在类里面？不在类里面声明怎么访问类里面的属性（如果是私有的呢？）

## 运算符重载

```c++
class multiple{
    public:
    int vala;
    int valb;
    multiple(){}
    multiple(int x, int y):vala(x), valb(y){}
    const multiple operator*(const multiple& rhs) const{
        multiple temp(this->vala * rhs.vala, this->valb*rhs.valb);
        return temp;
    }
    注意 乘法我们说是有两个参数即a*b 但是这里现在是成员函数，第一个参数默认是调用对象 即this 所以形参只有一个rhs。
    但是我们可以写为非成员函数，这样形参就会有rhs和lhs。
    非成员函数在进行隐式类型转换的时候可以实现交换律。参考effectiveC++ 条款24
    void getval(){
        cout << this->vala<< ", " << this->valb << endl;
    }

};

const multiple operator*(const multiple& lhs, const multiple& rhs){
    multiple temp(lhs.vala * rhs.vala, lhs.valb*rhs.valb);
    return temp;
}

//类外可以这么写。注意const不可修饰非成员函数！！
int main()
{
    multiple t1(5,5);
    multiple t2(6,4);
    multiple t3 = t1 * t2;
    t3.getval();
这里t3 = t1 * t2本质上是t3 = t1.operator*(t2)
t1是this，t2是rhs，t1.operator*(t2)对应函数返回值
}
```

 注意 这里重载第三个const的目的是让这个函数成为const函数。目的是可以被const对象调用 这里的例子就是我们避免以外赋值，使重载返回值也是const 因为如果不设置const的话 像是

```c__
(t1 * t2) = t3;
```

这种就不会报错。因为t1\*t2被当成了一个multiple类型的变量。可以给它赋值。因为它返回一个multiple对象。但是这违背了我们的意愿。所以我们加const来模拟常量确保t1\*t2不会被赋值 如果我们这个重载函数不设置const属性（也就是第三个const）的话，我们这样就无法链式调用了。因为我们现在的t1\*t2返回的是一个const multiple对象。const对象无法调用非const函数。所以我们的函数必须要const 

- 当运算符重载为**类的成员函数**时，函数的参数个数比原来的操作数要少一个（后置单目运算符除外），这是因为成员函数用this指针**隐式地访问了类的一个对象**，它充当了运算符函数最左边的操作数。因此：

  - 双目运算符重载为类的成员函数时，函数**只显式说明一个参数**，该形参是运算符的右操作数。

  - 前置单目运算符重载为类的成员函数时，**不需要显式说明参数**，**即函数没有形参**。

  - 后置单目运算符重载为类的成员函数时，函数要带有一个整型形参。

  - 调用成员函数运算符的格式如下：
    ```c++
    <对象名>.operator <运算符>(<参数>)
    它等价于
    <对象名><运算符><参数>                
    ```

- 当运算符重载为**类的友元函数**时，由于没有隐含的this指针，因此操作数的个数没有变化，所有的操作数都必须通过函数的**形参**进行传递，函数的参数与操作数自左至右一一对应。调用友元函数运算符的格式如下：

  ```c++
  operator<运算符>(<参数1>,<参数2>)
  它等价于
  <参数1><运算符><参数2>
  ```
  - **友元函数必须在类内声明。但是可以在类内或类外定义**
  ```c++
  class multiple{
      public:
      multiple(){}
      multiple(int x, int y):vala(x), valb(y){}
      friend const multiple operator*(const multiple& lhs, const multiple& rhs); //类内声明
      void getval(){
          cout << this->vala<< ", " << this->valb << endl;
      }
      private:
      int vala;
      int valb;
  
  };
  const multiple operator*(const multiple& lhs, const multiple& rhs){ //类内或类外定义均可。
      multiple temp(lhs.vala * rhs.vala, lhs.valb*rhs.valb);
      return temp;
  }
  int main()
  {
      multiple t1(5,5);
      multiple t2(6,4);
      multiple t3 = t1 * t2;
      t3.getval();
  }
  ```

- 在类外，因为不是成员函数所以没有this指针，所以必须要有全部参数。

## 解答：

1. 在类内，如果是双目运算符就少一个。因为左手部分是this。隐式传递。如果是类外，就正常两个。
2. 不在类里面声明，可以正常访问类公有部分。如果需要访问私有部分就需要使用友元函数。



# 关于mutable

很多人多`mutable`有错误认知。不仅仅是因为用得少，而且是有模糊概念。

**`mutable`是修饰成员变量所用。他的作用是让这个成员变量在任何时候都可以被修改，无论是:**

1. 做为参数传入形参带有`const`的函数
2. 做为参数传入被`const`修饰的(成员)函数
3. 在被`const`修饰的(成员)函数中
4. 被`const`修饰的变量中

首先举反例：

```c++
mutable int a; //这是啥？
const mutable int a; //这又是啥？
```

下面，正式开始举例：

```c++
class multiple{
    public:
    multiple(){}
    multiple(int x, int y):vala(x), valb(y){}
    
    
    mutable int vala;
    int valb;

};
```

我们拿到了类的定义。我们开始举例

```c++
mutable const int vala; //不可以 这啥玩意
const mutable int vala; //不可以 这啥玩意
```

**为了简便起见，我们只举成员函数的例子**

```c++
class multiple{
    public:
    multiple(){}
    multiple(int x, int y):vala(x), valb(y){}
    //------------------------------------- 被const修饰的成员函数
    void test1(multiple& x) const{
        vala = x.vala;
        x.vala = vala;
    }
    //-------------------------------------被const修饰的函数形参
    void test2(const multiple& x){
        vala = x.vala;
        x.vala = vala;
    }
    //-------------------------------------被const修饰的成员函数 和 被const修饰的函数形参
    void test3(const multiple& x) const{
        vala = x.vala;
        x.vala = vala;
    }
    //-------------------------------------
    mutable int vala;
    int valb;
};
```

**以上三个函数代表了三个例子。我们发现被无论是在被`const`修饰的成员函数中 还是 被当成参数传入被`const`修饰的函数形参中，我们都可以修改`mutable`修饰的变量。**

还有第四个例子

```c++
const multiple t1(3,3);
t1.valb = 3; //不可以
t1.vala = 3; //可以 因为被mutable修饰
```





# 关于`const_cast`

## 给一般读者：

- 常量指针（指向常量的指针）被转化成非常量的指针，并且仍然指向原来的对象；
- 常量引用被转换成非常量的引用，并且仍然指向原来的对象；

我们来看代码：

```c++
using namespace std;
class multiple{
    public:
    multiple():valc(0){}
    multiple(int x, int y, int z):vala(x), valb(y), valc(z){}
    int vala;
    int valb;
    const int valc;

};

int main()
{
    multiple p(1,3,5);
    const multiple* const_ptr = &p; 					//指向常量的指针
    //---------------------------------------------------------------------
    const_ptr = const_cast<multiple*> (const_ptr);		//进行const cast
    const_ptr->vala = 100;								//不可以, 必须要赋值给新的指针。
    const_cast<multiple*> (const_ptr)->vala = 100; 		//可以

    //---------------------------------------------------------------------
    multiple* ptr = const_cast<multiple*> (const_ptr);	//赋值给新指针
    ptr->vala = 10;										//可以
    ptr->valc = 100;									//不可以。因为valc是常量。
}
```



### 具体使用场景

### 1. **一个函数的形参数不是const对象，并且编程者事先已经知道在这个函数中不会对参数进行修改，但需要传递的实参却是已经定义好的const对象。为了成功调用这个函数，就需要利用到const_cast在实参传递前对其进行处理，从而使函数能够成功接收这个实参**

代码：

```c++
void Function(int &val){
    cout<<val<<endl;
}
int main(){
    const int value=21;
    Function(value);					//不可以
    Function(const_cast<int&>(value));	//转换为常量引用，可以
    return 0;
}
```





### 2. **如果我们定义了一个非const的变量，却使用了一个指向const对象的指针来指向它，而在程序的某处希望改变这个变量时发现只有指针可用，此时就可以const_cast进行处理**

```c++
int main(){
    int value=26;
    const int* const_ptr=&value;
    *const_ptr=3;							//不可以
    int* ptr=const_cast<int*>(const_ptr);	//转换为常量指针。可以
    *ptr=3;
    return 0;
}
```





## 给能思考的读者。因为这里我还没有完全弄明白，可能存在错误

我们直接看代码

```c++
class multiple{
    public:
    multiple():valc(0){}
    multiple(int x, int y, int z):vala(x), valb(y), valc(z){}
    int vala;
    int valb;
    const int valc;

};
int main()
{
    const multiple np(2,4,6);					//常量对象
    multiple ucnp = const_cast<multiple&>(np);	//这里下面会解释
    ucnp.vala = 10;
    //---------------------------------------------------------
    cout << ucnp.vala<< endl;						//输出10
    cout << ucnp.valb<< endl;						//输出4	
    cout << ucnp.valc<< endl;						//输出6
    //---------------------------------------------------------
    cout << np.vala<< endl;						//输出2
    cout << np.valb<< endl;						//输出4	
    cout << np.valc<< endl;						//输出6
}


```

**这里面我们进行`const_cast`的时候返回值并没有使用引用来接受。这是可以的。这里会产生一个临时变量做为中间值传给了结果值**

**有没有注意到问题，我们的`np`不是引用，是个对象。可能无法直观感受，我们接着看**  

这句话不知道对不对。来自：https://www.cnblogs.com/dracohan/p/3417842.html

下面有更狠的。

我们把`ucnp`换成引用。看看结果如何

```c++
int main()
{
    const multiple np(2,4,6);					//常量对象
    multiple& ucnp = const_cast<multiple&>(np);	//注意这里
    ucnp.vala = 10;
    //---------------------------------------------------------
    cout << ucnp.vala<< endl;						//输出10
    cout << ucnp.valb<< endl;						//输出4	
    cout << ucnp.valc<< endl;						//输出6
    //---------------------------------------------------------
    cout << np.vala<< endl;						//输出10
    cout << np.valb<< endl;						//输出4	
    cout << np.valc<< endl;						//输出6
}

```

**好像没什么问题啊？确实是这样的嘛。常量引用转换成非常量引用，有啥问题？**

**你再仔细看一眼。`np`是什么？是对象啊。这是个常量对象啊，我们修改了常量对象啊！**

我们可以来一个更明显的例子：

```c++
int main{
    
    multiple p(1,3,5);
    cout << p.valc << endl;					//输出5
    int& wtf = const_cast<int&>(p.valc);	//修改常量。
    wtf = 1000;
    cout << p.valc << endl;					//输出1000
    return 0;
}
```

**我们的`valc`是一个`const int`。但是这里我们修改了一个对象里的常量。**

**以上操作，编译器没有任何警告。但是这应该是一个未定义行为。需要避免修改任何已经声明为常量的对象。`const_cast`只能正确转换顶层（引用，指针）的常量性质，但是无法正确转换底层（引用的本体，指针指向的对象）的常量性质。强行转换会导致未定义行为。**

# 迭代器失效

我总是把迭代器失效理解成错误的含义。我们简单讲一下真正的含义是什么，不作具体细节展开

```c++
    vector<int> a = {1,2,3,4,5,6,7,8,9,10};
    auto it = a.end();
    cout << *(it-1) << endl; //输出10
    cout << a.size()<<endl; //输出10
    cout << a.capacity()<<endl; //输出10
    a.insert(a.begin() + 3, 3333); //插入后扩容，数据转移至新区域，原来区域被释放
    cout << *(it-1) << endl; //输出无效数据，迭代器失效。
```

首先，我们要知道。`begin()` 和`end()`每次都会动态的返回对应的迭代器，所以这俩不会失效。

啥时候会时效呢？**当有一个额外的手动赋值的迭代器出现的时候**

这句话是啥意思呢

比如：

`for(iter = a.begin();;)` 这里你声明了一个新的`iter`来接收这个调用`begin()`返回的迭代器。这就是另一个迭代器

或者如上图的：`auto it = a.end()`。这里也是新的。

所以为什么在for循环里对迭代器操作的时候会失效。因为你操作的迭代器不是动态获取的，而是你已经获取到之后对迭代器进行加减操作的。

另外一个简单例子

```c++
    vector<int> a;
    a.reserve(20);
    for(int i = 0 ;i < 10; i++){
        a.push_back(i);
    }
	//这时候a是{0,1,2,3,4,5,6,7,8,9}
    auto it = a.end();
    cout << *(it-1) << endl; //输出9
    a.insert(a.begin() + 3, 3333);
	//这时候a是{0,1,2,3333,3,4,5,6,7,8,9}
    cout << *(it-1) << endl; //输出8。
}
```

因为迭代器已经被赋值。对迭代器的加减操作我们可以理解为原始数组对指针的加减操作。所以原来的时候，最后一位指向的内存地址存的是9，我们可以理解为`end-1`是`begin+9`。我们执行`insert`之后，由于迭代器没有重新赋值，所以`begin+9`指向的内存地址不变。但是`insert`会让插入位置后的元素后移，8会被移到原来9的内存地址上。这样就是迭代器失效。
