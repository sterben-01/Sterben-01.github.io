---
title: C++杂记 - 3
date: 2022-09-06 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true
  
---



# C++杂记 - 3

# std::bind, std::function 和 std::mem_fn

## std::bind 包括但不限于mem_fn的功能，更为通用的解决方案

**什么是bind？我们可以把它看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。**

std::bind将可调用对象与其参数一起进行绑定**，绑定后的结果可以使用std::function保存**。std::bind主要有以下两个作用：

- 将可调用对象和其参数绑定成一个仿函数；
- 只绑定部分参数，减少可调用对象传入的参数。

语法：

```c++
auto newCallable = bind(callable, arg_list);
```

该形式表达的意思是：当调用`newCallable`时，会调用`callable`，并传给它`arg_list`中的参数。

需要注意的是：`arg_list`中的参数可能包含形如`_n`的名字。其中`n`是一个整数，这些参数是占位符，表示`newCallable`的参数，它们占据了传递给`newCallable`的参数的位置。数值`n`表示生成的可调用对象中参数的位置：`_1`为`newCallable`的第一个**待填充**参数，`_2`为第二个**待填充**参数，以此类推。
注意这些占位符在`std::placeholders`名称空间内。

- **std::bind的返回值是可调用实体，可以直接赋给std::function**。

- **bind绑定类非静态成员函数时，第一个参数表示对象的成员函数的指针，第二个参数表示对象的地址，这是因为对象的成员函数需要有this指针**。并且编译器不会将对象的成员函数隐式转换成函数指针，需要通过&手动转换（符合成员函数指针的赋值语法）。静态成员函数无需此操作。因为没有this指针。

```c++
class my_class{
    public:
    int val;
    my_class(int x):val(x){}

    void getval(){
        cout << val << endl;
    }
    void add(int another){
        val = val + another;
        cout << val << endl;
    }
    static void staticfunc(int val){
        cout << "static" << val << endl;
    }
};
int main(){
    my_class obj1(10);
    auto task2 = bind(&my_class::getval, &obj1); 	//调用无参函数，this参数预绑定。成员函数指针遵循语法。
    auto task3 = bind(&my_class::add, &obj1, placeholders::_1);	//调用有参函数，this参数预绑定。
    auto task4 = bind(&my_class::add, placeholders::_1, placeholders::_2); //调用有参函数，this参数使用占位形式。
    auto task5 = bind(&my_class::staticfunc, placeholders::_1); //静态成员函数没有this指针。无需传入。
    task2();
    task3(3); 
    task4(&obj1, 3); //this使用占位形式，需要调用时传入。
    task5(3);
    return 0;
}
```



 ## mem_fn 成员函数适配器 把成员函数转为函数对象，使用对象指针或对象(引用)进行绑定

**个人实验得出的结论：`mem_fn`是`bind`的子集**。

注意`mem_fn`不能调用类静态成员函数。因为没有this指针。

`mem_fn`就是强制给你把类对象塞进去。

比较：

```c++
class my_class{
    public:
    int val;
    my_class(int x):val(x){}

    void getval(){
        cout << val << endl;
    }
    void add(int another){
        val = val + another;
        cout << val << endl;
    }
    static void staticfunc(int val){
        cout << "static" << val << endl;
    }
};
int main(){
    my_class obj1(10);

    auto task1 = mem_fn(&my_class::getval); 
    task1(&obj1); //把对象地址传入

    auto task2 = mem_fn(&my_class::add);
    task2(&obj1, 5);

    //auto task3 = mem_fn(&my_class::staticfunc); 错误！静态成员函数不行。

    auto task1_1 = bind(&my_class::getval, placeholders::_1); //bind就得多写个参数
    task1_1(&obj1);
    
    auto task1_2 = bind(&my_class::getval, &obj1);
    task1_2();

    return 0;
}
```






## std::placeholders

我们提到了，我们使用`bind`的时候，`placeholder`是待填充参数。什么叫待填充？这是一种具象解释。其实它相当于生成了一个新的可调用对象，拥有两个参数。但是结合原本的可调用对象来看，我们有三个参数。所以站在原本的可调用对象角度来看，相当于待填充。

语法和例子：

```c++
void testfunc(int x, int y, int z){
    cout << x << endl;
    cout << y << endl;
    cout << z << endl;
}
int main(){

    auto callable1 = bind(testfunc, placeholders::_1, placeholders::_2, 5);
    callable1(8,80);
    //输出8 80 5
    auto callable2 = bind(testfunc, placeholders::_2, placeholders::_1, 5);
    callable2(8,80);
    //输出80 8 5

    auto callable3 = bind(testfunc, placeholders::_1, 5, placeholders::_2);
    callable3(8,80);
    //输出8 5 80
    auto callable4 = bind(testfunc, placeholders::_1, 5, placeholders::_3); //错误。新的调用对象只有两个参数。这里3超了。
    callable4(8,80);
    
    auto callable5 = bind(testfunc, placeholders::_1, 5, placeholders::_1); //极端情况。占位符可以重复。
    callable5(8);
    //输出8 5 8
}
```



参考资料：https://elloop.github.io/c++/2015-12-15/learning-using-stl-12-std-bind





## std::function

大家都用过函数指针。具体就不赘述了。稍微回忆一下函数指针的语法：

```c++
void(*another_a_ptr_ptr)(void) = (void(*)(void))*(long long*)(*a_ptr);
void(*another_a_ptr_ptr)(void); 这个函数指针的类型是void(*)(void)
```

成员函数指针的用法和声明在杂记2。

**std::function是一个可调用对象包装器，是一个类模板，可以容纳除了类成员函数指针之外的所有可调用对象，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟它们的执行**。







一个例子让你知道`function`怎么用：

```c++
int myfunc(int a){
    cout << a << endl;
    return a;
}

int myfunc1(const int& a){
    cout << a << endl;
    return a;
}

int myfunc2(int&& a){
    cout << a << endl;
    return a;
}

int main(){
    function<int(int)> func = myfunc;
    func(4);

    function<int(const int&)> func1 = myfunc1;
    func1(4);

    function<int(int&&)> func2 = myfunc2;
    func1(4);

    return 0;
}

```

**说白了就是类型是你的函数返回值类型+参数类型。**

我们前面提到过 `bind`的返回值是可调用实体，可以直接赋给`std::function`

```c++
function<void(void)> task1_2 = bind(&my_class::getval, &obj1);
task1_2();

function<void(int)> task2 = bind(&my_class::add, &obj1, placeholders::_1);
task2(5);
```

**有一个问题是，这里必须要显式把对象地址直接塞进去，不能把对象地址用占位符。因为参数对不上了。（个人实验）**

**故而，std::function的作用可以归结于：**

- std::function对C++中各种可调用实体(普通函数、Lambda表达式、函数指针、以及其它函数对象等)的封装，形成一个新的可调用的std::function对象，简化调用；
- std::function对象是对C++中现有的可调用实体的一种类型安全的包裹(如：函数指针这类可调用实体，是类型不安全的)。

# std::call_once 和 std::once_flag

通过`call_in_once`执行的可调用对象可以保证在多线程的状态下仅被（一个线程）执行一次

```c++
once_flag my_flag1; //这个flag是一次性使用的。必须要全局。而且如果有两个东西需要call_once就要两个flag
once_flag my_flag2;
void func1(){
    cout <<"func1" << endl;
}

void func2(int s){
    cout <<"func2" << s << endl;
}
void thread_exe(){
    //once_flag my_flag1; //错误 放在这里就是线程函数的局部变量。这样每个线程就会有自己的flag
    //once_flag my_flag2;
    call_once(my_flag1, func1);
    call_once(my_flag2, func2, 1);
}

int main(){
    thread mythread1(thread_exe);
    thread mythread2(thread_exe);
    mythread1.join();
    mythread2.join();

    return 0;
}
```

注意事项：

- `once_flag`对象对于所有线程来说应该是全局变量（或等同于全局变量的形式）。因为`once_flag`对象只能被使用一次。如果是局部变量，则放在这里就是线程函数的局部变量。这样每个线程就会有自己的`once_flag`对象，就无法起作用。
- 因为每一个`once_flag`对象是一次性的。所以如果有两个东西需要call_once就要两个`once_flag`对象
- 如果某个线程抛出异常，则`call_once`会选择下一个等候的线程重新执行`call_once`动作。

参考：https://blog.csdn.net/qq_31175231/article/details/77916028

https://blog.csdn.net/XJF199001/article/details/51435845

# 异步API。std::future, std::promise, std::packaged_task, std::async

想要进行多线程编程，这四个看起来高级的API是必不可少的。我们来看一看这一套异步编程套组里的四个组件到底有什么关系，他们是干什么的。

参考资料：https://segmentfault.com/a/1190000039201271

https://murphypei.github.io/blog/2019/04/cpp-concurrent-4

## std::future / std::shared_future

< future >头文件功能允许对特定提供者设置的值进行异步访问，可能在不同的线程中。
这些**提供程序**(要么是`promise` 对象，要么是`packaged_task`对象，或者是对异步的调用`async`)与`future`对象共享共享状态:提供者使共享状态就绪的点与`future`对象访问共享状态的点同步。

上面这段话翻译过来就是我们可以理解为future是一个时间胶囊, 一个对象**。这个对象的提供程序（如promise)里面储存了我们希望以后拿到的东西。然后我们用future来和提供程序连接起来，拿到提供程序里面的东西。**

我们看一下future的正式定义和具体细节。

- future 是一个对象，**可以从某个提供对象或函数中检索值**，如果在不同线程中，则可以正确同步此访问。
- 它提供了一种访问异步操作结果的机制。从字面意思上看它表示未来，这个意思就非常贴切，因为它不是立即获取结果但是可以在某个时候以同步的方式来获取结果。我们可以通过查询`future`的状态来获取异步操作的结果。`future_status`有三种状态：
  - `deferred`：异步操作还未开始。共享状态包含一个延迟函数，因此只有在明确请求时才会计算结果。（主要用于`async`函数的`std::launch::deferred`参数。)
  - `ready`：异步操作已经完成
  - `timeout`：异步操作超时。在指定的超时持续时间过去之前，共享状态尚未准备好
- “有效” future 对象，只能通过调用以下函数之一来构造：
  - `async` 
  - `promise::get_future`
  - `packaged_task::get_future`
- 默认构造的 future 对象是无效的（除非移动（move）分配一个有效的 future）。
- 在有效的 future 上调用 `future::get` 会阻塞线程，直到提供程序准备好共享状态（通过设置值或异常）。这样，两个线程可以通过一个线程同步，等待另一个线程设置值。
  - **`get()` 调用会改变其共享状态，不再可用，也就是说 `get()` 只能被调用一次，多次调用会触发异常。如果想要在多个线程中多次获取产出值需要使用 `shared_future`。**
- 共享状态的生存期至少要持续到与之关联的最后一个对象释放它或销毁它为止。因此，如果与 future 相关联，共享状态可以在最初获得它的对象（如果有的话）之后继续存在。

![20190506204825200](/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/20190506204825200.png)



几个函数详解：

### future::valid()

#### 检查有效的共享状态

- 返回 future 对象当前是否与共享状态关联。
- 对于默认构造的 future 对象，此函数返回 false (除非将有效的 future 分配给移动对象)。
- future 只能由某些提供函数（如， async, promise::get_future 或 packaged_task::get_future）使用有效的共享状态进行初始化。
- 一旦使用 future::get 检索了共享状态的值，则调用此函数返回 false (除非移动分配了一个新的 future).

#### 返回值

- 如果对象与共享状态关联，则为 ture。
- 否则为假。

**特别注意。返回值为true不代表此时共享状态已经就绪。只能表明对象与共享状态关联。**

### future::wait

#### 阻塞并等待共享状态就绪（结果可用）



### future::get

可以理解为包含了wait的操作。因为他调用了wait。（猜测）

#### 阻塞并等待共享状态就绪（结果可用），返回存储在共享状态中的值（或引发其异常）

- 当共享状态就绪时，返回存储在共享状态中的值（或引发其异常）。
- **如果共享状态尚未准备好（即提供程序尚未设置其值或异常），则该函数将阻塞调用线程直到准备就绪。**
- 共享状态就绪后，该函数将取消阻塞并返回（或引发异常）以释放其共享状态。**这时 future 对象不再有效**：**对于每个 future 的共享状态，此成员函数最多应被调用一次**。
- 提供者准备好共享状态和返回此函数之间是同步的。



### shared_future

`std::shared_future` 与 `std::future` 类似，但是 `std::shared_future` 可以拷贝、多个 `std::shared_future` 可以共享某个共享状态的最终结果(即共享状态的某个值或者异常)。**`shared_future` 可以通过某个 `std::future` 对象隐式转换（参见 `std::shared_future` 的构造函数），或者通过 `std::future::share()` 显示转换，无论哪种转换，被转换的那个 std::future 对象都会变为 not-valid**。`std::shared_future` 的成员函数和 `std::future` 大部分相同，这个地方就不一一展开了，需要的请查阅官方文档。



我们可以看到，想要创建一个有效的future对象必须依靠剩下的三个API。我们就来进一步看看剩下的几块内容。

## std::promise

promise是剩下三个当中最为“原始，底层“的API。

**`promise` 本质是一个类似我们打印输出中占位符的东西，你可以理解它就是一个等待数据装填的坑，它是一个“承诺”，承诺未来会有相应的数据（模板实现）**。因为这是一个“承诺”，所以创建的时候是没有东西的，所以我们需要知道这个异步操作什么时候能有东西，好实现“承诺”，所以 `promise` 可以通过调用 `get_future()` 返回一个 `future` 对象，让你去了解这个承诺是否完成了。因此，`promise` 是存放异步操作产出值的坑，而 `future` 是从其中获取异步操作结果，二者都是模板类型。

**这里理解为我们的future对象是一个接口，建立起与promise对象的联系。我们使用promise对象来进行异步操作，所以能看到我们并不需要把future对象传入线程。但是我们会通过future对象去获知这个异步操作的结果是否就绪，也就是promise对象是否已经包含了我们期望的结果。然后我们可以通过future来获取结果。**

- `promise` 是一个对象，由 `future` 对象（可能在另一个线程中）检索，并提供一个同步点。
- 通过调用成员get_future，可以将该共享状态与 future 对象关联。 调用之后，两个对象共享相同的共享状态：
  - promise对象是异步提供程序，应在某个时候为共享状态设置一个值。`set_value`
  - future 对象是一个异步返回对象，可以检索共享状态的值，并在必要时等待其准备就绪。
  - 理解为我们通过promise的get_future来创建我们的future对象。之后通过future对象（来检索）获得一个共享状态（结果）。

![20190506203234388](/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/20190506203234388.png)



### promise::set_value

- **以原子方式**将值存储到共享状态（就是把promise对象储存的值设置好），**并且改变该状态变为就绪状态**。（设置共享状态）
- 如果与同一共享状态关联的future对象当前正在等待对`future::get`的调用，则它将取消阻塞并返回val。
  - 因为future的get/wait会阻塞等待共享状态被设置完毕。



看看简单代码例子：

```c++
//使用promise进行异步
void accumulate2(std::vector<int>::iterator first, //注意不太需要返回值了。因为异步返回的值被储存在了promise对象中
                std::vector<int>::iterator last,
                std::promise<int> accumulate_promise) //函数头要有promise对象定义。
{
    int sum = std::accumulate(first, last, 0);
    accumulate_promise.set_value(sum);  // 将结果存入，并让共享状态变为就绪以提醒future
    //如果不set_value,那么调用了future::get/wait的线程将一直被阻塞。
}
 
int main()
{
    // 演示用 promise<int> 在线程间传递结果。
    std::vector<int> numbers = { 1, 2, 3, 4, 5, 6 };
    std::promise<int> accumulate_promise; //声明promise对象
    std::future<int> accumulate_future(accumulate_promise.get_future()); //通过promise对象的get_future来初始化(获取）future对象
    
    std::thread work_thread(accumulate2, numbers.begin(), numbers.end(),
                            std::move(accumulate_promise)); //启动线程。设置好执行函数和传入参数。注意必须要把promise对象一并传入（移入）
    //!这里也可以用ref。但是我们accumulate2的函数头要了个值。promise又禁用了拷贝构造所以这里目前只可以move。如果accumulate2函数头改为&就可以用ref
    // !可以用ref但是不推荐。因为如果你不转移所有权，万一你多个线程并发访问了promise，可能会有问题，
    !而且这也不符合设计，一般来说只应该让一个线程持有promise
    //accumulate_future.wait();  //等待结果 这个可以去掉，直接用get就可以
    
    std::cout << "result=" << accumulate_future.get() << '\n'; //get阻塞住等待共享对象变为ready。然后获取结果。
    work_thread.join();  //阻塞等待线程执行完成
 
    getchar();
    return 0;
}
```



## std::packaged_task

packaged_task比promise高级一点。直观来看就是参数少一点，操作少一点。稍后我们会有一个简单的对比。

`packaged_task` 是对一个任务的抽象，我们可以给其传递一个函数来完成其构造。相较于 `promise`，它应该算是更高层次的一个抽象，同样地，我们可以将任务投递给任何线程去完成，然后通过 `packaged_task::get_future()` 方法获取的 `future` 对象来获取任务完成后的产出值。总结来说，**`packaged_task` 是连数据操作（比如set_value)都封装进去了的 `promise`**。`packaged_task` 也是一个类模板，模板参数为函数签名，也就是传递函数的类型。

```c++
template <class T> packaged_task;     // undefined
template <class Ret, class... Args> class packaged_task<Ret(Args...)>;
```

- **std::packaged_task包装可调用对象，并允许异步检索其结果。**（可调用对象是重点）
- 类似于 std::function, 但是会自动将其结果传输到 future 对象。
- 对象内部包含两个元素：
  - 存储的任务是一些可调用对象（例如，函数指针，成员或函数对象的指针），其调用签名应采用 Args... 中类型的参数，并返回 Ret 类型的值。
  - 共享状态，该状态能够存储调用存储的任务（类型为 Ret）的结果，并且可以通过 future 来异步访问。
- 通过调用成员 get_future 将共享状态与 future 对象关联。调用之后，两个对象共享相同的共享状态：
  - packaged_task 对象是异步提供程序，通过调用存储的任务，可以在某个时刻将共享状态设置为就绪。
  - future 对象是一个异步返回对象，可以检索共享状态的值，并在必要时等待其准备就绪。

![2019050621124831](/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/2019050621124831.png)

看看代码实例，做一下比较：

```c++
//? 使用packaged_task进行异步
int accumulate(std::vector<int>::iterator first,
                std::vector<int>::iterator last) //注意函数头，我们没有像promise那样需要传入promise对象。
{
    int sum = std::accumulate(first, last, 0);
    return sum;  //所以也不需要promise的set_value
}
 
int main()
{
    // 演示用 packaged_task 在线程间传递结果。
    std::vector<int> numbers = { 1, 2, 3, 4, 5, 6 };
    std::packaged_task<int(std::vector<int>::iterator,std::vector<int>::iterator)> accumulate_task(accumulate);
    //创建packaged_task对象。注意这里有区别，下面详说。
    std::future<int> accumulate_future = accumulate_task.get_future(); //通过packaged_task对象的get_future来创建future对象
    std::thread work_thread(std::move(accumulate_task), numbers.begin(), numbers.end()); //启动线程。注意这里有区别了。
    /*
    @ 使用move的主要原因还有一个就是按值传递函数参数会调用拷贝构造。packaged_task禁用了拷贝构造，要么传引用要么换成右值引用转移所有权。
    */
    //accumulate_future.wait();  //等待结果 可以和下面的get合并
    std::cout << "result=" << accumulate_future.get() << '\n';
    work_thread.join();  //阻塞等待线程执行完成
 
    getchar();
    return 0;
}

```

**我们来说一说几点具体区别**

- 我们提到了，packaged_task包装的是可调用对象。但是promise仅仅是一个包装着异步执行结果的对象。所以：
  - packaged_task对象的模板类型是函数签名，因为他包装了可调用对象。
  - 所以线程执行的时候只需要移入packaged_task对象即可，无需传入函数本身。因为已经被包装了。
  - 所以包装的函数无需额外参数，函数内无需额外动作。
  - 因为promise会储存异步任务的结果，所以函数的返回值可以去掉。
- 其实理解了上面那一点，就理解了packaged_task和promise的区别。可以简单理解为promise是一个包装了执行结果的对象。而packaged_task是一个包装了整个任务的对象，它不仅包装任务执行结果，而且包装任务本身。





## std::async

async是最高级的一个API，代码简单，比较高层。它其实封装了其实是封装了thread 和 packged_task的功能，使异步执行一个任务更为方便

**async是函数，不是类模板。**

```c++
unspecified policy (1)    
template <class Fn, class... Args>
  future<typename result_of<Fn(Args...)>::type>
    async (Fn&& fn, Args&&... args);

specific policy (2)    
template <class Fn, class... Args>
  future<typename result_of<Fn(Args...)>::type>
    async (launch policy, Fn&& fn, Args&&... args);
```

- 异步调用函数在某个时刻调用 fn (以 args 作为参数)，返回时无需等待 fn 执行完成。(都说了是异步)
- **可以通过返回的 future 对象（通过调用其成员 future::get）来访问 fn 返回的值。**
- 第二个版本 （2） 允许调用者选择特定的启动策略，而第一个版本 （1） 使用自动选择，就好像调用 (2) 并将 launch::aysnc | launch::deferred 作为策略。
- 该函数在共享状态下临时存储使用的线程处理程序。一旦完成 fn 的执行，共享状态将包含 fn 返回的值并准备就绪。

| launch::async                     | 启动一个新的线程以调用 fn （就像使用 fn 和 args 作为参数构造线程对象，并访问返回的 future 的共享状态将其联接）`std::thread(std::forward<F>(f), std::forward<Args>(args)...)` |
| --------------------------------- | ------------------------------------------------------------ |
| launch::deferred                  | 意味着函数可能只会在std::async返回的future对象调用get或wait时执行。（函数在future对象调用了get或wait的时候才会开始执行）。**不会产出新的线程。该任务会在调用线程中执行。**。当调用get或wait时，函数会同步执行，即调用者会阻塞直到函数运行结束。如果get或wait没有被调用，函数就绝对不会执行。 |
| launch::async \| launch::deferred | 该功能自动（在某个时候）选择策略。这取决于系统和库的实现，他们通常会针对系统中当前的并发可用性进行优化 |

看一下细节

```c++
//? 使用async进行异步

int accumulate3(std::vector<int>::iterator first, std::vector<int>::iterator last){
    std::cout <<"async begin" << std::endl;
    int sum = std::accumulate(first, last, 0);
    std::cout <<"async end" << std::endl;
    return sum;
}

int main(){
    std::cout <<"main begin" << std::endl;
    std::vector<int> numbers = { 1, 2, 3, 4, 5, 6 };
    std::future<int> accumulate_future = std::async(std::launch::async, accumulate3, numbers.begin(), numbers.end()); //ver1
    std::future<int> accumulate_future = std::async(std::launch::deferred, accumulate3, numbers.begin(), numbers.end()); //ver2
    std::cout << "result=" << accumulate_future.get() << '\n';
    std::cout <<"main end" << std::endl;
    return 0;
}
```

```
ver1 输出：
main begin
main endasync begin
async end

result=21

ver2 输出：
main begin        
main end
result=async begin
async end
21
```

调用方式和thread很像，没什么区别。没有花里胡哨的东西。但是注意下细节。

1. 在async模式中，一旦开始了调用，则会立刻创建子线程开始任务执行。所以我们看到result=21是同步打印的。因为get的时候任务已经完成（或者是阻塞至任务完成）。
2. 在deferred模式中，只有get/wait调用的时候任务才开始执行。所以我们看到result=先打印出来，然后调用get函数，开始执行任务，任务执行完毕后结果才能拿到，打印21。
