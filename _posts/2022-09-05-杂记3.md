---
title: C++杂记 - 3
date: 2022-09-06 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true
  
---



# C++杂记 - 3

# std::bind, std::function 和 std::mem_fn

## std::bind 包括但不限于mem_fn的功能，更为通用的解决方案

**什么是bind？我们可以把它看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。**

std::bind将可调用对象与其参数一起进行绑定**，绑定后的结果可以使用std::function保存**。std::bind主要有以下两个作用：

- 将可调用对象和其参数绑定成一个仿函数；
- 只绑定部分参数，减少可调用对象传入的参数。

语法：

```c++
auto newCallable = bind(callable, arg_list);
```

该形式表达的意思是：当调用`newCallable`时，会调用`callable`，并传给它`arg_list`中的参数。

需要注意的是：`arg_list`中的参数可能包含形如`_n`的名字。其中`n`是一个整数，这些参数是占位符，表示`newCallable`的参数，它们占据了传递给`newCallable`的参数的位置。数值`n`表示生成的可调用对象中参数的位置：`_1`为`newCallable`的第一个**待填充**参数，`_2`为第二个**待填充**参数，以此类推。
注意这些占位符在`std::placeholders`名称空间内。

- **std::bind的返回值是可调用实体，可以直接赋给std::function**。
- **bind绑定类非静态成员函数时，第一个参数表示对象的成员函数的指针，第二个参数表示对象的地址，这是因为对象的成员函数需要有this指针**。并且编译器不会将对象的成员函数隐式转换成函数指针，需要通过&手动转换（符合成员函数指针的赋值语法）。静态成员函数无需此操作。因为没有this指针。
  - 在类内使用该类的成员函数的时候，和类外使用一样。都需要取地址并且传入对象指针。只不过可以使用`this`替代。


```c++
class my_class{
    public:
    int val;
    my_class(int x):val(x){}

    void getval(){
        cout << val << endl;
    }
    void add(int another){
        val = val + another;
        cout << val << endl;
    }
    static void staticfunc(int val){
        cout << "static" << val << endl;
    }
};
int main(){
    my_class obj1(10);
    auto task2 = bind(&my_class::getval, &obj1); 	//调用无参函数，this参数预绑定。成员函数指针遵循语法。
    auto task3 = bind(&my_class::add, &obj1, placeholders::_1);	//调用有参函数，this参数预绑定。
    auto task4 = bind(&my_class::add, placeholders::_1, placeholders::_2); //调用有参函数，this参数使用占位形式。
    auto task5 = bind(&my_class::staticfunc, placeholders::_1); //静态成员函数没有this指针。无需传入。
    task2();
    task3(3); 
    task4(&obj1, 3); //this使用占位形式，需要调用时传入。
    task5(3);
    return 0;
}
```



- **默认情况下，bind的那些不是占位符的参数会被拷贝（以值传递）到bind返回的可调用对象中。如果需要使用引用传递，必须使用`ref`**

```c++
void mypred(int a, int b, vector<int>& c){ 尽管这里函数头使用了引用，但是bind在预绑定的时候(也就是非placeholder参数）默认会拷贝一份原参数进行传入，也就是默认是值传递。所以这里的容器c其实是一个局部变量。
    if(a < b){
        cout <<"yes" << endl;
        c.push_back(a);
        
    }
}

int main(){
    vector<int> test = {1};
    vector<int> final;
    final.reserve(10);
    for_each(test.begin(), test.end(), bind(mypred, placeholders::_1, 3, ref(final))); 所以这里我们如果要使用引用来传递final，则必须要使用ref函数来获取其引用。
    for(auto i = final.begin(); i != final.end(); i++){
        cout << *i << endl;
    }
    return 0;
}
```



## 使用std::bind搭配priority_queue 和 vector的自定义排序。

请参考STL-1笔记







## mem_fn 成员函数适配器 把成员函数转为函数对象，使用对象指针或对象(引用)进行绑定

**个人实验得出的结论：`mem_fn`是`bind`的子集**。

注意`mem_fn`不能调用类静态成员函数。因为没有this指针。

`mem_fn`就是强制给你把类对象塞进去。

**`mem_fn`无法接受额外参数。也就是无法使用`placeholder`**

`mem_fn`的核心功能是把类成员函数转换成不需要类成员就可以调用的形式。就是把`this`指针绑定到类成员函数的隐藏`this`参数上。但是调用的时候依旧需要传入一个对象地址。。就很废物。

比较：

```c++
class my_class{
    public:
    int val;
    my_class(int x):val(x){}

    void getval(){
        cout << val << endl;
    }
    void add(int another){
        val = val + another;
        cout << val << endl;
    }
    static void staticfunc(int val){
        cout << "static" << val << endl;
    }
};
int main(){
    my_class obj1(10);

    auto task1 = mem_fn(&my_class::getval); 
    task1(&obj1); //把对象地址传入

    auto task2 = mem_fn(&my_class::add);
    task2(&obj1, 5);

    //auto task3 = mem_fn(&my_class::staticfunc); 错误！静态成员函数不行。

    auto task1_1 = bind(&my_class::getval, placeholders::_1); //bind就得多写个参数
    task1_1(&obj1);
    
    auto task1_2 = bind(&my_class::getval, &obj1);
    task1_2();

    return 0;
}
```






## std::placeholders

我们提到了，我们使用`bind`的时候，`placeholder`是待填充参数。什么叫待填充？这是一种具象解释。其实`bind`相当于生成了一个新的可调用对象，拥有两个参数。但是结合原本的可调用对象来看，我们有三个参数。所以站在原本的可调用对象角度来看，这原来的可调用对象中多出来的一个参数相当于已填充参数。剩下的两个参数相当于待填充。

语法和例子：

```c++
void testfunc(int x, int y, int z){
    cout << x << endl;
    cout << y << endl;
    cout << z << endl;
}
int main(){

    auto callable1 = bind(testfunc, placeholders::_1, placeholders::_2, 5);
    callable1(8,80);
    //输出8 80 5
    auto callable2 = bind(testfunc, placeholders::_2, placeholders::_1, 5);
    callable2(8,80);
    //输出80 8 5

    auto callable3 = bind(testfunc, placeholders::_1, 5, placeholders::_2);
    callable3(8,80);
    //输出8 5 80
    auto callable4 = bind(testfunc, placeholders::_1, 5, placeholders::_3); //错误。新的调用对象只有两个参数。这里3超了。并placeholders且必须按序。不可跨越。不能没有2的时候直接使用3，尽管可能待填充参数一共有3个。
    callable4(8,80);
    
    auto callable5 = bind(testfunc, placeholders::_1, 5, placeholders::_1); //极端情况。占位符可以重复。
    callable5(8);
    //输出8 5 8
}
```

**注意**

- `placeholder`编号必须按序。此处按序指的是不能没有`2`的时候直接使用`3`
- 并且编号不能大于待填充参数的数量。



参考资料：https://elloop.github.io/c++/2015-12-15/learning-using-stl-12-std-bind





## std::function

大家都用过函数指针。具体就不赘述了。稍微回忆一下函数指针的语法：

```c++
void(*another_a_ptr_ptr)(void) = (void(*)(void))*(long long*)(*a_ptr);
void(*another_a_ptr_ptr)(void); 这个函数指针的类型是void(*)(void)
```

成员函数指针的用法和声明在杂记2。

**std::function是一个可调用对象包装器，是一个类模板，可以容纳除所有可调用对象（类成员函数和指针需要bind一下），它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟它们的执行**。







一个例子让你知道`function`怎么用：

```c++
int myfunc(int a){
    cout << a << endl;
    return a;
}

int myfunc1(const int& a){
    cout << a << endl;
    return a;
}

int myfunc2(int&& a){
    cout << a << endl;
    return a;
}

int main(){
    function<int(int)> func = myfunc;
    func(4);

    function<int(const int&)> func1 = myfunc1;
    func1(4);

    function<int(int&&)> func2 = myfunc2;
    func1(4);

    return 0;
}

```

**说白了就是类型是你的函数返回值类型+参数类型。**

我们前面提到过 `bind`的返回值是可调用实体，可以直接赋给`std::function`

```c++
function<void(void)> task1_2 = bind(&my_class::getval, &obj1);
task1_2();

function<void(int)> task2 = bind(&my_class::add, &obj1, placeholders::_1);
task2(5);
```

**有一个问题是，这里必须要显式把对象地址直接塞进去，不能把对象地址用占位符。因为参数对不上了。（个人实验）**

**故而，std::function的作用可以归结于：**

- std::function对C++中各种可调用实体(普通函数、Lambda表达式、函数指针、以及其它函数对象等)的封装，形成一个新的可调用的std::function对象，简化调用；
- std::function对象是对C++中现有的可调用实体的一种类型安全的包裹(如：函数指针这类可调用实体，是类型不安全的)。







## 在函数中传递`std::function`对象，搭配`bind`并考虑使用`placeholders`。

为了方便起见。此处仅使用全局函数为例。

```c++
void test(int a, int b, const string& c){
    cout << a << b << c << endl;
}

void funcinput(function<void(int, int, const string&)> in_func){//注意函数入参签名
    in_func(1,2,"abc");
}

void another_funcinput(function<void(int, const string&)> in_func){ //注意函数入参签名
    in_func(2,"abc");
}
int main(){
    funcinput(bind(&test, placeholders::_1, placeholders::_2, placeholders::_3)); //输出12abc
    another_funcinput(bind(&test, 1, placeholders::_1, placeholders::_2));//输出ab123
    return 0;

}
```

我们打算将`std::function`对象传入函数。

注意在搭配`bind`使用的时候。注意`function`的类型。[下方例子全部忽略第一个实际参数（为函数地址）]。<u>**`function`的类型为函数返回类型+除预先绑定的参数以外的全部参数类型（所有`placeholders`代表的类型）。**</u>

- 在`bind(&test, placeholders::_1, placeholders::_2, placeholders::_3)`的时候，由于三个参数全部为`placeholders`，所以此时`function`的类型为目标函数的返回值类型+全部参数类型。为`function<void(int, int, const string&)> `。
- 在`(bind(&test, 1, placeholders::_1, placeholders::_2)`的时候，由于第一个参数为预绑定，只有两个`placeholders`，所以此时`function`的类型为目标函数的返回值类型+除第一个外，也就是剩余的参数类型。为`function<void(int, const string&)>`











# std::call_once 和 std::once_flag

通过`call_in_once`执行的可调用对象可以保证在多线程的状态下仅被（一个线程）执行一次

```c++
once_flag my_flag1; //这个flag是一次性使用的。必须要全局。而且如果有两个东西需要call_once就要两个flag
once_flag my_flag2;
void func1(){
    cout <<"func1" << endl;
}

void func2(int s){
    cout <<"func2" << s << endl;
}
void thread_exe(){
    //once_flag my_flag1; //错误 放在这里就是线程函数的局部变量。这样每个线程就会有自己的flag
    //once_flag my_flag2;
    call_once(my_flag1, func1);
    call_once(my_flag2, func2, 1);
}

int main(){
    thread mythread1(thread_exe);
    thread mythread2(thread_exe);
    mythread1.join();
    mythread2.join();

    return 0;
}
```

注意事项：

- `once_flag`对象对于所有线程来说应该是全局变量（或等同于全局变量的形式）。因为`once_flag`对象只能被使用一次。如果是局部变量，则放在这里就是线程函数的局部变量。这样每个线程就会有自己的`once_flag`对象，就无法起作用。
- 因为每一个`once_flag`对象是一次性的。所以如果有两个东西需要call_once就要两个`once_flag`对象
- 如果某个线程抛出异常，则`call_once`会选择下一个等候的线程重新执行`call_once`动作。

参考：https://blog.csdn.net/qq_31175231/article/details/77916028

https://blog.csdn.net/XJF199001/article/details/51435845

# 异步API。std::future, std::promise, std::packaged_task, std::async

想要进行多线程编程，这四个看起来高级的API是必不可少的。我们来看一看这一套异步编程套组里的四个组件到底有什么关系，他们是干什么的。

参考资料：https://segmentfault.com/a/1190000039201271

https://murphypei.github.io/blog/2019/04/cpp-concurrent-4

## std::future / std::shared_future

< future >头文件功能允许对特定提供者设置的值进行异步访问，可能在不同的线程中。
这些**提供程序**(要么是`promise` 对象，要么是`packaged_task`对象，或者是对异步的调用`async`)与`future`对象共享共享状态:提供者使共享状态就绪的点与`future`对象访问共享状态的点同步。

上面这段话翻译过来就是我们可以理解为future是一个时间胶囊, 一个对象**。这个对象的提供程序（如promise)里面储存了我们希望以后拿到的东西。然后我们用future来和提供程序连接起来，拿到提供程序里面的东西。**

我们看一下future的正式定义和具体细节。

- future 是一个对象，**可以从某个提供对象或函数中检索值**，如果在不同线程中，则可以正确同步此访问。
- 它提供了一种访问异步操作结果的机制。从字面意思上看它表示未来，这个意思就非常贴切，因为它不是立即获取结果但是可以在某个时候以同步的方式来获取结果。我们可以通过查询`future`的状态来获取异步操作的结果。`future_status`有三种状态：
  - `deferred`：异步操作还未开始。共享状态包含一个延迟函数，因此只有在明确请求时才会计算结果。（主要用于`async`函数的`std::launch::deferred`参数。)
  - `ready`：异步操作已经完成
  - `timeout`：异步操作超时。在指定的超时持续时间过去之前，共享状态尚未准备好
- “有效” future 对象，只能通过调用以下函数之一来构造：
  - `async` 
  - `promise::get_future`
  - `packaged_task::get_future`
- 默认构造的 future 对象是无效的（除非移动（move）分配一个有效的 future）。
- 在有效的 future 上调用 `future::get` 会阻塞线程，直到提供程序准备好共享状态（通过设置值或异常）。这样，两个线程可以通过一个线程同步，等待另一个线程设置值。
  - **`get()` 调用会改变其共享状态，不再可用，也就是说 `get()` 只能被调用一次，多次调用会触发异常。如果想要在多个线程中多次获取产出值需要使用 `shared_future`。**
- 共享状态的生存期至少要持续到与之关联的最后一个对象释放它或销毁它为止。因此，如果与 future 相关联，共享状态可以在最初获得它的对象（如果有的话）之后继续存在。

![20190506204825200](/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/20190506204825200.png)



几个函数详解：

### future::valid()

#### 检查有效的共享状态

- 返回 future 对象当前是否与共享状态关联。
- 对于默认构造的 future 对象，此函数返回 false (除非将有效的 future 分配给移动对象)。
- future 只能由某些提供函数（如， async, promise::get_future 或 packaged_task::get_future）使用有效的共享状态进行初始化。
- 一旦使用 future::get 检索了共享状态的值，则调用此函数返回 false (除非移动分配了一个新的 future).

#### 返回值

- 如果对象与共享状态关联，则为 ture。
- 否则为假。

**特别注意。返回值为true不代表此时共享状态已经就绪。只能表明对象与共享状态关联。**

### future::wait

#### 阻塞并等待共享状态就绪（结果可用）



### future::get

可以理解为包含了wait的操作。因为他调用了wait。（猜测）

#### 阻塞并等待共享状态就绪（结果可用），返回存储在共享状态中的值（或引发其异常）

- 当共享状态就绪时，返回存储在共享状态中的值（或引发其异常）。
- **如果共享状态尚未准备好（即提供程序尚未设置其值或异常），则该函数将阻塞调用线程直到准备就绪。在此前，调用了get的函数不会返回。**
- 共享状态就绪后，该函数将取消阻塞并返回（或引发异常）以释放其共享状态。**这时 future 对象不再有效**：**对于每个 future 的共享状态，此成员函数最多应被调用一次**。
- 提供者准备好共享状态和返回此函数之间是同步的。



### shared_future

`std::shared_future` 与 `std::future` 类似，但是 `std::shared_future` 可以拷贝、多个 `std::shared_future` 可以共享某个共享状态的最终结果(即共享状态的某个值或者异常)。**`shared_future` 可以通过某个 `std::future` 对象隐式转换（参见 `std::shared_future` 的构造函数），或者通过 `std::future::share()` 显示转换，无论哪种转换，被转换的那个 std::future 对象都会变为 not-valid**。`std::shared_future` 的成员函数和 `std::future` 大部分相同，这个地方就不一一展开了，需要的请查阅官方文档。



我们可以看到，想要创建一个有效的future对象必须依靠剩下的三个API。我们就来进一步看看剩下的几块内容。

## std::promise

promise是剩下三个当中最为“原始，底层“的API。

**`promise` 本质是一个类似我们打印输出中占位符的东西，你可以理解它就是一个等待数据装填的坑，它是一个“承诺”，承诺未来会有相应的数据（模板实现）**。因为这是一个“承诺”，所以创建的时候是没有东西的，所以我们需要知道这个异步操作什么时候能有东西，好实现“承诺”，所以 `promise` 可以通过调用 `get_future()` 返回一个 `future` 对象，让你去了解这个承诺是否完成了。因此，`promise` 是存放异步操作产出值的坑，而 `future` 是从其中获取异步操作结果，二者都是模板类型。

**这里理解为我们的future对象是一个接口，建立起与promise对象的联系。我们使用promise对象来进行异步操作，所以能看到我们并不需要把future对象传入线程。但是我们会通过future对象去获知这个异步操作的结果是否就绪，也就是promise对象是否已经包含了我们期望的结果。然后我们可以通过future来获取结果。**

- `promise` 是一个对象，由 `future` 对象（可能在另一个线程中）检索，并提供一个同步点。
- 通过调用成员get_future，可以将该共享状态与 future 对象关联。 调用之后，两个对象共享相同的共享状态：
  - promise对象是异步提供程序，应在某个时候为共享状态设置一个值。`set_value`
  - future 对象是一个异步返回对象，可以检索共享状态的值，并在必要时等待其准备就绪。
  - 理解为我们通过promise的get_future来创建我们的future对象。之后通过future对象（来检索）获得一个共享状态（结果）。

![20190506203234388](/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/20190506203234388.png)



### promise::set_value

- **以原子方式**将值存储到共享状态（就是把promise对象储存的值设置好），**并且改变该状态变为就绪状态**。（设置共享状态）
- 如果与同一共享状态关联的future对象当前正在等待对`future::get`的调用，则它将取消阻塞并返回val。
  - 因为future的get/wait会阻塞等待共享状态被设置完毕。



看看简单代码例子：

```c++
//使用promise进行异步
void accumulate2(std::vector<int>::iterator first, //注意不太需要返回值了。因为异步返回的值被储存在了promise对象中
                std::vector<int>::iterator last,
                std::promise<int> accumulate_promise) //函数头要有promise对象定义。
{
    int sum = std::accumulate(first, last, 0);
    accumulate_promise.set_value(sum);  // 将结果存入，并让共享状态变为就绪以提醒future
    //如果不set_value,那么调用了future::get/wait的线程将一直被阻塞。
}
 
int main()
{
    // 演示用 promise<int> 在线程间传递结果。
    std::vector<int> numbers = { 1, 2, 3, 4, 5, 6 };
    std::promise<int> accumulate_promise; //声明promise对象
    std::future<int> accumulate_future(accumulate_promise.get_future()); //通过promise对象的get_future来初始化(获取）future对象
    
    std::thread work_thread(accumulate2, numbers.begin(), numbers.end(),
                            std::move(accumulate_promise)); //启动线程。设置好执行函数和传入参数。注意必须要把promise对象一并传入（移入）
    //!这里也可以用ref。但是我们accumulate2的函数头要了个值。promise又禁用了拷贝构造所以这里目前只可以move。如果accumulate2函数头改为&就可以用ref
    // !可以用ref但是不推荐。因为如果你不转移所有权，万一你多个线程并发访问了promise，可能会有问题，
    !而且这也不符合设计，一般来说只应该让一个线程持有promise
    //accumulate_future.wait();  //等待结果 这个可以去掉，直接用get就可以
    
    std::cout << "result=" << accumulate_future.get() << '\n'; //get阻塞住等待共享对象变为ready。然后获取结果。
    work_thread.join();  //阻塞等待线程执行完成
 
    getchar();
    return 0;
}
```



## std::packaged_task

packaged_task比promise高级一点。直观来看就是参数少一点，操作少一点。稍后我们会有一个简单的对比。

`packaged_task` 是对一个任务的抽象，我们可以给其传递一个函数来完成其构造。相较于 `promise`，它应该算是更高层次的一个抽象，同样地，我们可以将任务投递给任何线程去完成，然后通过 `packaged_task::get_future()` 方法获取的 `future` 对象来获取任务完成后的产出值。总结来说，**`packaged_task` 是连数据操作（比如set_value)都封装进去了的 `promise`**。`packaged_task` 也是一个类模板，模板参数为函数签名，也就是传递函数的类型。

```c++
template <class T> packaged_task;     // undefined
template <class Ret, class... Args> class packaged_task<Ret(Args...)>;
```

- **std::packaged_task包装可调用对象，并允许异步检索其结果。**（可调用对象是重点）
- 类似于 std::function, 但是会自动将其结果传输到 future 对象。
- 对象内部包含两个元素：
  - 存储的任务是一些可调用对象（例如，函数指针，成员或函数对象的指针），其调用签名应采用 Args... 中类型的参数，并返回 Ret 类型的值。
  - 共享状态，该状态能够存储调用存储的任务（类型为 Ret）的结果，并且可以通过 future 来异步访问。
- 通过调用成员 get_future 将共享状态与 future 对象关联。调用之后，两个对象共享相同的共享状态：
  - packaged_task 对象是异步提供程序，通过调用存储的任务，可以在某个时刻将共享状态设置为就绪。
  - future 对象是一个异步返回对象，可以检索共享状态的值，并在必要时等待其准备就绪。

![2019050621124831](/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/2019050621124831.png)

看看代码实例，做一下比较：

```c++
//? 使用packaged_task进行异步
int accumulate(std::vector<int>::iterator first,
                std::vector<int>::iterator last) //注意函数头，我们没有像promise那样需要传入promise对象。
{
    int sum = std::accumulate(first, last, 0);
    return sum;  //所以也不需要promise的set_value
}
 
int main()
{
    // 演示用 packaged_task 在线程间传递结果。
    std::vector<int> numbers = { 1, 2, 3, 4, 5, 6 };
    std::packaged_task<int(std::vector<int>::iterator,std::vector<int>::iterator)> accumulate_task(accumulate);
    //创建packaged_task对象。注意这里有区别，下面详说。
    std::future<int> accumulate_future = accumulate_task.get_future(); //通过packaged_task对象的get_future来创建future对象
    std::thread work_thread(std::move(accumulate_task), numbers.begin(), numbers.end()); //启动线程。注意这里有区别了。
    /*
    @ 使用move的主要原因还有一个就是按值传递函数参数会调用拷贝构造。packaged_task禁用了拷贝构造，要么传引用要么换成右值引用转移所有权。
    */
    //accumulate_future.wait();  //等待结果 可以和下面的get合并
    std::cout << "result=" << accumulate_future.get() << '\n';
    work_thread.join();  //阻塞等待线程执行完成
 
    getchar();
    return 0;
}

```

**我们来说一说几点具体区别**

- 我们提到了，packaged_task包装的是可调用对象。但是promise仅仅是一个包装着异步执行结果的对象。所以：
  - packaged_task对象的模板类型是函数签名，因为他包装了可调用对象。
  - 所以线程执行的时候只需要移入packaged_task对象即可，无需传入函数本身。因为已经被包装了。
  - 所以包装的函数无需额外参数，函数内无需额外动作。
  - 因为promise会储存异步任务的结果，所以函数的返回值可以去掉。
- 其实理解了上面那一点，就理解了packaged_task和promise的区别。可以简单理解为promise是一个包装了执行结果的对象。而packaged_task是一个包装了整个任务的对象，它不仅包装任务执行结果，而且包装任务本身。





## std::async

async是最高级的一个API，代码简单，比较高层。它其实封装了其实是封装了thread 和 packged_task的功能，使异步执行一个任务更为方便

**async是函数，不是类模板。**

```c++
unspecified policy (1)    
template <class Fn, class... Args>
  future<typename result_of<Fn(Args...)>::type>
    async (Fn&& fn, Args&&... args);

specific policy (2)    
template <class Fn, class... Args>
  future<typename result_of<Fn(Args...)>::type>
    async (launch policy, Fn&& fn, Args&&... args);
```

- 异步调用函数在某个时刻调用 fn (以 args 作为参数)，返回时无需等待 fn 执行完成。(都说了是异步)
- **可以通过返回的 future 对象（通过调用其成员 future::get）来访问 fn 返回的值。**
- 第二个版本 （2） 允许调用者选择特定的启动策略，而第一个版本 （1） 使用自动选择，就好像调用 (2) 并将 launch::aysnc | launch::deferred 作为策略。
- 该函数在共享状态下临时存储使用的线程处理程序。一旦完成 fn 的执行，共享状态将包含 fn 返回的值并准备就绪。

| launch::async                     | 启动一个新的线程以调用 fn （就像使用 fn 和 args 作为参数构造线程对象，并访问返回的 future 的共享状态将其联接）`std::thread(std::forward<F>(f), std::forward<Args>(args)...)` |
| --------------------------------- | ------------------------------------------------------------ |
| launch::deferred                  | 意味着函数可能只会在std::async返回的future对象**调用get或wait时执行**。（函数在future对象调用了get或wait的时候才会开始执行）。**不会产出新的线程。该任务会在调用线程中执行。**当调用get或wait时，函数会同步执行，即调用者会阻塞直到函数运行结束。**如果get或wait没有被调用，函数就绝对不会执行**。 |
| launch::async \| launch::deferred | 该功能自动（在某个时候）选择策略。这取决于系统和库的实现，他们通常会针对系统中当前的并发可用性进行优化 |

看一下细节

```c++
//? 使用async进行异步

int accumulate3(std::vector<int>::iterator first, std::vector<int>::iterator last){
    std::cout <<"async begin" << std::endl;
    int sum = std::accumulate(first, last, 0);
    std::cout <<"async end" << std::endl;
    return sum;
}

int main(){
    std::cout <<"main begin" << std::endl;
    std::vector<int> numbers = { 1, 2, 3, 4, 5, 6 };
    std::future<int> accumulate_future = std::async(std::launch::async, accumulate3, numbers.begin(), numbers.end()); //ver1
    std::future<int> accumulate_future = std::async(std::launch::deferred, accumulate3, numbers.begin(), numbers.end()); //ver2
    Sleep(50); //睡眠五秒
    std::cout << "result=" << accumulate_future.get() << '\n';
    std::cout <<"main end" << std::endl;
    return 0;
}
```

```
ver1 输出：
main begin
async begin
async end
result=21
main end

ver2 输出：
main begin
result=async begin
async end
21
main end
```

调用方式和thread很像，没什么区别。没有花里胡哨的东西。但是注意下细节。

1. 在async模式中，一旦开始了调用，则会立刻创建子线程开始任务执行。所以我们看到尽管主线程睡眠了一下，但是并不影响异步线程的执行。所以async begin， async end和result=21是可以打印的。因为get的时候任务已经完成（或者是阻塞至任务完成）。
2. 在deferred模式中，只有get/wait调用的时候任务才开始执行。所以result=先打印出来，然后直到调用get函数的时候，才开始执行任务，任务执行完毕后结果才能拿到，所以会先打印result=, 然后在调用线程（此处是主线程）中执行函数，拿到结果后打印21。



- **传参的时候如果需要使用只支持移动的参数比如unique_ptr，则必须使用move显式移动。**

```c++
unique_ptr<int> testfunc(unique_ptr<int> ptr){
    *ptr = *ptr + 1;
    return ptr;
}

int main(){
    unique_ptr<int> myptr = make_unique<int> (5);
    future<unique_ptr<int>> my_future = async(std::launch::async, testfunc, move(myptr)); //显示使用move转移所有权。
    cout << *(my_future.get()) << endl;
    return 0;
}
```



- **如果async函数的返回值没有一个东西接住他（显式获取返回值），因为async会创建临时的future对象, 所以这个临时对象的析构函数会阻塞住调用线程直至异步线程执行完毕。因为我们不能让异步线程返回值的时候，这个临时对象已经被销毁了。**

例子：

```c++
unique_ptr<int>  testfunc(unique_ptr<int> ptr){
    *ptr = *ptr + 1;
	sleep(5); //睡眠五秒
    return ptr;
}

int main(){
    unique_ptr<int> myptr = make_unique<int> (5);
	cout << "running" << endl;
    async(std::launch::async, testfunc, move(myptr)); //卡在这里5秒。因为没有获取返回值。直到任务完成后赋值给临时future对象之后才能执行future临时对象的析构。
    cout <<"blocked" << endl;
    return 0;
}
```

这段代码执行的时候，调用线程会由于异步线程没有执行完毕，而且因为没有获取返回值，所以卡在async这行。直到异步线程执行完毕后赋值给临时future对象之后才能执行future临时对象的析构。才会继续输出blocked。





- **如果async函数的返回值有`future`对象接住他（显式获取返回值），而且没有对`future`对象用使用`get`来阻塞主线程，因为满足下面的条件，所以主线程依旧会等待异步线程结束。因为该`future`对象的析构函数被阻塞了**
  - 注意：此条件仅限于如下条件为真：
    - `future`对象以 `std::async` 的调用创建，且**共享状态仍未就绪**，且` this` 是到共享状态的最后引用。
      - 最后面那个条件原文是：this was the last reference to the shared state. 我的理解其实是：这个`future`对象是`async`调用创建的那个对象的最后的引用。
        - 也就是如果当前的`future`对象此时是`async`调用创建的那个`future`对象，唯一与其有关联的实例。

```c++
int accumulate3(std::vector<int>::iterator first, std::vector<int>::iterator last){
    std::cout <<"async begin" << std::endl;
    int sum = std::accumulate(first, last, 0);
    sleep(5); //异步线程睡眠5秒
    std::cout <<"async end" << std::endl;
    return sum;
}


int exe(){
    std::cout <<"exe begin" << std::endl;
    std::vector<int> numbers = { 1, 2, 3, 4, 5, 6 };
    std::future<int> accumulate_future = std::async(std::launch::async, accumulate3, numbers.begin(), numbers.end()); //通过async调用创建的future对象，且共享状态仍未就绪，且除了这个future对象以外，没有其他的对共享状态的引用。所以会阻塞。
    //std::cout << "result=" << accumulate_future.get() << '\n'; 没有对`future`对象用使用`get`来阻塞主线程
    std::cout <<"exe end" << std::endl;
    return 200;
}

int main(){
    int a = exe();
    cout << a << endl;
    return 0;
}
/*
输出：
exe begin
exe end
async begin
(睡眠五秒...)
async end
200
*/
```

我们可以看到，启用了异步线程，并且有`future`对象做为返回值，所以没有阻碍临时对象的析构。同时我们没有对`future`对象用使用`get`来阻塞主线程。但是**虽然exe end被打印，但是因为满足上面的条件，所以该`future`对象的析构函数被阻塞了，这个调用线程依旧会被阻塞。所以这个函数的执行没有结束，所以`main`函数内的函数调用不会返回。所以调用线程依旧会等待异步线程结束而结束。**



## future, packaged_tast, promise三者的关系

std::future用于访问异步操作的结果，而std::promise和std::packaged_task包住了future，它们内部都有一个future，promise包装的是一个值，packaged_task包装的是一个函数，当需要获取线程中的某个值，可以使用std::promise，当需要获取线程函数返回值，可以使用std::packaged_task。

## 杂项

- std::future提供访问异步操作结果的机制。std::future 只能与指定事件相关联，而 std::shared_future 就能关联多个事件。future对象本身并不提供同步访问（需要使用get/wait)。future的get()函数的设计包含移动语义，即只能调用一次，第二次调用时会报异常。shared_future的get()函数的设计包含复制语义，可以多次调用。std::shared_future对象可以通过std::future对象隐式转换，也可以通过显示调用std::future::share显示转换，在这两种情况下，原std::future对象都将变得无效。
- 当不着急让任务结果时，可以使用 std::async 启动一个异步任务。std::async 会返回一个 std::future 对象。get()等价与先调用wait()再调用get()。 std::launch::defered 表明函数调用延迟到wait()或get()函数调用时才执行，std::launch::async 表明函数必须在其所在的独立线程上执行。
- std::packaged_task<> 会将future与函数或可调用对象进行绑定。当 std::packaged_task 作为函数调用时，实参将由函数调用操作符传递至底层函数，并且返回值作为异步结果存储在 std::future 中。
- std::promise/std::future 对提供一种机制：future可以阻塞等待线程，提供数据的线程可以使用promise对相关值进行设置，并将future的状态置为“就绪”。
- 任何情况下，当future的状态还不是“就绪”时，调用 std::promise 或 std::packaged_task 的析构函数，将会存储一个与 std::future_errc::broken_promise 错误状态相关的 std::future_error 异常。
  - 当调用抛出一个异常时，这个异常就会存储到future中，之后调用get()会抛出已存储的异常。
  - std::current_exception() 来检索抛出的异常，可用 std::copy_exception() 作为替代方案， std::copy_exception() 会直接存储新的异常而不抛出。
- 因为 std::future 是只移动的，所以其所有权可以在不同的实例中互相传递，但只有一个实例可以获得特定的同步结果，而 std::shared_future 实例是可拷贝的，所以多个对象可以引用同一关联期望值的结果。
- 当多线程 在没有额外同步的情况下，访问一个独立的 std::future 对象时，就会有数据竞争和未定义的 行为。这是因为： std::future 模型独享同步结果的所有权，并且通过调用get()函数，一次性 的获取数据，这就让并发访问变的毫无意义——只有一个线程可以获取结果值，因为在第一 次调用get()后，就没有值可以再获取了。 
- 在每一个 std::shared_future 的独立对象上成员函数调用返回的结果还是不同步的，所以为 了在多个线程访问一个独立对象时，避免数据竞争，可以使用两种方式：
  - 锁
  - 每一个线程有自己的shared_future对象，然后都通过自己的这个shared_future对象来获取结果。



# atomic , fence 和 内存模型 和 无锁编程

https://youtu.be/ZQFzMfHIxng

## 无锁编程不一定会让程序更快，甚至会有副作用。它并不具有加速行为。

无锁编程不保证性能，不保证程序更快。

## 打算使用无锁编程提升性能之前，先检查其他部分，比如算法。

## std::atomic_flag

`std::atomic_flag` 是原子布尔类型。不同于所有 std::atomic 的特化，**它保证是免锁的**。不同于 `std::atomic<bool>` ， `std::atomic_flag` 不提供加载或存储操作。

`std::atomic_flag`是最简单的原子类型，这个类型的对象可以在两个状态间切换：

- 设置

- 清除



### 默认构造函数

构造一个新`std::atomic_flag`对象，不过未指明状态。这里未指定默认构造出来的`std::atomic_flag`实例是`clear`状态，还是`set`状态（c++20后默认构造函数初始化的状态为clear）。因为对象存储过程是静态的，所以初始化必须是静态的。**`std::atomic_flag` 必须使用`ATOMIC_FLAG_INIT`进行初始化**，这样构造出来的实例状态为`clear`。**另外，`atomic_flag`不能被拷贝，也不能 `move`**

### std::atomic_flag::test_and_set

原子地更改 `std::atomic_flag`的状态为设置（ true ）并返回它先前保有的值。

### std::atomic_flag::clear

原子地更改 `std::atomic_flag`的状态为清除（ false ）。

### std::atomic_flag::wait/notify_one/notify_all

C++20内容

## std::atomic

`std::atomic`模板的每个实例化和专门化都定义了一个原子类型。如果一个线程在另一个线程读取它时写入一个原子对象，那么行为就会被明确定义(参见关于数据竞争的详细信息的内存模型)。此外，对原子对象的访问可以建立线程间的同步，并按照`std::memoryorder`指定非原子性的内存访问。

- `std::atomic`可以用任何简单的可复制的t实例化。同时std::atomic是不可复制的，是不可移动的。

- 注意初始化方式只能使用直接初始化。因为拷贝赋值和拷贝构造被禁用。**这个初始化方式非原子**。

  - **c++17后可以使用拷贝初始化。强制使用了复制省略技术。前提是右侧必须是prvalue临时对象**
  - `atomic`不可以使用聚合初始化（aggregate initialization）

  ```c++
  atomic<int> a = 5; //c++14错误, c++17 OK
  atomic<int> a(5);
  ```

- 具体特化类型参考https://zh.cppreference.com/w/cpp/atomic/atomic

- 特化成员函数操作，操作符重载加减之类的不讲了。

- **注意原子操作没有乘法和除法**

- 注意带有赋值操作符的时候不能保证整条语句的原子性。
 ```c++
  atomic<int> a(5);
  a = a + 5; //只保证原子读 + 原子写。不能保证原子读+写
 ```

- c++20前，浮点类型不支持自增操作。

- 主 `std::atomic` 模板可用任何满足[*可复制构造* *(CopyConstructible)* ](https://zh.cppreference.com/w/cpp/named_req/CopyConstructible)及[*可复制赋值* *(CopyAssignable)* ](https://zh.cppreference.com/w/cpp/named_req/CopyAssignable)的[*可平凡复制* *(TriviallyCopyable)* ](https://zh.cppreference.com/w/cpp/named_req/TriviallyCopyable)类型 `T` 特化。若下列任何值为 `false` 则程序为非良构：

  - [std::is_trivially_copyable](http://zh.cppreference.com/w/cpp/types/is_trivially_copyable)<T>::value

  - [std::is_copy_constructible](http://zh.cppreference.com/w/cpp/types/is_copy_constructible)<T>::value

  - [std::is_move_constructible](http://zh.cppreference.com/w/cpp/types/is_move_constructible)<T>::value

  - [std::is_copy_assignable](http://zh.cppreference.com/w/cpp/types/is_copy_assignable)<T>::value

  - [std::is_move_assignable](http://zh.cppreference.com/w/cpp/types/is_move_assignable)<T>::value

###  std::atomic<T>::store

```c++
void store( T desired, std::memory_order order = std::memory_order_seq_cst ) noexcept;
```

**原子地**以 `val` 替换当前值。按照 `order` 的值影响内存。`order` 必须是 `std::memory_order_relaxed` 、 `std::memory_order_release` 或 `std::memory_order_seq_cs`t 之一。否则行为未定义。

### std::atomic<T>::load

```c++
T load( std::memory_order order = std::memory_order_seq_cst ) const noexcept;
```

原子地加载并返回原子变量的当前值。按照 `order` 的值影响内存。

`order` 必须是 `std::memory_order_relaxed`、 `std::memory_order_consume` 、 `std::memory_order_acquire` 或 `std::memory_order_seq_cst` 之一。否则行为未定义。

### std::atomic<T>::operator=

等于`store() `注意用法。

```c++
atomic<int> a;
a = 3;
```

**这个等号不是拷贝赋值的那个等号。**

### std::atomic<T>::operator T

等于`load()`

### std::atomic<T>::exchange

```c++
T exchange( T desired, std::memory_order order = std::memory_order_seq_cst )
```

原子地以 `desired` 替换底层值。操作为读-修改-写操作。根据 `order` 的值影响内存。

返回调用前原子对象的值。

### std::atomic<T>::wait/notify_one/notify_all

C++20内容

## 内存模型

### Happens-Before 关系

> A、B 是两个在多核 CPU 上执行的操作。如果 A **happens-before** B，那么 A 所产生的内存变化会在 B 操作执行之前被看到（visible）。

不管我们使用什么编程语言，在同一个线程下的顺序语句总是遵循 happens-before 原则的。

就像下面代码所示：

```cpp
int a, b;

void foo() {
    a = 42;
    b = a;

    assert(b == 42);
}
```

在单线程的情况下，断言是永远不会 为假的。（不然这还怎么写程序...）

但这并不代表 b 在内存中后于 a 被修改。就像下面这段伪代码所示的：

```text
mov 42, %eax
mov %eax, (b)
mov %eax, (a)
```

虽然这并不能说明编译器就是这么处理的，但足以说明程序语义上的 happens-before 不能代表操作是真的 happened before 了。

### Synchronizes-With 关系

这个术语简单来说就是描述了一种方法，能让内存的变化（即便是非原子操作）保证被其他线程看到，这也是实现 **lock-free** 编程模式的基础。

用一段代码来举例：

```cpp
int data;
std::atomic_bool flag { false };

// Execute in thread A
void producer() {
    data = 42;  // (1)
    flag.store(true);  // (2)
}

// Execute in thread B
void consume() {
    while (!flag.load());  // (3)
    assert(data == 42);  // (4)
}
```

让两个函数分别在两个线程中运行，(4) 所示的断言将有一定几率 为假，这是为什么呢？虽然我们使用原子量 flag 作为“同步信号”，而且同一个线程中 happens-before 原则也一定会被遵循，但我们并不能保证 (4) 执行时 (1) 的修改一定会被 B 线程看到, 可能是2-3-4-1这个顺序。这**是由于现代处理器对于程序可能会采取指令重排来提高运行效率，CPU 的读写 Cache 也可能并没有写回内存。**

所以，企图在多线程环境中通过某原子量来做非原子量的 Synchronization 并不是可靠的（当没有 Memory Order 的约束）。

当然，上面的代码在你的机器上可能也不会 为假，因为 C++ 默认使用 **memory_order_seq_cst**顺序约束。而且 x86 架构中也做不到松弛（**memory_order_relaxed**）内存模型。





## 三种模型和六种枚举值

### 顺序一致（sequentially consistent ordering）

- `memory_order_seq_cst`
  - Load/store/RMW操作都可以使用该枚举值，用于 `load operation`（原子读操作）的时候有`acquire operation`的特性，用于` store operation`(原子写操作）的时候有`release operation`的特性, 用于 `read-modify-write operation`（RMW）的时候有`acq_rel operation`的特性，且所有操作都相当于一个双向屏障，**前后语句都不能跨越该操作进行重排**。并且所有线程的语句都以全局的内存修改顺序为参照。


### 获取发布 （release-acquire/consume ordering）

- `memory_order_consume`
  - 类似于`memory_order_acquire`，也是用于`load`操作，但更为宽松。针对于该`load`操作，不允许`load`之后的**有关联（依赖）的**操作重排到`load`之前。

  - `memory_order_consume`适用于`load operation`（原子读操作），对于采用此内存序的`load operation`，我们可以称为`consume operation`(consume原子读操作），设有一个原子变量M上的`consume operation`(consume原子读操作），对周围内存序的影响是：
    - 当前线程中该`consume operation`(consume原子读操作）后的**依赖**该`consume operation`(consume原子读操作）读取的值的写入或读取操作不能被重排到该`consume operation`(consume原子读操作）前，其他线程中所有对M的`release operation`（原子写操作）及其之前的对数据依赖变量的写入都对当前线程从该`consume operation`(consume原子读操作）开始往后的操作可见

    - 相比较于下面讲的`memory_order_acquire`，`memory_order_consume`只是阻止了之后有依赖关系的重排。绝大部分平台上，这个内存序只会影响到编译器优化，依赖于dependency chain。但实际上很多编译器都没有正确地实现consume，导致等同于acquire。

    - 见下图，只有`int r2 = x->i` 是有效的，因为其读取的值依赖原子变量`p`，但`int r1 = A`并不能读到线程1写入到`A`的值，因为`A`值并不依赖`p`。

- `memory_order_acquire`
  - 针对于该`load`操作，不允许`load`之后的操作重排到`load`之前。
  - `memory_order_acquire`适用于`load operation`（原子读操作），对于采用此内存序的`load operation`（原子读操作），我们可以称为`acquire operation`，设有一个原子变量M上的`acquire operation`（原子读操作），对周围内存序的影响是：
    - 当前线程中该`acquire operation`（原子读操作）后的任何内存读写操作都不能被重排到该`acquire operation`（原子读操作）前。
    - 结合下面的`memory_order_release`我们能推导出从而会有其他线程中所有对M的`release operation`（原子写操作）及其之前的写入都对当前线程从该`acquire operation`（原子读操作）开始往后的操作可见。
    - 见下图。线程1写入操作之前的所有操作对于线程2读取后的所有操作可见。


- `memory_order_release`

  - 针对于该`store`操作，不允许`store`之前的操作重排到`store`之后。

    - `memory_order_release`适用于`store operation`（原子写操作），对于采用此内存序的写入操作，我们可以称为`release operation`，设有一个原子变量M上的`release operation`(写入操作），对周围内存序的影响是：

      - 该`release operation`(写入操作）前的内存读写都不能重排到该`release operation`(写入操作）之后。(该`store`操作，不允许`store`之前的操作重排到`store`之后。)结合`memory_order_acquire`的左右从而有：

        - 当前线程截止到该`release operation`（原子写操作）的所有内存写入都对另外线程对M的`acquire operation`（原子读操作）以及之后的内存操作可见，这就是`release acquire` 语义。
        - 当前线程截止到该operation的所有M所依赖的内存写入都对另外线程对M的`consume operation`以及之后的内存操作可见，这就是`release consume`语义。

- `memory_order_acq_rel`

  - 用于RMW(read-modify-write)原子操作，RMW操作前后的语句都不允许跨越该操作而重排。该操作相当于兼具load(acquire)和store(release)，可以看作由这两个操作组成，但是整体上是原子的。
  - `memory_order_acq_rel`适用于`read-modify-write operation`(RMW操作)，对于采用此内存序的`read-modify-write operation`，我们可以称为`acq_rel operation`，既属于`acquire operation` 也是`release operation`. 设有一个原子变量M上的`acq_rel operation`：自然的，因为同时具有两种属性，所以该`acq_rel operation`之前的内存读写都不能重排到该`acq_rel operation`之后，该`acq_rel operation`之后的内存读写都不能重排到该`acq_rel operation`之前. 其他线程中所有对M的`release operation`(写入操作）及其之前的写入都对当前线程从该`acq_rel operation`开始的操作可见，并且截止到该`acq_rel operation`的所有内存写入都对另外线程对M的`acquire operation`（原子读操作）以及之后的内存操作可见。

### 宽松（relaxed ordering ）

- `memory_order_relaxed`
  - 对于其它读写操作没有任何同步和重排的限制，仅要求保证读写的原子性和内存一致性。除此之外，不提供任何跨线程的同步。
  - 一般应用于计数器场景

```c++
// Thread 1:
r1 = y.load(std::memory_order_relaxed); // A
x.store(r1, std::memory_order_relaxed); // B
// Thread 2:
r2 = x.load(std::memory_order_relaxed); // C 
y.store(42, std::memory_order_relaxed); // D
```

执行完上面的程序，可能出现`r1 == r2 == 42`。理解这一点并不难，因为编译器允许调整 C 和 D 的执行顺序。如果程序的执行顺序是 D -> A -> B -> C，那么就会出现`r1 == r2 == 42`。





| 操作              | 有效的Memory order枚举值                                     | 备注                                                         |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Load              | `memory_order_relaxed`, `memory_order_consume`, `memory_order_acquire`, `memory_order_seq_cst` | 其它枚举值不合法， MS STL的实现是将其当作memory_order_seq_cst处理 |
| Store             | `memory_order_relaxed`, `memory_order_release`, `memory_order_seq_cst` | 同上                                                         |
| read-modify-write | `memory_order_relaxed`, `memory_order_consume`, `memory_order_acquire`, `memory_order_release`, `memory_order_acq_rel`, `memory_order_seq_cst` |                                                              |

参考资料：https://zhuanlan.zhihu.com/p/382372072?utm_id=0

https://blog.csdn.net/wxj1992/category_11580766.html





![QQ截图20220909144257](/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220909144257.png)

### 这里所谓的指定内存序，**指的是对执行语句所在的线程内部的限制，也就是之影响一个cpu核心，但是这些对单线程内部的限制组合起来就能实现多线程之间数据同步的效果**，







## atomic_thread_fence分类和效果

在C++ 11及之后的标准里，除了利用原子操作指定内存序，还定义了单独使用memory fence（`std::atomic_thread_fence`）的方式，fence可以和原子操作组合进行同步，也可以fence之间进行同步，fence不光可以不依赖原子操作进行同步，而且相比较于同样memory order的原子操作，具有更强的内存同步效果

和`atomic`变量类似，`atomic_thread_fence`也可以指定六种内存序，指定不同内存序的fence可以分为以下几类：
（1） `std::atomic_thread_fence(memory_order_relaxed)`，没有任何效果。
（2） `std::atomic_thread_fence(memory_order_acquire)` 和 `std::atomic_thread_fence(memory_order_consume)` 属于acquire fence。
（3）`std::atomic_thread_fence(memory_order_release)`属于release fence。
（4）`std::atomic_thread_fence(memory_order_acq_rel)`既是acquire fence 也是release fence，为了方便这里称为full fence。
（5）`std::atomic_thread_fence(memory_order_seq_cst)`额外保证有单独全序的full fence。

也就是说，如果不考虑单独全序，那么有release fence、acquire fence 和full fence三种。下面就根据以前介绍过的四种重排来介绍下这三种fence的效果。

不同类型的Fence对于乱序的保护是不一样的。我们可以将读和写的交错分成下面四种情况：

- Load-Load：读接着读
- Load-Store：先读后写
- Store-Load：先写后读
- Store-Store：写接着写

### release fence

- `Release fence`可以防止fence前的内存操作重排到fence后的任意store（写入）之后，即阻止load-store重排和store-store重排。（**阻止了所有在它之前的读写操作和在它之后的写操作乱序**）



![QQ截图20220909153644](/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220909153644.png)



### acquire fence

- `acquire fence`可以防止fence后的内存操作重排到fence前的任意load（读取）之前，即阻止load-load重排和load-store重排。（**阻止了所有在它之前的读操作与在它之后的读写操作乱序。**）

![QQ截图20220909153840](/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220909153840.png)

### full fence

- 因为`full fence`是release fence和acquire fence的组合，所以也就是防止load-load、load-store、store-store重排



![QQ截图20220909154223](/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220909154223.png)





### C++标准中，三种fence不禁止store-load（先写后读）的重排。

即便是`std::atomic_thread_fence(memory_order_seq_cst)`也一样，只是需要额外保证单独全序，**但是在实际的实现上为了实现这个全序编译器大都是采用了硬件层面的能够阻止storeload重排的full barrier指令**


参考资料：

https://paul.pub/cpp-memory-model/

https://blog.csdn.net/wxj1992/article/details/103917093

# NULL和nullptr区别

其实`NULL`根据命名全大写可以看出来，**它是一个常量，既然是常量，就需要进行宏定义。**

- C语言的标准头文件是这样定义的` #define NULL ((void*)0)`
- 而到了C++中，则变成了`#define NULL 0`

从定义中可以看出，C++中，NULL其实就是0，但是也可以用作空指针，只是用作空指针可能是为了兼容C，迫于无奈。

但是当NULL既可以表示0又可以表示空指针的时候，发生函数重载的时候就会有二义性

```c++
void test(void *p)
{
    cout<<"p is pointer "<<p<<endl;
 }
void test(int num)
{
    cout<<"num is int "<<num<<endl; 
}
int main(void)
{
    test(NULL); //NULL是int还是指针？
    return 0; 
}
```

很明显，NULL存在二义性，它既是整数，也是一个指针，函数test()无法根据参数的数据类型判断应该调用哪一个实现。
 这时使用nullptr的优越性就体现出来了，因为它可以很好地把空指针这一层意思给剥离出来。nullptr就是C++11为了解决这个痛点而推出的东西。

# lockguard和uniquelock

**注意一下锁的含义。为什么锁叫互斥量？不要认为锁和资源是挨着的。或者是资源一定和锁连着。**

**锁，互斥量是独立的。什么意思？假设我们有规定：想要打开抽屉，必须从桌子上拿走令牌。如果没有令牌则不能打开抽屉。所以说资源（抽屉）和锁（互斥量）不一定在一起。资源在抽屉里，锁在桌子上。两者是分离的。我只要确保每个人都可以访问到令牌（锁）和抽屉（资源）即可。**

- `unique_lock`功能丰富灵活得多。如果需要实现更复杂的锁策略可以用`unique_lock`
- 如果只需要基本的锁功能，优先使用更严格高效的`lock_guard`。

两种锁的简单概述与策略对比见下表：

| **类模板**           | **描述**                                                     | **策略**                                         |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------ |
| **std::lock_guard**  | 严格基于作用域(scope-based)的锁管理类模板，构造时是否加锁是可选的(不加锁时假定当前线程已经获得锁的所有权—使用std::adopt_lock策略)，析构时自动释放锁，**所有权不可转移，对象生存期内不允许手动加锁和释放锁** | std::adopt_lock                                  |
| **std::unique_lock** | 更加灵活的锁管理类模板，构造时是否加锁是可选的，在对象析构时如果持有锁会自动释放锁，**所有权可以转移。对象生命期内允许手动加锁和释放锁** | std::adopt_lock std::defer_lock std::try_to_lock |

![QQ截图20220926064910](/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220926064910.png)



![QQ截图20220926064919](/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220926064919.png)



- **`lock_guard`不能手动解锁**。这也是为什么使用条件变量的时候互斥锁一定要使用unique_lock，因为wait函数内部会进行解锁。详细查看项目相关的条件变量。
- `lock_guard`不能创建时不锁定，也就是没有`defer`功能。

# 互斥锁的底层实现

其实就是一个CAS操作的原子变量，查看一个值是0还是1。

- 内存中准备一个表示锁定状态的整数
- 使用CAS操作来尝试修改值（上锁）
- 提供一个函数让互斥锁在被锁定的情况下等待。Linux里面这个操作是`futex`系统调用。这会将线程放入队列中，并监视内存中的整数。
- 可能包括防止指令重排的内存屏障



# Futex

Futex是一种用户态和内核态混合的同步机制。

- 首先，同步的进程间通过`mmap`共享一段内存，`futex`变量就位于这段共享的内存中。且操作是原子的
- 当进程尝试进入互斥区或者退出互斥区的时候，先去查看共享内存中的`futex`变量，如果没有竞争发生，则只修改`futex`,而不 用再执行系统调用了。
- 当通过访问`futex`变量告诉进程有竞争发生，则还是得执行系统调用去完成相应的处理(`wait` 或者 `wake up`)。

- 当进程尝试持有锁或者要进入互斥区的时候，对futex执行"down"操作，即原子性的给futex同步变量减1。如果同步变量变为0，则没有竞争发生， 进程照常执行。如果同步变量是个负数，则意味着有竞争发生，需要调用futex系统调用的futex_wait操作休眠当前进程。 当进程释放锁或 者要离开互斥区的时候，对futex进行"up"操作，即原子性的给futex同步变量加1。如果同步变量由0变成1，则没有竞争发生，进程照常执行。如 果加之前同步变量是负数，则意味着有竞争发生，需要调用futex系统调用的futex_wake操作唤醒一个或者多个等待进程。

futex 的基本思想是**竞争态总是很少发生的，只有在竞争态才需要进入内核，否则在用户态即可完成**。futex的两个目标是：

- 尽量避免系统调用；(因为需要切换到内核态。比如线程的挂起和唤醒都需要切换至内核态)
- 避免不必要的上下文切换（导致的TLB失效等）。

# 自旋锁的底层实现

区别就是不挂起，一直使用CAS尝试上锁。



# 自旋锁和互斥锁的区别

- **自旋锁是一种非阻塞锁**，也就是说，**如果某线程需要获取自旋锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗CPU的时间，不停的试图获取自旋锁**。**不会引起切换**

- **互斥量是阻塞锁，当某线程无法获取互斥量时，该线程会被直接挂起，该线程不再消耗CPU时间，当其他线程释放互斥量后，操作系统会激活那个被挂起的线程，让其投入运行**。**会引起切换** 

- 两种锁适用于不同场景： 
  - 如果是多核处理器，**如果预计线程等待锁的时间很短，短到比线程两次上下文切换时间要少的情况下，使用自旋锁是划算的。**
  -  如果是多核处理器，**如果预计线程等待锁的时间较长，至少比两次线程上下文切换的时间要长，建议使用互斥量。** 
  - 如果是单核处理器，一般建议不要使用自旋锁。因为，在同一时间只有一个线程是处在运行状态，那如果运行线程发现无法获取锁，只能等待解锁，但因为自身不挂起，所以那个获取到锁的线程没有办法进入运行状态，只能等到运行线程把操作系统分给它的时间片用完，才能有机会被调度。这种情况下使用自旋锁的代价很高。 
  - **如果加锁的代码经常被调用，但竞争情况很少发生时，应该优先考虑使用自旋锁，自旋锁的开销比较小，互斥量的开销较大** 



# 可重入锁和不可重入锁

简单来说我们说过同一个线程对一个锁上锁两次会被死锁。因为第二次进行上锁的时候会尝试拿锁，但是一直拿不到。所以线程会被挂起。除非其他线程帮我们解锁。（查看笔试题整理）

- 可重入锁（reentrant lock）：

  - 可重入锁简单如字面而言，就是可以重新进入的锁，允许同一进程多次获取同一把锁，是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提是同一个对象或者class），这样的锁就叫做可重入锁，也叫做递归锁。
  - `recursive_mutex`

- 不可重入锁（non-reentrant lock）：
  - 不可重入锁与可重入锁相反，如果当前线程已经获取了该锁，那么再次尝试获取该锁时，就会出现死锁的状况，被阻塞。在这个线程解锁之前，其他线程无法用这个锁再来加锁。
- 可重入锁不与可重入锁的区别：
  - **不可重入锁只判断这个锁有没有被锁上**，只要被锁上申请锁的线程都会被要求等待。实现起来较为简单。而**可重入锁不仅要判断锁有没有被锁上，还会判断锁是谁锁上的，当就是自己锁上的时候，那么他依旧可以再次访问临界资源，并把加锁次数加一。**



# CAS 的底层实现

汇编指令让CPU锁住内存总线。

# CAS 的缺点

- 自旋时间太长

  - 如果CAS一直不成功呢？这种情况绝对有可能发生，如果自旋CAS长时间地不成功，则会给CPU带来非常大的开销。

- 只能保证一个共享变量原子操作

  - 看了CAS的实现就知道这只能针对一个共享变量，如果是多个共享变量就只能使用锁了，当然如果你有办法把多个变量整成一个变量，利用CAS也不错。例如读写锁中state的高低位。（https://www.cnblogs.com/wait-pigblog/p/9350569.html）

- ABA问题

  - CAS需要检查操作值有没有发生改变，如果没有发生改变则更新。但是存在这样一种情况：**如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，只是又回到了原来的值而已，这就是所谓的ABA问题。**对于ABA问题其解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加1，即A —> B —> A，变成1A —> 2B —> 3A，采用AtomicStampedRdference类可以实现这个方案。



# 前向声明

前向声明可以解决两个类互相包含的问题。因为前向声明属于不完整类型，所以有如下限制：

- 可以
  - 将成员声明为指向不完整类型的指针或引用
  - **声明**接受/返回不完整类型的函数或方法
  - **定义**接受/返回指向不完整类型的指针/引用的函数或方法（但不使用其成员）
- 不可以
  - 将其用作基类
  - 用它来声明一个成员（使用对象）
  - **使用该类型定义**函数或方法
  - 使用其方法或字段，实际上试图解引用类型不完整的变量
    - 这里就是使用这个前向声明类型的指针然后对其解引用使用其类型包含的数据或方法。



# 模板相关



## 类模板定义规则

- 注意c++类模板定义方法 类模板没有自动类型推导。所以只要使用了就必须显式指定参数类型。 
- 但是类模板可以有默认参数和偏特化 
- 类模板中的成员函数只有在调用的时候才会被创建。因为在编译阶段，编译器无法确认模板的参数类型，所以无法创建模板类成员函数

```c++
template<typename 模板参数表>
class 类名{
    // 类定义．．．．．．
};
```

- 注意全特化和偏特化的语法

```c++
template<typename T1, typename T2>
class test{
    T1 data1;
    T2 data2;
};
//全特化
template<>
class test<int, float>{
    int data1;
};
//偏特化
template<typename T2>
class test<int, T2>{
    int data1;
};
```





## 模板调用顺序 规则 

- 类模板： 对主版本模板类、全特化类、偏特化类的调用优先级从高到低进行排序是：全特化类>偏特化类>主版本模板类。这样的优先级顺序对性能也是最好的。 
- 函数模板： 如果函数模板和普通函数都可以实现，优先调用普通函数 **可以使用空模板参数列表来强制调用函数模板** 函数模板也可以重载 如果函数版可以产生更好的匹配，则优先调用函数模板.
  - **函数模板只能全特化**


```c++
void test(int a, int b){
    cout << "普通函数" << endl;
}

template <typename T>
void test(T a, T b){
    cout << "模板函数" << endl;
}

template <typename T>
void test(T a, T b, T c){
    cout << "重载的模板函数" << endl;
}

int main(){
    test(1,2); //输出普通函数
    test<>(1,2); //使用空模板参数列表 输出模板函数
    test(1,2,3); //输出重载的模板函数
}
```





## 模板模板参数

模板的模板参数的经典应用是在某些自定义指定储存容器类型的时候不指定元素类型。 

- 最基本的举例

```c++
template<template<typename> class container, typename T1, typename T2> // 最基本的举例
class test{
    container<T1> a1;
    container<T2> a2;
};
```

- 茴字的三种写法, 都可以

```c++
template <typename T, template <typename> class Container>
template <typename T, template <class> class Container>
template <typename T, template <typename> typename Container>
```

- 更好的理解的写法:

```c++
template <typename T, template <typename T1> typename Container>
```

- 更多例子参见template_template_parameter_*文件

## 模板参数按值传递还是引用传递

https://vinkle.top/2021/06/12/cpp-template-7/#7-%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92



## 非类型模板参数

这块之前居然忽略了。必须简单说一下

```c++
template<typename T>
void func(T obj){
    //...
}

int main(){
    func<int>(5);
    return 0;
}
```

我们都知道模板参数一般都是类型。比如这里，T就是int。是类型。

但是如果我们有时候需要一些特殊情况， 例如想要传点奇怪东西的时候。

```c++
template<typename T, int MAXSIZE>
void func1(T obj){
    vector<T>a;
    a.reserve(MAXSIZE);
    cout << a.capacity() << endl;
    a.push_back(obj);
    cout << a[0] << endl; 			//干啥了不解释了 忽略即可
}

```

这里的`int MAXSIZE`就是非类型模板参数。因为他不是类型，而是变量。

使用非类型模板参数是有限制的。通常它们只能是：

1. 整型常量或字面值（包含枚举，或可隐式转换的比如`bool`）（`string` `double`都不可以。前者是类对象，后者是浮点数）
2. 指向对象/函数/成员变量的指针
3. 对象/函数的左值引用
4. `std::nullptr_t`

当传递对象的指针或者引用作为模板参数时，对象不能是字符串常量，临时变量或者数据成员以及其他子对象。由于C++17之前，C++每次版本更新都会放宽以上限制，因此还有一些针对不同版本的限制：

- C++11中，对象必须要有外部链接
- C++14中，对象必须是外部链接或者内部链接

所以：传入的`s`必须是常量。

```c++
const int s = 8;	//必须是const
func1<int, s>(5);
func2<int, 4>(5); //或者直接传入字面值。
```



### 搭配类模板偏特化的小例子

```c++
template<typename T, bool option>
class myclass; //主模板不实现

template<typename T>
class myclass<T, true>{ //偏特化1，注意语法。T在这里依旧要写上。
    public:
    void func(){
        cout <<"true one" << endl;
    }
};


template<typename T>
class myclass<T, false>{ //偏特化2，注意语法。T在这里依旧要写上。
    public:
    void func(){
        cout <<"false one" << endl;
    }
};

int main(){
    const bool myoption = true;
    myclass<int, false> obj; //直接使用字面值
    obj.func();
    myclass<int, myoption> obj1; //或必须用const常量变量。
    obj1.func();
    return 0;
}
```



## enable_if

简单看一下原型

```c++
template <bool, typename T=void>
struct enable_if {
};
template <typename T>
struct enable_if<true, T> { ///< 第一个模板参数为 true
  using type = T;           ///< type 才有定义
};
```

意思就是，前面的表达式为真，后面的类型定义才有意义。

一般三种用法：

- 控制函数返回类型
- 校验函数模板参数类型
- 类型偏特化

这里就随便写个控制函数返回类型的例子：

```c++
template<int stat> //这里是非模板类型参数。上面提到了。注意一下
typename enable_if<stat == 1, bool>::type checkstate(){
    cout <<"type is bool" << endl;
    return true;
}
template<int stat>
typename enable_if<stat == 0, int>::type checkstate(){
    cout <<"type is int" << endl;
    return 5;
}

template<bool stat>			//bool也可以。隐式转换为整型了，但是必须要常量。
typename enable_if<stat == true, int>::type checkstate1(){
    cout <<"type is int" << endl;
    return 5;
}

int main(){
    const int myobj = 1; 	//必须是const
    checkstate<myobj>();	//输出"type is bool" 
    checkstate<0>();		//输出"type is int" 
    return 0;
}
```

注意事项：返回类型前必须加`typename`来告知`enable_if::type`是个类型。还有就是非模板类型参数的限制。



## 函数的变长参数模板

- 基本定义

```c++
template <typename T, typename... Args> 
// 如果函数参数列表中一个参数的类型是一个模板参数包,
// 则此参数也是一个函数参数包
void func(const T& t, const Args&... rest);
```



- C++17之前的写法：因为没有折叠表达式

```c++
void print (){
//必须要有无参重载，否则会无限递归。也就是最后一次无参无法被调用。
//最后一次被解包后，参数包会为空。所以会调用无参函数。
}
template<typename T, typename... Args>
void print (T firstArg, Args... args)
{
    cout << firstArg << endl; //print first argument
    print(args...); // call print() for remaining arguments
}
int main() 
{
    print(1, 1000, "b23", 1.123, "HahaahaH", 42);
    return 0;
}
```

- C++17之后的写法：有了折叠表达式

```c++
template<typename T> //要有单参打印的重载。不然会无限调用。
void print(T t){
    cout << t << endl;
}


template<typename... Args>
void print(Args... args){
    (print(args),...); //这里外部一定要加括号。注意语法
}


int main() 
{
    print(1, 1000, "b23", 1.123, "HahaahaH", 42);
    return 0;
}
```

- **多种变长参数模板可以同时存在 尽管直观看起来会有二义性**



### 搭配列表初始化

- 函数变长参数模板搭配列表初始化。
  - 这个函数会返回一个`T`类型的`vector`，元素是`args`

```c++
template<typename T, typename... Args>
vector<T> func(const Args&... args){
    return {args...};
}
int main(){
    auto vec = func<int>(1,2,3,4,5,6,7);
    for(auto& i:vec){
        cout << i << endl;
    }
}
/*
输出：
1
2
3
4
5
6
7
*/
```









## 类的变长参数模板

- 基本定义：

```c++
template<typename... Ts> class Variadic;
```

- 其模板实例化：

  - 0个参数的模板类 `Variadic<> zero;`

  - 多个参数的模板类 `Variadic<int, double, std::string, std::list<int>> sample;`







## 模板类对象做为函数参数传入

```c++
template<typename T1, typename T2>
class test{
public:
    T1 _a;
    T2 _b;
    test(T1 a, T2 b) : _a(a), _b(b) {}
};

void testprint1(test<int,int>& obj){ //方法1 显式指定传入类型
    cout << obj._a << obj._b << endl;
}

template<typename T1, typename T2> 
void testprint2(test<T1, T2>& obj){ //方法2 使用参数模板
    cout << obj._a << obj._b << endl;
}


template<typename T>
void testprint3(T& obj){ //方法3 利用函数模板的自动推导特性
    cout << obj._a << obj._b << endl;
}

int main(){
    test<int,int> b(5,5);
    testprint1(b);
    testprint2(b);
    testprint3(b);
}
```

## 类模板 模板类 的继承 子类调用父类构造函数

- **当有多继承的时候，子类继承的父类必须全部拥有默认无参构造函数。因为创建子类对象时，一定会先调用父类构造函数。如果子类的构造函数没有指明调用父类的有参构造的话，就会调用默认构造。但是一旦类有了一个构造函数，编译器就不会自动生成默认构造函数，导致编译失败。**

```c++
template<typename T1, typename T2>
class test{
public:
    T1 _a;
    T2 _b;

    test(T1 a, T2 b) : _a(a), _b(b) {}

    void showitem(){
        cout << this->_a << "," << this->_b << endl;
    }


};

template<typename T1, typename T2, typename T3, typename T4>
class test1 : public test<T1, T2>{ //!继承模板父类，子类父类都要是模板类。而且要显式指定父类模板类型。
public:
    // T1 _a;   //!如果子类也有自己的_a 和_b变量的话 那就不能调用父类构造函数赋值。
                //!想一下，子类自己的东西怎么可能让父类构造函数赋值？
                //@所以调用父类构造函数赋值其实相当于给子类的父类成分赋值。
    // T2 _b;
    T3 _c;
    T4 _d;
    //test1(T3 a, T4 b) : _a(a), _b(b) {}
    test1(T1 a, T2 b, T3 c, T4 d) : test<T1, T2>(a,b),_c(c),_d(d) //调用父类构造函数赋值 //!记得调用模板类父类构造函数的时候要显式指定数据类型
    {
        //!可以用构造列表也可以普通构造函数
        // _c = c; 
        // _d = d;
    }
    void showitem(){
        cout << this->_a << "," << this->_b << "," << this->_c << "," << this->_d<< endl;
    }

};



int main(){
    test<int,int>* b = new test<int, int>(5,5);
    b->showitem();
    test1<int, int, char, char>* c = new test1<int, int, char, char>(1,2,'a','b');
    c->showitem();
    
    //指针和对象都可以
    test<int,int> bb(5,5);
    bb.showitem();
    test1<int, int, char, char> cc (1,2,'a','b');
    cc.showitem();
}

```

## 普通类的子类调用父类构造函数长这样

```c++
class A {
    public:
        A(){}
        A(int a) :m_a(a) {}
        virtual~A(){}
    int m_a;
};

class B : public A{
    public:
        B(){}
        B(int x):m_b(x){}
        B(int no, int x):A(no),m_b(x){} //子类调用父类构造。
        ~B(){}
        int m_b;
};

int main(){
    B b(5,8);
    cout << b.m_a << endl;
    
    return 0;
}
```

## 模板类 类模板 成员函数 类外实现

```c++
template<typename T1, typename T2>
class test{
    T1 _a;
    T2 _b;
    test(T1 a){} //构造1
    test(T1 a, T2 b){} //构造2
    void func1(); //无参函数1
    void func2(T1 a); //有参函数2
};

/*
类模板 成员函数 类外实现
头部要加模板
作用域部分要显式指明数据类型
*/
template<typename T1, typename T2>
test<T1, T2>::test(T1 a) : _a(a){} //构造1 使用初始化列表


template<typename T1, typename T2> 
test<T1, T2>::test(T1 a, T2 b){ //构造2
    _a = a;
    _b = b;
}

template<typename T1, typename T2>
void test<T1, T2>::func1(){ //无参函数1
    cout <<"func1" << endl;
}

template<typename T1, typename T2>
void test<T1, T2>::func2(T1 a){ //有参函数2
    cout <<"func2" << endl;
}

```

## 万能引用相关

参见杂记。





# auto

- auto 变量必须在定义时初始化，这类似于const关键字。
- 定义在一个auto序列的变量必须始终推导成同一类型。例如：

```c++
auto a4 = 10, a5 = 20, a6 = 30;//正确
auto b4 = 10, b5 = 20.0, b6 = 'a';//错误,没有推导为同一类型
```

- **如果初始化表达式是引用，则去除引用语义。**

```c++
int a = 10;
int &b = a;
 
auto c = b;//c的类型为int而非int&（去除引用）
c = 100;
cout << c << endl; //100
cout << b << endl; //10
cout << a << endl; //10
```

我们看到了即使`b`是`a`的引用，我们使用`b`初始化`c`的时候依旧使用了值语义。也就是`c`是一个独立变量。更改`c`的值不影响`a`和`b`

```c++
int a = 10;
int &b = a;

auto &c = b;//c的类型为int&
c = 100;
cout << c << endl; //100
cout << b << endl; //100
cout << a << endl; //100
```

- **如果初始化表达式为const或volatile（或者两者兼有），则除去const/volatile语义。**

```c++
const int a1 = 10;
auto  b1= a1; //b1的类型为int而非const int（去除const）
const auto c1 = a1;//此时c1的类型为const int
b1 = 100;//合法
c1 = 100;//非法
```

- 如果auto关键字带上&号，则不去除const语意。

```c++
const int a2 = 10;
auto &b2 = a2;//因为auto带上&，故不去除const，b2类型为const int
b2 = 10; //非法
```

- **初始化表达式为数组时，auto关键字推导类型（退化）为指针。**

```c++
int a3[3] = { 1, 2, 3 };
auto b3 = a3;
cout << typeid(b3).name() << endl; //int *
```

- 若表达式为数组且auto带上&，则推导类型为数组类型

```c++
int a7[3] = { 1, 2, 3 };
auto & b7 = a7;
cout << typeid(b7).name() << endl; //int[3]
```

- **时刻要注意auto并不是一个真正的类型。**
  - auto仅仅是一个占位符，它并不是一个真正的类型，不能使用一些以类型为操作数的操作符，如sizeof或者typeid





**所以我们才会有`auto& `, `auto&&`，`const auto`,`const auto&`等等。还可以有`auto*`，也可以被volatile修饰**

- **注意在使用增强for循环遍历容器元素时，如果声明为auto则最好变成`const auto& `防止修改和拷贝。**
  - 使用增强for循环遍历容器元素时，`auto`的类型是容器内元素的类型。所以需要加`const`或`&`




其他细节参见列表初始化。



# C++17 复制省略技术

1. 返回值优化（RVO），即通过将返回值所占空间的分配地点从被调用端转移至调用端的手段来避免拷贝操作。返回值优化包括具名返回值优化（NRVO）与无名返回值优化（URVO），两者的区别在于返回值是具名的局部变量还是无名的临时对象。


2. **右值拷贝优化，当某一个类类型的临时对象被拷贝赋予同一类型的另一个对象时，通过直接利用该临时对象的方法来避免拷贝操作。**
   - 在一个变量的等号右侧是 **临时变量(prvalue)** 的时候，这里会用 direct-initalize，而不是尝试使用 copy/move initialize。对于一些没有拷贝构造或移动构造的对象，如`unique_ptr`、`atomic`，`std::array`等可以使用等号初始化了。但是前提是右侧是一个临时对象以满足右值拷贝优化。

所以

```c++
auto a = atomic<int>{9};  //c++14 error， C++17 OK
atomic<int>s = 4;//c++14 error， C++17 OK
```



# stringstream

## 我们可以使用`stringstream`方便的在`string`和其他内值类型之间进行转换。

- 首先要`#include<sstream>`
- 然后需要有一个`stringstream` 对象`stringstream ss`
- 我们可以把字符串使用流插入运算符`<<`把要转换的字符串插入`stringstream` 对象
- 使用流提取运算符`>>`把转换完成的对象提取至对应类型的变量内
- 然后记得把`stringstream` 对象清空。
- 支持负数自动转换。

```c++
vector<int> process(vector<string>& input){
    vector<int> ret;
    stringstream ss; //stringstream对象
    for(int i = 0; i < input.size(); i++){
        ss << input[i]; //要转换的东西插入对象
        int a;
        ss >> a; //提取至我们想要的对象
        ss.clear(); //清空stringstream对象
        ret.push_back(a);
    }
    return ret;
}
int main(){
    vector<string> s{"1","2","200","-20","-10000"};
    vector<int> ret = process(s);
    for(int i = 0; i < ret.size(); i++){
        cout << ret[i] << endl;
    }
    return 0;
}
```



## 我们还可以使用stringstream进行默认分割。此处是根据空格，tab和回车换行分割

```c++
void split(const string& str){
    vector<string> item;
    stringstream ss(str); //字符串放入stringstream对象
    string temp; //储存临时分割对象
    while(ss >> temp){ //直到字符耗尽
        item.emplace_back(temp); //放入结果数组。
    }

    for(auto& i:item){
        cout << i << endl;
    }

}
```



## 我们还可以使用stringstream搭配getline进行自定义分割。

```c++
void split(const string& str, const char& splitter){
    vector<string> item;
    stringstream ss(str);
    string temp;
    while(getline(ss, temp, splitter)){
        item.emplace_back(temp);
    }
    for(auto& i:item){
        cout << i << endl;
    }

}
```







# std::initializer_list

搭配聚合初始化一起看。

- 在我们使用大括号进行列表初始化的时候，如果我们有显式的符合对应条件的列表初始化构造函数则会优先匹配。
- 注意列表初始化只能使用相同类型或可以被转换为相同类型的参数。
- 匹配`initializer_list`构造函数必须使用`{}`
- 如果有默认构造函数就算有`initializer_list`构造函数，但是如果对象构造时入参为空，就算使用了`{}`也优先匹配默认构造函数。除非没有默认构造函数。
  - 如果没有默认构造函数，则会匹配`initializer_list`构造函数也就是构造对象时就算没有参数要输入也必须加`{}`
- `initializer_list`构造函数拥有高优先级。但是默认构造函数(default constructor)拥有最高优先级

```c++
class myclass{
    public:
        myclass(){
          cout <<"default" << endl;
        };
                
        myclass(int x, int y):val1(x), val2(y){
            cout <<"cont0" << endl;
        }
        myclass(int x, int y, int z):val1(x), val2(y), val3(z){
            cout <<"cont1" << endl;
        }
        myclass(int x, int y, int z, const string& s):val1(x), val2(y), val3(z), s_m(s){
            cout <<"cont2" << endl;
        }
        myclass(std::initializer_list<int>list){
            val1 = *list.begin();		//提取第一个元素。
            val2 = *list.begin()+1;		//提取第二个元素
            val3 = *list.begin()+2;
            cout <<"cont3" << endl;
        };

        int val1;
        int val2;
        int val3;
        string s_m = "";
};




int main(){
    myclass obj0{1,2};		//cont3 因为使用了大括号
    myclass obj1{1,2,3};	//cont3 因为使用了大括号
    myclass obj2{1,2,3, "abcd"};//cont2 虽然使用了大括号但是类型不匹配，所以转而匹配普通的符合条件的构造函数。


    myclass obj4(1,2);	//cont0 因为没有使用大括号
    myclass obj5(1,2,3);//cont1 因为没有使用大括号
    myclass obj6(1,2,3,"abcd");//cont2 因为没有使用大括号
  
  
  	myclass obj7; //default 注意不能加小括号。那是函数声明。
    myclass obj8{}; //default。就算有initializer_list构造函数，但是如果创建对象是无参的也优先匹配默认无参构造函数因为他有最高优先级。除非没有默认无参构造函数。
    return 0;
}
```

- 特别的，如果`initializer_list`构造函数被`explicit`修饰，则也嘘遵照其`explicit`进制隐式类型转换的规则。
- **如果构造函数所有参数都有默认值，这个构造函数就成了默认构造函数**
- 默认构造函数就是要么没有参数，要么所有参数都有默认值。

```c++
class obj{
    public:
        explicit obj(int a = 10, int b = 20):val1(a), val2(b){}; //禁止隐式类型转换。
    int val1;
    int val2;
};
int main(){
    obj t1; //可以。有默认构造函数。
    obj t2{10,20}; //可以，explicit只能限制拷贝初始化。这里是直接初始化。
    obj t3 = {10,20}; //不可以，禁止隐式类型转换。
    obj t4 = obj{10,20}; //可以，显式类型转换。
    return 0;
}
```




- 注意，当一个类中不仅含有普通构造函数，还含有`initializer_list`构造函数，那么这个类在使用`()`或`{}`初始化的时候会有不同的含义。比如`vector`。例子：

```c++
class myobj{
    public:
        myobj(int x, int y){
            inner_vec.resize(x, y); //可能会有更优雅的解决方案。
        }
        myobj(initializer_list<int>my_list){
            for(auto& j:my_list){
                inner_vec.emplace_back(j);
            }
        }
        vector<int> inner_vec;
};



int main(){
    myobj ob1(2,3); //两个值为3的元素。
    for(auto& i:ob1.inner_vec){
        cout <<i << endl;
    }
    cout <<"----------" << endl;
    myobj ob2{1,2,3,4,5,6,7}; //把元素1,2,3,4,5,6,7放入vector
    for(auto& i:ob2.inner_vec){
        cout <<i << endl;
    }
    return 0;
}
```



## 原理分析

- 当用`{}`进行初始化的时候，首先会创建一个array，并将初始化元素存放起来。然后，调用`initializer_list`的构造函数，用array首元素的迭代器和array的元素个数，进行初始化。

- 如果仔细看会发现，`initializer_list`构造函数是private类型的，按道理来说，是没有办法外部调用的！但是，在源码中也注明了，编译器可以调用该private构造函数。

- 除此之外，还有如下几个注意点：

  - `initializer_list`是一个轻量级的容器类型，内部定义了iterator等容器必需的概念。
    - **其中有3个成员接口：`size()`、`begin()`和`end()`。遍历时取得的迭代器是只读的，无法修改其中的某一个元素的值；**

  - 对于`initializer_list`而言，它可以接收任意长度的初始化列表，但要求元素必须是同种类型T(或可转换为T)；

  - `initializer_list`内部并不负责保存初始化列表中的元素拷贝，仅仅是列表中元素的引用而己。因此，通过拷贝构造对象与原对象共享列表中的元素空间。也就是说，`initializer_list`的内部并没有内含该array的内容，仅仅是拥有指向array的迭代器。如果拷贝构造或者拷贝赋值的话，array的内容只有一份，但有两份迭代器指向。如果对`initializer_list`对象copy一个副本，默认是浅拷贝，此时两个对象指向同一个array。这是危险的。
    - 来自cppreference：底层数组是 `const T[N]` 类型的[临时](https://zh.cppreference.com/w/cpp/language/implicit_conversion#.E4.B8.B4.E6.97.B6.E9.87.8F.E5.AE.9E.E8.B4.A8.E5.8C.96)数组，其中每个元素都从原始初始化器列表的对应元素[复制初始化](https://zh.cppreference.com/w/cpp/language/copy_initialization)（除非窄化转换非法）。底层数组的生存期与任何其他[临时对象](https://zh.cppreference.com/w/cpp/language/lifetime#.E4.B8.B4.E6.97.B6.E5.AF.B9.E8.B1.A1.E7.9A.84.E7.94.9F.E5.AD.98.E6.9C.9F)相同，除了从数组初始化 initializer_list 对象会延长数组的生存期，恰如[绑定引用到临时量](https://zh.cppreference.com/w/cpp/language/reference_initialization#.E4.B8.B4.E6.97.B6.E9.87.8F.E7.94.9F.E5.AD.98.E6.9C.9F)（有例外，例如对于初始化非静态类成员）。底层数组可以分配在只读内存。

```c++
std::initializer_list<int> func(void){
  int a = 1, b = 2;
  return {a, b};      //由于initializer_list保存的是对象的引用，但a与b是局部变量在
                      //func返回后会被释放，initializer_list内部会存在空悬指针！危险！
                      //正确的做法可以将返回值改为保存副本的容器，如vector<int>
}

//注意下面s1、s2、s3和s4均共享元素空间
initializer_list<string> s1 = { "aa", "bb", "cc", "dd" };
initializer_list<string> s2 = s1;
initializer_list<string> s3(s1);
initializer_list<string> s4;
s4 = s1;

```






# 指针A给指针B赋值的意思是将指针A指向的地址赋给指针B

```c++
int digit = 5;
int* a = &digit;
int* b = a; //指针a指向的地址赋给指针b 没有新对象产生所以不会调用拷贝构造。
int* c = &*a; //等同于将指针a先解引用（*a = 5），得到指针a指向的的值。然后把这个值取地址(&*a)赋值给指针c。

cout << b << endl; //打印b储存的地址。也就是b指向的地址。 也就是变量地址。等同于&digit 和&*b
cout << &b << endl; //打印b自己的地址。
cout << &*b << endl; //打印b指向的地址的值的地址。等于直接打印指针。
cout << &digit << endl; //打印变量地址。等于直接打印指针和&*b
cout << *b << endl; //解引用b 打印b指向的地址的值。

```

# 指针加法

## 指针直接和数字相加：意思是指针当前指向的地址 + 对应指针类型的大小 * 数字。

举例：

```c++
int * p;
p = (int*)malloc(100); //分配100字节。
cout << p<< endl; //打印p储存的地址。也就是指针指向的地址。是内存首地址。此处输出 0x771410
auto y = p + 1; //把p指向的地址偏移4位（因为int是4字节）后赋值给y。
printf("%#x",y); //打印y储存的地址。也就是指向的地址。此处输出 0x771414
```

**也就是说指针直接和数字相加，可以理解为用指针操作数组。加几就是将指针往后移动几位。具体偏移量也就是对应对象的大小*移动位数。**



## 如果想要指定一个具体的偏移量应该怎么办？

首先，可以使用转型将指针转换为对应类型。然后再加数字。

举例：

```c++
obj* p;
p = (obj*)malloc(sizeof(int) * 10);
cout << p<< endl; //打印p储存的地址。也就是指针指向的地址。是内存首地址。 此处输出 0x771410
auto x = (char*)p + 1; //把p指向的地址偏移1位后赋值给x。因为char是1位。
printf("%#x\n",x); //打印x储存的地址。也就是指向的地址。此处输出 0x771411
auto y = (obj*)p + 1; //把p指向的地址偏移8位后赋值给x。因为obj是指针类型。8位。
printf("%#x\n",y); //打印y储存的地址。也就是指向的地址。此处输出 0x771418
```

**注意：指针类型转换指的是指针转换为对应类型的指针。**

**此处不要使用`cout`**

`auto x = (char*)p`的意思是把指针`p`转为`char*`类型的指针。不可以`auto x = (char)p`。 这样做的意思是直接转换成了`char`。当然，所有的指针都是8字节。记住，指针类型指的是告诉指针应该读取指针指向的地址之后多大的数据。

怎么理解这个操作呢。我们可以想一下。如果 `a`是`int*`类型，也就是`int`类型指针。意思是指针`a`指向的数据是`int`，所以需要以`4`字节为一段进行读取。也就是一次读取四个字节。那么`a+1`其实是对地址进行了`+4`操作。因为指针+1的意思是将指针往后移动一个**对象位。也就是指针当前指向的地址 + 对应指针类型的大小（此处为4） * 数量（此处为1）**。但是我们如果想要对地址`+1`的话怎么办？我们可以把指针`a`转换为`char*`类型也就是`char`类型指针。而不是`int`类型指针。这样相当于告诉编译器，指针`a`指向的数据是`char`。所以需要以1字节为一段进行读取。也就是一次读取一个字节。所以此时`a+1`就是对地址进行了`+1`操作。**也就是指针当前指向的地址 + 对应指针类型的大小（此处为1） * 数量（此处为1）。**

移动一个对象位也就是移动的偏移量为对象大小。



```c++
int digit = 5;
int* a = &digit;
cout << a << endl;
auto x = (char*)a + 1;
printf("%#x\n",x);
```

**注意！`(char*)a + 1`往后移动1位的时候，`(char*)a`的意思是把指针a看成指向`char`类型的指针（告诉编译器一段是1）。所以`(char*)a + 1`不是+2，还是+1。因为指针`a`指向的地址根本没变。仅仅是看成了`char`类型的指针后+1**



# 函数入参为指针的时候，指针本身会有浅拷贝

```c++
void func(int* a){
    cout << &a << endl; //打印指针的地址
    cout << a << endl;  //打印指针指向的变量的地址
}

int main(){
    int* ptr = new int(5);
    cout << &ptr <<endl; //打印指针的地址
    cout << ptr << endl; //打印指针指向的变量的地址
    func(ptr);
}
/*
输出：
0x61fe18 //指针地址
0x1b1490 //变量地址
0x61fdf0 //指针地址
0x1b1490 //变量地址
*/

```

- 我们可以看到，指针入参后，指针本身会发生拷贝。会发生指针给指针赋值。也就是新建了一个指针指向了同一个地址，也就是浅拷贝。所以此时会有两个指针指向同一个地址。一个在`func`函数内，一个在`main`里。



# 函数指针 和 回调函数

- 函数指针

```c++
typedef int(*ptr)(int, int); //typedef 定义别名
ptr instance = add; //方法一 函数外直接生成示例并赋值。注意这里typedef之后直接把函数赋值过去即可。
ptr test1;
test1 = add; //这里是错的。函数体外只能进行全局函数和变量的声明，而无法执行语句或调用函数。

int add(int a, int b){ //不需要传入函数指针了。
    cout << a+b << endl;
    return (a+b);
}

int main(){
    ptr test; //方法二 函数内进行分离声明
    test = add;
    test(5,8);
}
```

- 回调函数

```c++
int add(int a, int b){ 
    cout << a+b << endl;
    return (a+b);
}

void callback(int(*ptr)(int,int), int a, int b){ //设立callback函数。传入函数指针和参数。
  注意这里如果需要有值传出就要设置为返回int
    ptr(a, b);
}

int main(){
    callback(add, 5, 8);
}
```

- 回调函数 c++风格

```c++
void callback(int(*ptr)(int, int), int a, int b){ //回调函数 如果需要返回值就return
    ptr(a, b);
}


class test{
    public:
        static int add(int a, int b){ //需要被执行的函数。注意要static。要么就全局。
            cout << a+b << endl;
            return (a+b);
        }
        void registure(){ //注册函数
            callback(add, 3, 5);
        }
        
};

int main(){
    test Test;
    Test.registure();
    return 0;
}
```

- 回调函数 c++多态

```c++
class basecase{
    public:
        virtual void testmsg() = 0;
        virtual ~basecase(){}; //虽然这里没什么卵用但是还是要记得虚析构，不然无法执行子类析构
};

class case1 : public basecase{ //继承
    public:
        void testmsg() override{
            cout << "Case1 coutmsg" << endl;
        }
};

class case2 : public basecase{ //继承
    public:
        void testmsg() override{
            cout << "Case2 coutmsg" << endl;
        }
};

int main(){
    basecase* test1 = new case1();
    basecase* test2 = new case2();
    test1->testmsg();
    test2->testmsg();
    delete test1; //养成良好习惯
    delete test2;
    return 0;
}
```

## 注意c++中的类回调函数必须是静态函数或者是全局函数。

一般来说为了封装性质，我们需要把一个函数放入类内。但是调用类成员函数需要加`this`，也就是要通过对象调用。但我们不想这样做。于是想舍弃这个`this`的话就应该设置为`static`静态函数。静态函数就像一个全局函数一样，也就是带作用域的全局函数。满足我们的需求。

## 静态函数只能访问静态对象，想访问非静态数据怎么办？

我们可以把回调函数的入参设置为一个类对象的指针或者是一个`void*`类型的指针。然后通过这个入参来调用。

- 例子1：传入类对象指针

```c++
class A{
    public:
    static void callback(A *pThis); //静态函数
    void b(){ //非静态函数
        cout <<"b" << endl;
    }        
}; 
 
void A::callback(A *pThis) //入参为类类型指针
{
    pThis->b(); //静态函数中调用非静态函数
}
int main(){
    A* aptr = new A();
    A::callback(aptr); //指针传入回调函数。
    delete aptr;
    return 0;
}
```

- 例子2：传入this指针

```c++
class A{
    public:
    static void callback(A *pThis); //静态函数
    void b(){ //非静态函数
        cout <<"b" << endl;
    }       
    void in_class(){
        callback(this); //直接传入this
    } 
}; 
 
void A::callback(A *pThis)
{
    pThis->b(); //静态函数中调用非静态函数
}
int main(){
    A* aptr = new A();
    aptr->in_class();
    delete aptr;
    return 0;
}
```

例子3：使用void*类型做为入参后强转。

```c++
class A{
    public:
    static void callback(void *pThis); //静态函数
    void b(){ //非静态函数
        cout <<"b" << endl;
    }       
    void in_class(){
        callback(this); //直接传入this
    } 
}; 
 
void A::callback(void *pThis)
{
    ((A*)pThis)->b(); //静态函数中调用非静态函数。强转
}
int main(){
    A* aptr = new A();
    aptr->in_class();
    delete aptr;
    return 0;
}
```

