---
title: C++杂记 - 3
date: 2022-09-06 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true
  
---



# C++杂记 - 3

# std::bind, std::function 和 std::mem_fn

## std::bind 包括但不限于mem_fn的功能，更为通用的解决方案

**什么是bind？我们可以把它看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。**

std::bind将可调用对象与其参数一起进行绑定**，绑定后的结果可以使用std::function保存**。std::bind主要有以下两个作用：

- 将可调用对象和其参数绑定成一个仿函数；
- 只绑定部分参数，减少可调用对象传入的参数。

语法：

```c++
auto newCallable = bind(callable, arg_list);
```

该形式表达的意思是：当调用`newCallable`时，会调用`callable`，并传给它`arg_list`中的参数。

需要注意的是：`arg_list`中的参数可能包含形如`_n`的名字。其中`n`是一个整数，这些参数是占位符，表示`newCallable`的参数，它们占据了传递给`newCallable`的参数的位置。数值`n`表示生成的可调用对象中参数的位置：`_1`为`newCallable`的第一个**待填充**参数，`_2`为第二个**待填充**参数，以此类推。
注意这些占位符在`std::placeholders`名称空间内。

- **std::bind的返回值是可调用实体，可以直接赋给std::function**。

- **bind绑定类非静态成员函数时，第一个参数表示对象的成员函数的指针，第二个参数表示对象的地址，这是因为对象的成员函数需要有this指针**。并且编译器不会将对象的成员函数隐式转换成函数指针，需要通过&手动转换（符合成员函数指针的赋值语法）。静态成员函数无需此操作。因为没有this指针。

```c++
class my_class{
    public:
    int val;
    my_class(int x):val(x){}

    void getval(){
        cout << val << endl;
    }
    void add(int another){
        val = val + another;
        cout << val << endl;
    }
    static void staticfunc(int val){
        cout << "static" << val << endl;
    }
};
int main(){
    my_class obj1(10);
    auto task2 = bind(&my_class::getval, &obj1); 	//调用无参函数，this参数预绑定。成员函数指针遵循语法。
    auto task3 = bind(&my_class::add, &obj1, placeholders::_1);	//调用有参函数，this参数预绑定。
    auto task4 = bind(&my_class::add, placeholders::_1, placeholders::_2); //调用有参函数，this参数使用占位形式。
    auto task5 = bind(&my_class::staticfunc, placeholders::_1); //静态成员函数没有this指针。无需传入。
    task2();
    task3(3); 
    task4(&obj1, 3); //this使用占位形式，需要调用时传入。
    task5(3);
    return 0;
}
```



 ## mem_fn 成员函数适配器 把成员函数转为函数对象，使用对象指针或对象(引用)进行绑定

**个人实验得出的结论：`mem_fn`是`bind`的子集**。

注意`mem_fn`不能调用类静态成员函数。因为没有this指针。

`mem_fn`就是强制给你把类对象塞进去。

比较：

```c++
class my_class{
    public:
    int val;
    my_class(int x):val(x){}

    void getval(){
        cout << val << endl;
    }
    void add(int another){
        val = val + another;
        cout << val << endl;
    }
    static void staticfunc(int val){
        cout << "static" << val << endl;
    }
};
int main(){
    my_class obj1(10);

    auto task1 = mem_fn(&my_class::getval); 
    task1(&obj1); //把对象地址传入

    auto task2 = mem_fn(&my_class::add);
    task2(&obj1, 5);

    //auto task3 = mem_fn(&my_class::staticfunc); 错误！静态成员函数不行。

    auto task1_1 = bind(&my_class::getval, placeholders::_1); //bind就得多写个参数
    task1_1(&obj1);
    
    auto task1_2 = bind(&my_class::getval, &obj1);
    task1_2();

    return 0;
}
```






## std::placeholders

我们提到了，我们使用`bind`的时候，`placeholder`是待填充参数。什么叫待填充？这是一种具象解释。其实它相当于生成了一个新的可调用对象，拥有两个参数。但是结合原本的可调用对象来看，我们有三个参数。所以站在原本的可调用对象角度来看，相当于待填充。

语法和例子：

```c++
void testfunc(int x, int y, int z){
    cout << x << endl;
    cout << y << endl;
    cout << z << endl;
}
int main(){

    auto callable1 = bind(testfunc, placeholders::_1, placeholders::_2, 5);
    callable1(8,80);
    //输出8 80 5
    auto callable2 = bind(testfunc, placeholders::_2, placeholders::_1, 5);
    callable2(8,80);
    //输出80 8 5

    auto callable3 = bind(testfunc, placeholders::_1, 5, placeholders::_2);
    callable3(8,80);
    //输出8 5 80
    auto callable4 = bind(testfunc, placeholders::_1, 5, placeholders::_3); //错误。新的调用对象只有两个参数。这里3超了。
    callable4(8,80);
    
    auto callable5 = bind(testfunc, placeholders::_1, 5, placeholders::_1); //极端情况。占位符可以重复。
    callable5(8);
    //输出8 5 8
}
```



参考资料：https://elloop.github.io/c++/2015-12-15/learning-using-stl-12-std-bind





## std::function

大家都用过函数指针。具体就不赘述了。稍微回忆一下函数指针的语法：

```c++
void(*another_a_ptr_ptr)(void) = (void(*)(void))*(long long*)(*a_ptr);
void(*another_a_ptr_ptr)(void); 这个函数指针的类型是void(*)(void)
```

成员函数指针的用法和声明在杂记2。

**std::function是一个可调用对象包装器，是一个类模板，可以容纳除了类成员函数指针之外的所有可调用对象，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟它们的执行**。







一个例子让你知道`function`怎么用：

```c++
int myfunc(int a){
    cout << a << endl;
    return a;
}

int myfunc1(const int& a){
    cout << a << endl;
    return a;
}

int myfunc2(int&& a){
    cout << a << endl;
    return a;
}

int main(){
    function<int(int)> func = myfunc;
    func(4);

    function<int(const int&)> func1 = myfunc1;
    func1(4);

    function<int(int&&)> func2 = myfunc2;
    func1(4);

    return 0;
}

```

**说白了就是类型是你的函数返回值类型+参数类型。**

我们前面提到过 `bind`的返回值是可调用实体，可以直接赋给`std::function`

```c++
function<void(void)> task1_2 = bind(&my_class::getval, &obj1);
task1_2();

function<void(int)> task2 = bind(&my_class::add, &obj1, placeholders::_1);
task2(5);
```

**有一个问题是，这里必须要显式把对象地址直接塞进去，不能把对象地址用占位符。因为参数对不上了。（个人实验）**

**故而，std::function的作用可以归结于：**

- std::function对C++中各种可调用实体(普通函数、Lambda表达式、函数指针、以及其它函数对象等)的封装，形成一个新的可调用的std::function对象，简化调用；
- std::function对象是对C++中现有的可调用实体的一种类型安全的包裹(如：函数指针这类可调用实体，是类型不安全的)。

# std::call_once 和 std::once_flag

通过`call_in_once`执行的可调用对象可以保证在多线程的状态下仅被（一个线程）执行一次

```c++
once_flag my_flag1; //这个flag是一次性使用的。必须要全局。而且如果有两个东西需要call_once就要两个flag
once_flag my_flag2;
void func1(){
    cout <<"func1" << endl;
}

void func2(int s){
    cout <<"func2" << s << endl;
}
void thread_exe(){
    //once_flag my_flag1; //错误 放在这里就是线程函数的局部变量。这样每个线程就会有自己的flag
    //once_flag my_flag2;
    call_once(my_flag1, func1);
    call_once(my_flag2, func2, 1);
}

int main(){
    thread mythread1(thread_exe);
    thread mythread2(thread_exe);
    mythread1.join();
    mythread2.join();

    return 0;
}
```

注意事项：

- `once_flag`对象对于所有线程来说应该是全局变量（或等同于全局变量的形式）。因为`once_flag`对象只能被使用一次。如果是局部变量，则放在这里就是线程函数的局部变量。这样每个线程就会有自己的`once_flag`对象，就无法起作用。
- 因为每一个`once_flag`对象是一次性的。所以如果有两个东西需要call_once就要两个`once_flag`对象
- 如果某个线程抛出异常，则`call_once`会选择下一个等候的线程重新执行`call_once`动作。

参考：https://blog.csdn.net/qq_31175231/article/details/77916028

https://blog.csdn.net/XJF199001/article/details/51435845

# 异步API。std::future, std::promise, std::packaged_task, std::async

想要进行多线程编程，这四个看起来高级的API是必不可少的。我们来看一看这一套异步编程套组里的四个组件到底有什么关系，他们是干什么的。

参考资料：https://segmentfault.com/a/1190000039201271

https://murphypei.github.io/blog/2019/04/cpp-concurrent-4

## std::future / std::shared_future

< future >头文件功能允许对特定提供者设置的值进行异步访问，可能在不同的线程中。
这些**提供程序**(要么是`promise` 对象，要么是`packaged_task`对象，或者是对异步的调用`async`)与`future`对象共享共享状态:提供者使共享状态就绪的点与`future`对象访问共享状态的点同步。

上面这段话翻译过来就是我们可以理解为future是一个时间胶囊, 一个对象**。这个对象的提供程序（如promise)里面储存了我们希望以后拿到的东西。然后我们用future来和提供程序连接起来，拿到提供程序里面的东西。**

我们看一下future的正式定义和具体细节。

- future 是一个对象，**可以从某个提供对象或函数中检索值**，如果在不同线程中，则可以正确同步此访问。
- 它提供了一种访问异步操作结果的机制。从字面意思上看它表示未来，这个意思就非常贴切，因为它不是立即获取结果但是可以在某个时候以同步的方式来获取结果。我们可以通过查询`future`的状态来获取异步操作的结果。`future_status`有三种状态：
  - `deferred`：异步操作还未开始。共享状态包含一个延迟函数，因此只有在明确请求时才会计算结果。（主要用于`async`函数的`std::launch::deferred`参数。)
  - `ready`：异步操作已经完成
  - `timeout`：异步操作超时。在指定的超时持续时间过去之前，共享状态尚未准备好
- “有效” future 对象，只能通过调用以下函数之一来构造：
  - `async` 
  - `promise::get_future`
  - `packaged_task::get_future`
- 默认构造的 future 对象是无效的（除非移动（move）分配一个有效的 future）。
- 在有效的 future 上调用 `future::get` 会阻塞线程，直到提供程序准备好共享状态（通过设置值或异常）。这样，两个线程可以通过一个线程同步，等待另一个线程设置值。
  - **`get()` 调用会改变其共享状态，不再可用，也就是说 `get()` 只能被调用一次，多次调用会触发异常。如果想要在多个线程中多次获取产出值需要使用 `shared_future`。**
- 共享状态的生存期至少要持续到与之关联的最后一个对象释放它或销毁它为止。因此，如果与 future 相关联，共享状态可以在最初获得它的对象（如果有的话）之后继续存在。

![20190506204825200](/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/20190506204825200.png)



几个函数详解：

### future::valid()

#### 检查有效的共享状态

- 返回 future 对象当前是否与共享状态关联。
- 对于默认构造的 future 对象，此函数返回 false (除非将有效的 future 分配给移动对象)。
- future 只能由某些提供函数（如， async, promise::get_future 或 packaged_task::get_future）使用有效的共享状态进行初始化。
- 一旦使用 future::get 检索了共享状态的值，则调用此函数返回 false (除非移动分配了一个新的 future).

#### 返回值

- 如果对象与共享状态关联，则为 ture。
- 否则为假。

**特别注意。返回值为true不代表此时共享状态已经就绪。只能表明对象与共享状态关联。**

### future::wait

#### 阻塞并等待共享状态就绪（结果可用）



### future::get

可以理解为包含了wait的操作。因为他调用了wait。（猜测）

#### 阻塞并等待共享状态就绪（结果可用），返回存储在共享状态中的值（或引发其异常）

- 当共享状态就绪时，返回存储在共享状态中的值（或引发其异常）。
- **如果共享状态尚未准备好（即提供程序尚未设置其值或异常），则该函数将阻塞调用线程直到准备就绪。在此前，调用了get的函数不会返回。**
- 共享状态就绪后，该函数将取消阻塞并返回（或引发异常）以释放其共享状态。**这时 future 对象不再有效**：**对于每个 future 的共享状态，此成员函数最多应被调用一次**。
- 提供者准备好共享状态和返回此函数之间是同步的。



### shared_future

`std::shared_future` 与 `std::future` 类似，但是 `std::shared_future` 可以拷贝、多个 `std::shared_future` 可以共享某个共享状态的最终结果(即共享状态的某个值或者异常)。**`shared_future` 可以通过某个 `std::future` 对象隐式转换（参见 `std::shared_future` 的构造函数），或者通过 `std::future::share()` 显示转换，无论哪种转换，被转换的那个 std::future 对象都会变为 not-valid**。`std::shared_future` 的成员函数和 `std::future` 大部分相同，这个地方就不一一展开了，需要的请查阅官方文档。



我们可以看到，想要创建一个有效的future对象必须依靠剩下的三个API。我们就来进一步看看剩下的几块内容。

## std::promise

promise是剩下三个当中最为“原始，底层“的API。

**`promise` 本质是一个类似我们打印输出中占位符的东西，你可以理解它就是一个等待数据装填的坑，它是一个“承诺”，承诺未来会有相应的数据（模板实现）**。因为这是一个“承诺”，所以创建的时候是没有东西的，所以我们需要知道这个异步操作什么时候能有东西，好实现“承诺”，所以 `promise` 可以通过调用 `get_future()` 返回一个 `future` 对象，让你去了解这个承诺是否完成了。因此，`promise` 是存放异步操作产出值的坑，而 `future` 是从其中获取异步操作结果，二者都是模板类型。

**这里理解为我们的future对象是一个接口，建立起与promise对象的联系。我们使用promise对象来进行异步操作，所以能看到我们并不需要把future对象传入线程。但是我们会通过future对象去获知这个异步操作的结果是否就绪，也就是promise对象是否已经包含了我们期望的结果。然后我们可以通过future来获取结果。**

- `promise` 是一个对象，由 `future` 对象（可能在另一个线程中）检索，并提供一个同步点。
- 通过调用成员get_future，可以将该共享状态与 future 对象关联。 调用之后，两个对象共享相同的共享状态：
  - promise对象是异步提供程序，应在某个时候为共享状态设置一个值。`set_value`
  - future 对象是一个异步返回对象，可以检索共享状态的值，并在必要时等待其准备就绪。
  - 理解为我们通过promise的get_future来创建我们的future对象。之后通过future对象（来检索）获得一个共享状态（结果）。

![20190506203234388](/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/20190506203234388.png)



### promise::set_value

- **以原子方式**将值存储到共享状态（就是把promise对象储存的值设置好），**并且改变该状态变为就绪状态**。（设置共享状态）
- 如果与同一共享状态关联的future对象当前正在等待对`future::get`的调用，则它将取消阻塞并返回val。
  - 因为future的get/wait会阻塞等待共享状态被设置完毕。



看看简单代码例子：

```c++
//使用promise进行异步
void accumulate2(std::vector<int>::iterator first, //注意不太需要返回值了。因为异步返回的值被储存在了promise对象中
                std::vector<int>::iterator last,
                std::promise<int> accumulate_promise) //函数头要有promise对象定义。
{
    int sum = std::accumulate(first, last, 0);
    accumulate_promise.set_value(sum);  // 将结果存入，并让共享状态变为就绪以提醒future
    //如果不set_value,那么调用了future::get/wait的线程将一直被阻塞。
}
 
int main()
{
    // 演示用 promise<int> 在线程间传递结果。
    std::vector<int> numbers = { 1, 2, 3, 4, 5, 6 };
    std::promise<int> accumulate_promise; //声明promise对象
    std::future<int> accumulate_future(accumulate_promise.get_future()); //通过promise对象的get_future来初始化(获取）future对象
    
    std::thread work_thread(accumulate2, numbers.begin(), numbers.end(),
                            std::move(accumulate_promise)); //启动线程。设置好执行函数和传入参数。注意必须要把promise对象一并传入（移入）
    //!这里也可以用ref。但是我们accumulate2的函数头要了个值。promise又禁用了拷贝构造所以这里目前只可以move。如果accumulate2函数头改为&就可以用ref
    // !可以用ref但是不推荐。因为如果你不转移所有权，万一你多个线程并发访问了promise，可能会有问题，
    !而且这也不符合设计，一般来说只应该让一个线程持有promise
    //accumulate_future.wait();  //等待结果 这个可以去掉，直接用get就可以
    
    std::cout << "result=" << accumulate_future.get() << '\n'; //get阻塞住等待共享对象变为ready。然后获取结果。
    work_thread.join();  //阻塞等待线程执行完成
 
    getchar();
    return 0;
}
```



## std::packaged_task

packaged_task比promise高级一点。直观来看就是参数少一点，操作少一点。稍后我们会有一个简单的对比。

`packaged_task` 是对一个任务的抽象，我们可以给其传递一个函数来完成其构造。相较于 `promise`，它应该算是更高层次的一个抽象，同样地，我们可以将任务投递给任何线程去完成，然后通过 `packaged_task::get_future()` 方法获取的 `future` 对象来获取任务完成后的产出值。总结来说，**`packaged_task` 是连数据操作（比如set_value)都封装进去了的 `promise`**。`packaged_task` 也是一个类模板，模板参数为函数签名，也就是传递函数的类型。

```c++
template <class T> packaged_task;     // undefined
template <class Ret, class... Args> class packaged_task<Ret(Args...)>;
```

- **std::packaged_task包装可调用对象，并允许异步检索其结果。**（可调用对象是重点）
- 类似于 std::function, 但是会自动将其结果传输到 future 对象。
- 对象内部包含两个元素：
  - 存储的任务是一些可调用对象（例如，函数指针，成员或函数对象的指针），其调用签名应采用 Args... 中类型的参数，并返回 Ret 类型的值。
  - 共享状态，该状态能够存储调用存储的任务（类型为 Ret）的结果，并且可以通过 future 来异步访问。
- 通过调用成员 get_future 将共享状态与 future 对象关联。调用之后，两个对象共享相同的共享状态：
  - packaged_task 对象是异步提供程序，通过调用存储的任务，可以在某个时刻将共享状态设置为就绪。
  - future 对象是一个异步返回对象，可以检索共享状态的值，并在必要时等待其准备就绪。

![2019050621124831](/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/2019050621124831.png)

看看代码实例，做一下比较：

```c++
//? 使用packaged_task进行异步
int accumulate(std::vector<int>::iterator first,
                std::vector<int>::iterator last) //注意函数头，我们没有像promise那样需要传入promise对象。
{
    int sum = std::accumulate(first, last, 0);
    return sum;  //所以也不需要promise的set_value
}
 
int main()
{
    // 演示用 packaged_task 在线程间传递结果。
    std::vector<int> numbers = { 1, 2, 3, 4, 5, 6 };
    std::packaged_task<int(std::vector<int>::iterator,std::vector<int>::iterator)> accumulate_task(accumulate);
    //创建packaged_task对象。注意这里有区别，下面详说。
    std::future<int> accumulate_future = accumulate_task.get_future(); //通过packaged_task对象的get_future来创建future对象
    std::thread work_thread(std::move(accumulate_task), numbers.begin(), numbers.end()); //启动线程。注意这里有区别了。
    /*
    @ 使用move的主要原因还有一个就是按值传递函数参数会调用拷贝构造。packaged_task禁用了拷贝构造，要么传引用要么换成右值引用转移所有权。
    */
    //accumulate_future.wait();  //等待结果 可以和下面的get合并
    std::cout << "result=" << accumulate_future.get() << '\n';
    work_thread.join();  //阻塞等待线程执行完成
 
    getchar();
    return 0;
}

```

**我们来说一说几点具体区别**

- 我们提到了，packaged_task包装的是可调用对象。但是promise仅仅是一个包装着异步执行结果的对象。所以：
  - packaged_task对象的模板类型是函数签名，因为他包装了可调用对象。
  - 所以线程执行的时候只需要移入packaged_task对象即可，无需传入函数本身。因为已经被包装了。
  - 所以包装的函数无需额外参数，函数内无需额外动作。
  - 因为promise会储存异步任务的结果，所以函数的返回值可以去掉。
- 其实理解了上面那一点，就理解了packaged_task和promise的区别。可以简单理解为promise是一个包装了执行结果的对象。而packaged_task是一个包装了整个任务的对象，它不仅包装任务执行结果，而且包装任务本身。





## std::async

async是最高级的一个API，代码简单，比较高层。它其实封装了其实是封装了thread 和 packged_task的功能，使异步执行一个任务更为方便

**async是函数，不是类模板。**

```c++
unspecified policy (1)    
template <class Fn, class... Args>
  future<typename result_of<Fn(Args...)>::type>
    async (Fn&& fn, Args&&... args);

specific policy (2)    
template <class Fn, class... Args>
  future<typename result_of<Fn(Args...)>::type>
    async (launch policy, Fn&& fn, Args&&... args);
```

- 异步调用函数在某个时刻调用 fn (以 args 作为参数)，返回时无需等待 fn 执行完成。(都说了是异步)
- **可以通过返回的 future 对象（通过调用其成员 future::get）来访问 fn 返回的值。**
- 第二个版本 （2） 允许调用者选择特定的启动策略，而第一个版本 （1） 使用自动选择，就好像调用 (2) 并将 launch::aysnc | launch::deferred 作为策略。
- 该函数在共享状态下临时存储使用的线程处理程序。一旦完成 fn 的执行，共享状态将包含 fn 返回的值并准备就绪。

| launch::async                     | 启动一个新的线程以调用 fn （就像使用 fn 和 args 作为参数构造线程对象，并访问返回的 future 的共享状态将其联接）`std::thread(std::forward<F>(f), std::forward<Args>(args)...)` |
| --------------------------------- | ------------------------------------------------------------ |
| launch::deferred                  | 意味着函数可能只会在std::async返回的future对象调用get或wait时执行。（函数在future对象调用了get或wait的时候才会开始执行）。**不会产出新的线程。该任务会在调用线程中执行。**。当调用get或wait时，函数会同步执行，即调用者会阻塞直到函数运行结束。如果get或wait没有被调用，函数就绝对不会执行。 |
| launch::async \| launch::deferred | 该功能自动（在某个时候）选择策略。这取决于系统和库的实现，他们通常会针对系统中当前的并发可用性进行优化 |

看一下细节

```c++
//? 使用async进行异步

int accumulate3(std::vector<int>::iterator first, std::vector<int>::iterator last){
    std::cout <<"async begin" << std::endl;
    int sum = std::accumulate(first, last, 0);
    std::cout <<"async end" << std::endl;
    return sum;
}

int main(){
    std::cout <<"main begin" << std::endl;
    std::vector<int> numbers = { 1, 2, 3, 4, 5, 6 };
    std::future<int> accumulate_future = std::async(std::launch::async, accumulate3, numbers.begin(), numbers.end()); //ver1
    std::future<int> accumulate_future = std::async(std::launch::deferred, accumulate3, numbers.begin(), numbers.end()); //ver2
    Sleep(50); //睡眠五秒
    std::cout << "result=" << accumulate_future.get() << '\n';
    std::cout <<"main end" << std::endl;
    return 0;
}
```

```
ver1 输出：
main begin
async begin
async end
result=21
main end

ver2 输出：
main begin
result=async begin
async end
21
main end
```

调用方式和thread很像，没什么区别。没有花里胡哨的东西。但是注意下细节。

1. 在async模式中，一旦开始了调用，则会立刻创建子线程开始任务执行。所以我们看到尽管主线程睡眠了一下，但是并不影响异步线程的执行。所以async begin， async end和result=21是可以打印的。因为get的时候任务已经完成（或者是阻塞至任务完成）。
2. 在deferred模式中，只有get/wait调用的时候任务才开始执行。所以result=先打印出来，然后直到调用get函数的时候，才开始执行任务，任务执行完毕后结果才能拿到，所以会先打印result=, 然后在调用线程（此处是主线程）中执行函数，拿到结果后打印21。



**传参的时候如果需要使用只支持移动的参数比如unique_ptr，则必须使用move显式移动。**

```c++
unique_ptr<int> testfunc(unique_ptr<int> ptr){
    *ptr = *ptr + 1;
    return ptr;
}

int main(){
    unique_ptr<int> myptr = make_unique<int> (5);
    future<unique_ptr<int>> my_future = async(std::launch::async, testfunc, move(myptr)); //显示使用move转移所有权。
    cout << *(my_future.get()) << endl;
    return 0;
}
```



**因为async会创建临时的future对象。如果async函数的返回值没有一个东西接住他，则这个临时对象的析构函数会阻塞住调用线程直至异步线程执行完毕。因为我们不能让异步线程返回值的时候，这个临时对象已经被销毁了。**

例子：

```c++
unique_ptr<int>  testfunc(unique_ptr<int> ptr){
    *ptr = *ptr + 1;
	sleep(5);
    return ptr;
}

int main(){
    unique_ptr<int> myptr = make_unique<int> (5);
	cout << "running" << endl;
    async(std::launch::async, testfunc, move(myptr)); //卡在这里5秒
    cout <<"blocked" << endl;
    return 0;
}
```

这段代码执行的时候，调用线程会由于异步线程没有执行完毕，而卡在async这行。直到异步线程执行完毕后，才会继续输出blocked。

## 杂项

- std::future提供访问异步操作结果的机制。std::future 只能与指定事件相关联，而 std::shared_future 就能关联多个事件。future对象本身并不提供同步访问（需要使用get/wait)。future的get()函数的设计包含移动语义，即只能调用一次，第二次调用时会报异常。shared_future的get()函数的设计包含复制语义，可以多次调用。std::shared_future对象可以通过std::future对象隐式转换，也可以通过显示调用std::future::share显示转换，在这两种情况下，原std::future对象都将变得无效。
- 当不着急让任务结果时，可以使用 std::async 启动一个异步任务。std::async 会返回一个 std::future 对象。get()等价与先调用wait()再调用get()。 std::launch::defered 表明函数调用延迟到wait()或get()函数调用时才执行，std::launch::async 表明函数必须在其所在的独立线程上执行。
- std::packaged_task<> 会将future与函数或可调用对象进行绑定。当 std::packaged_task 作为函数调用时，实参将由函数调用操作符传递至底层函数，并且返回值作为异步结果存储在 std::future 中。
- std::promise/std::future 对提供一种机制：future可以阻塞等待线程，提供数据的线程可以使用promise对相关值进行设置，并将future的状态置为“就绪”。
- 任何情况下，当future的状态还不是“就绪”时，调用 std::promise 或 std::packaged_task 的析构函数，将会存储一个与 std::future_errc::broken_promise 错误状态相关的 std::future_error 异常。
  - 当调用抛出一个异常时，这个异常就会存储到future中，之后调用get()会抛出已存储的异常。
  - std::current_exception() 来检索抛出的异常，可用 std::copy_exception() 作为替代方案， std::copy_exception() 会直接存储新的异常而不抛出。
- 因为 std::future 是只移动的，所以其所有权可以在不同的实例中互相传递，但只有一个实例可以获得特定的同步结果，而 std::shared_future 实例是可拷贝的，所以多个对象可以引用同一关联期望值的结果。
- 当多线程 在没有额外同步的情况下，访问一个独立的 std::future 对象时，就会有数据竞争和未定义的 行为。这是因为： std::future 模型独享同步结果的所有权，并且通过调用get()函数，一次性 的获取数据，这就让并发访问变的毫无意义——只有一个线程可以获取结果值，因为在第一 次调用get()后，就没有值可以再获取了。 
- 在每一个 std::shared_future 的独立对象上成员函数调用返回的结果还是不同步的，所以为 了在多个线程访问一个独立对象时，避免数据竞争，可以使用两种方式：
  - 锁
  - 每一个线程有自己的shared_future对象，然后都通过自己的这个shared_future对象来获取结果。



# atomic , fence 和 内存模型 和 无锁编程

https://youtu.be/ZQFzMfHIxng

## 无锁编程不一定会让程序更快，甚至会有副作用。它并不具有加速行为。

无锁编程不保证性能，不保证程序更快。

## 打算使用无锁编程提升性能之前，先检查其他部分，比如算法。

## std::atomic_flag

`std::atomic_flag` 是原子布尔类型。不同于所有 std::atomic 的特化，**它保证是免锁的**。不同于 `std::atomic<bool>` ， `std::atomic_flag` 不提供加载或存储操作。

`std::atomic_flag`是最简单的原子类型，这个类型的对象可以在两个状态间切换：

- 设置

- 清除



### 默认构造函数

构造一个新`std::atomic_flag`对象，不过未指明状态。这里未指定默认构造出来的`std::atomic_flag`实例是`clear`状态，还是`set`状态（c++20后默认构造函数初始化的状态为clear）。因为对象存储过程是静态的，所以初始化必须是静态的。**`std::atomic_flag` 必须使用`ATOMIC_FLAG_INIT`进行初始化**，这样构造出来的实例状态为`clear`。**另外，`atomic_flag`不能被拷贝，也不能 `move`**

### std::atomic_flag::test_and_set

原子地更改 `std::atomic_flag`的状态为设置（ true ）并返回它先前保有的值。

### std::atomic_flag::clear

原子地更改 `std::atomic_flag`的状态为清除（ false ）。

### std::atomic_flag::wait/notify_one/notify_all

C++20内容

## std::atomic

`std::atomic`模板的每个实例化和专门化都定义了一个原子类型。如果一个线程在另一个线程读取它时写入一个原子对象，那么行为就会被明确定义(参见关于数据竞争的详细信息的内存模型)。此外，对原子对象的访问可以建立线程间的同步，并按照`std::memoryorder`指定非原子性的内存访问。

- `std::atomic`可以用任何简单的可复制的t实例化。同时std::atomic是不可复制的，是不可移动的。

- 注意初始化方式只能使用直接初始化。因为拷贝赋值和拷贝构造被禁用。**这个初始化方式非原子**

  ```c++
  atomic<int> a = 5; //错误
  atomic<int> a(5);
  ```

- 具体特化类型参考https://zh.cppreference.com/w/cpp/atomic/atomic

- 特化成员函数操作，操作符重载加减之类的不讲了。

- **注意原子操作没有乘法和除法**

- 注意带有赋值操作符的时候不能保证整条语句的原子性。
 ```c++
  atomic<int> a(5);
  a = a + 5; //只保证原子读 + 原子写。不能保证原子读+写
 ```

- c++20前，浮点类型不支持自增操作。

- 主 `std::atomic` 模板可用任何满足[*可复制构造* *(CopyConstructible)* ](https://zh.cppreference.com/w/cpp/named_req/CopyConstructible)及[*可复制赋值* *(CopyAssignable)* ](https://zh.cppreference.com/w/cpp/named_req/CopyAssignable)的[*可平凡复制* *(TriviallyCopyable)* ](https://zh.cppreference.com/w/cpp/named_req/TriviallyCopyable)类型 `T` 特化。若下列任何值为 `false` 则程序为非良构：

  - [std::is_trivially_copyable](http://zh.cppreference.com/w/cpp/types/is_trivially_copyable)<T>::value

  - [std::is_copy_constructible](http://zh.cppreference.com/w/cpp/types/is_copy_constructible)<T>::value

  - [std::is_move_constructible](http://zh.cppreference.com/w/cpp/types/is_move_constructible)<T>::value

  - [std::is_copy_assignable](http://zh.cppreference.com/w/cpp/types/is_copy_assignable)<T>::value

  - [std::is_move_assignable](http://zh.cppreference.com/w/cpp/types/is_move_assignable)<T>::value

###  std::atomic<T>::store

```c++
void store( T desired, std::memory_order order = std::memory_order_seq_cst ) noexcept;
```

**原子地**以 `val` 替换当前值。按照 `order` 的值影响内存。`order` 必须是 `std::memory_order_relaxed` 、 `std::memory_order_release` 或 `std::memory_order_seq_cs`t 之一。否则行为未定义。

### std::atomic<T>::load

```c++
T load( std::memory_order order = std::memory_order_seq_cst ) const noexcept;
```

原子地加载并返回原子变量的当前值。按照 `order` 的值影响内存。

`order` 必须是 `std::memory_order_relaxed`、 `std::memory_order_consume` 、 `std::memory_order_acquire` 或 `std::memory_order_seq_cst` 之一。否则行为未定义。

### std::atomic<T>::operator=

等于`store() `注意用法。

```c++
atomic<int> a;
a = 3;
```

**这个等号不是拷贝赋值的那个等号。**

### std::atomic<T>::operator T

等于`load()`

### std::atomic<T>::exchange

```c++
T exchange( T desired, std::memory_order order = std::memory_order_seq_cst )
```

原子地以 `desired` 替换底层值。操作为读-修改-写操作。根据 `order` 的值影响内存。

返回调用前原子对象的值。

### std::atomic<T>::wait/notify_one/notify_all

C++20内容

## 内存模型

### Happens-Before 关系

> A、B 是两个在多核 CPU 上执行的操作。如果 A **happens-before** B，那么 A 所产生的内存变化会在 B 操作执行之前被看到（visible）。

不管我们使用什么编程语言，在同一个线程下的顺序语句总是遵循 happens-before 原则的。

就像下面代码所示：

```cpp
int a, b;

void foo() {
    a = 42;
    b = a;

    assert(b == 42);
}
```

在单线程的情况下，断言是永远不会 为假的。（不然这还怎么写程序...）

但这并不代表 b 在内存中后于 a 被修改。就像下面这段伪代码所示的：

```text
mov 42, %eax
mov %eax, (b)
mov %eax, (a)
```

虽然这并不能说明编译器就是这么处理的，但足以说明程序语义上的 happens-before 不能代表操作是真的 happened before 了。

### Synchronizes-With 关系

这个术语简单来说就是描述了一种方法，能让内存的变化（即便是非原子操作）保证被其他线程看到，这也是实现 **lock-free** 编程模式的基础。

用一段代码来举例：

```cpp
int data;
std::atomic_bool flag { false };

// Execute in thread A
void producer() {
    data = 42;  // (1)
    flag.store(true);  // (2)
}

// Execute in thread B
void consume() {
    while (!flag.load());  // (3)
    assert(data == 42);  // (4)
}
```

让两个函数分别在两个线程中运行，(4) 所示的断言将有一定几率 为假，这是为什么呢？虽然我们使用原子量 flag 作为“同步信号”，而且同一个线程中 happens-before 原则也一定会被遵循，但我们并不能保证 (4) 执行时 (1) 的修改一定会被 B 线程看到, 可能是2-3-4-1这个顺序。这**是由于现代处理器对于程序可能会采取指令重排来提高运行效率，CPU 的读写 Cache 也可能并没有写回内存。**

所以，企图在多线程环境中通过某原子量来做非原子量的 Synchronization 并不是可靠的（当没有 Memory Order 的约束）。

当然，上面的代码在你的机器上可能也不会 为假，因为 C++ 默认使用 **memory_order_seq_cst**顺序约束。而且 x86 架构中也做不到松弛（**memory_order_relaxed**）内存模型。





## 三种模型和六种枚举值

### 顺序一致（sequentially consistent ordering）

- `memory_order_seq_cst`
  - Load/store/RMW操作都可以使用该枚举值，用于 `load operation`（原子读操作）的时候有`acquire operation`的特性，用于` store operation`(原子写操作）的时候有`release operation`的特性, 用于 `read-modify-write operation`（RMW）的时候有`acq_rel operation`的特性，且所有操作都相当于一个双向屏障，**前后语句都不能跨越该操作进行重排**。并且所有线程的语句都以全局的内存修改顺序为参照。


### 获取发布 （release-acquire/consume ordering）

- `memory_order_consume`
  - 类似于`memory_order_acquire`，也是用于`load`操作，但更为宽松。针对于该`load`操作，不允许`load`之后的**有关联（依赖）的**操作重排到`load`之前。

  - `memory_order_consume`适用于`load operation`（原子读操作），对于采用此内存序的`load operation`，我们可以称为`consume operation`(consume原子读操作），设有一个原子变量M上的`consume operation`(consume原子读操作），对周围内存序的影响是：
    - 当前线程中该`consume operation`(consume原子读操作）后的**依赖**该`consume operation`(consume原子读操作）读取的值的写入或读取操作不能被重排到该`consume operation`(consume原子读操作）前，其他线程中所有对M的`release operation`（原子写操作）及其之前的对数据依赖变量的写入都对当前线程从该`consume operation`(consume原子读操作）开始往后的操作可见

    - 相比较于下面讲的`memory_order_acquire`，`memory_order_consume`只是阻止了之后有依赖关系的重排。绝大部分平台上，这个内存序只会影响到编译器优化，依赖于dependency chain。但实际上很多编译器都没有正确地实现consume，导致等同于acquire。

    - 见下图，只有`int r2 = x->i` 是有效的，因为其读取的值依赖原子变量`p`，但`int r1 = A`并不能读到线程1写入到`A`的值，因为`A`值并不依赖`p`。

- `memory_order_acquire`
  - 针对于该`load`操作，不允许`load`之后的操作重排到`load`之前。
  - `memory_order_acquire`适用于`load operation`（原子读操作），对于采用此内存序的`load operation`（原子读操作），我们可以称为`acquire operation`，设有一个原子变量M上的`acquire operation`（原子读操作），对周围内存序的影响是：
    - 当前线程中该`acquire operation`（原子读操作）后的任何内存读写操作都不能被重排到该`acquire operation`（原子读操作）前。
    - 结合下面的`memory_order_release`我们能推导出从而会有其他线程中所有对M的`release operation`（原子写操作）及其之前的写入都对当前线程从该`acquire operation`（原子读操作）开始往后的操作可见。
    - 见下图。线程1写入操作之前的所有操作对于线程2读取后的所有操作可见。


- `memory_order_release`

  - 针对于该`store`操作，不允许`store`之前的操作重排到`store`之后。

    - `memory_order_release`适用于`store operation`（原子写操作），对于采用此内存序的写入操作，我们可以称为`release operation`，设有一个原子变量M上的`release operation`(写入操作），对周围内存序的影响是：

      - 该`release operation`(写入操作）前的内存读写都不能重排到该`release operation`(写入操作）之后。(该`store`操作，不允许`store`之前的操作重排到`store`之后。)结合`memory_order_acquire`的左右从而有：

        - 当前线程截止到该`release operation`（原子写操作）的所有内存写入都对另外线程对M的`acquire operation`（原子读操作）以及之后的内存操作可见，这就是`release acquire` 语义。
        - 当前线程截止到该operation的所有M所依赖的内存写入都对另外线程对M的`consume operation`以及之后的内存操作可见，这就是`release consume`语义。

- `memory_order_acq_rel`

  - 用于RMW(read-modify-write)原子操作，RMW操作前后的语句都不允许跨越该操作而重排。该操作相当于兼具load(acquire)和store(release)，可以看作由这两个操作组成，但是整体上是原子的。
  - `memory_order_acq_rel`适用于`read-modify-write operation`(RMW操作)，对于采用此内存序的`read-modify-write operation`，我们可以称为`acq_rel operation`，既属于`acquire operation` 也是`release operation`. 设有一个原子变量M上的`acq_rel operation`：自然的，因为同时具有两种属性，所以该`acq_rel operation`之前的内存读写都不能重排到该`acq_rel operation`之后，该`acq_rel operation`之后的内存读写都不能重排到该`acq_rel operation`之前. 其他线程中所有对M的`release operation`(写入操作）及其之前的写入都对当前线程从该`acq_rel operation`开始的操作可见，并且截止到该`acq_rel operation`的所有内存写入都对另外线程对M的`acquire operation`（原子读操作）以及之后的内存操作可见。

### 宽松（relaxed ordering ）

- `memory_order_relaxed`
  - 对于其它读写操作没有任何同步和重排的限制，仅要求保证读写的原子性和内存一致性。除此之外，不提供任何跨线程的同步。
  - 一般应用于计数器场景

```c++
// Thread 1:
r1 = y.load(std::memory_order_relaxed); // A
x.store(r1, std::memory_order_relaxed); // B
// Thread 2:
r2 = x.load(std::memory_order_relaxed); // C 
y.store(42, std::memory_order_relaxed); // D
```

执行完上面的程序，可能出现`r1 == r2 == 42`。理解这一点并不难，因为编译器允许调整 C 和 D 的执行顺序。如果程序的执行顺序是 D -> A -> B -> C，那么就会出现`r1 == r2 == 42`。





| 操作              | 有效的Memory order枚举值                                     | 备注                                                         |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Load              | `memory_order_relaxed`, `memory_order_consume`, `memory_order_acquire`, `memory_order_seq_cst` | 其它枚举值不合法， MS STL的实现是将其当作memory_order_seq_cst处理 |
| Store             | `memory_order_relaxed`, `memory_order_release`, `memory_order_seq_cst` | 同上                                                         |
| read-modify-write | `memory_order_relaxed`, `memory_order_consume`, `memory_order_acquire`, `memory_order_release`, `memory_order_acq_rel`, `memory_order_seq_cst` |                                                              |

参考资料：https://zhuanlan.zhihu.com/p/382372072?utm_id=0

https://blog.csdn.net/wxj1992/category_11580766.html





![QQ截图20220909144257](/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220909144257.png)

### 这里所谓的指定内存序，**指的是对执行语句所在的线程内部的限制，也就是之影响一个cpu核心，但是这些对单线程内部的限制组合起来就能实现多线程之间数据同步的效果**，







## atomic_thread_fence分类和效果

在C++ 11及之后的标准里，除了利用原子操作指定内存序，还定义了单独使用memory fence（`std::atomic_thread_fence`）的方式，fence可以和原子操作组合进行同步，也可以fence之间进行同步，fence不光可以不依赖原子操作进行同步，而且相比较于同样memory order的原子操作，具有更强的内存同步效果

和`atomic`变量类似，`atomic_thread_fence`也可以指定六种内存序，指定不同内存序的fence可以分为以下几类：
（1） `std::atomic_thread_fence(memory_order_relaxed)`，没有任何效果。
（2） `std::atomic_thread_fence(memory_order_acquire)` 和 `std::atomic_thread_fence(memory_order_consume)` 属于acquire fence。
（3）`std::atomic_thread_fence(memory_order_release)`属于release fence。
（4）`std::atomic_thread_fence(memory_order_acq_rel)`既是acquire fence 也是release fence，为了方便这里称为full fence。
（5）`std::atomic_thread_fence(memory_order_seq_cst)`额外保证有单独全序的full fence。

也就是说，如果不考虑单独全序，那么有release fence、acquire fence 和full fence三种。下面就根据以前介绍过的四种重排来介绍下这三种fence的效果。

不同类型的Fence对于乱序的保护是不一样的。我们可以将读和写的交错分成下面四种情况：

- Load-Load：读接着读
- Load-Store：先读后写
- Store-Load：先写后读
- Store-Store：写接着写

### release fence

- `Release fence`可以防止fence前的内存操作重排到fence后的任意store（写入）之后，即阻止load-store重排和store-store重排。（**阻止了所有在它之前的读写操作和在它之后的写操作乱序**）



![QQ截图20220909153644](/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220909153644.png)



### acquire fence

- `acquire fence`可以防止fence后的内存操作重排到fence前的任意load（读取）之前，即阻止load-load重排和load-store重排。（**阻止了所有在它之前的读操作与在它之后的读写操作乱序。**）

![QQ截图20220909153840](/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220909153840.png)

### full fence

- 因为`full fence`是release fence和acquire fence的组合，所以也就是防止load-load、load-store、store-store重排



![QQ截图20220909154223](/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220909154223.png)





### C++标准中，三种fence不禁止store-load（先写后读）的重排。

即便是`std::atomic_thread_fence(memory_order_seq_cst)`也一样，只是需要额外保证单独全序，**但是在实际的实现上为了实现这个全序编译器大都是采用了硬件层面的能够阻止storeload重排的full barrier指令**


参考资料：

https://paul.pub/cpp-memory-model/

https://blog.csdn.net/wxj1992/article/details/103917093
