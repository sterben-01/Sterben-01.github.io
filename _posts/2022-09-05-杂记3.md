---
title: C++杂记 - 3
date: 2022-07-20 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true
  
---



# C++杂记 - 3

# `std::bind`, `std::function` 和 `std::mem_fn`

## std::bind 包括但不限于mem_fn的功能，更为通用的解决方案

**什么是bind？我们可以把它看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。**

std::bind将可调用对象与其参数一起进行绑定**，绑定后的结果可以使用std::function保存**。std::bind主要有以下两个作用：

- 将可调用对象和其参数绑定成一个仿函数；
- 只绑定部分参数，减少可调用对象传入的参数。

语法：

```c++
auto newCallable = bind(callable, arg_list);
```

该形式表达的意思是：当调用`newCallable`时，会调用`callable`，并传给它`arg_list`中的参数。

需要注意的是：`arg_list`中的参数可能包含形如`_n`的名字。其中`n`是一个整数，这些参数是占位符，表示`newCallable`的参数，它们占据了传递给`newCallable`的参数的位置。数值`n`表示生成的可调用对象中参数的位置：`_1`为`newCallable`的第一个**待填充**参数，`_2`为第二个**待填充**参数，以此类推。
注意这些占位符在`std::placeholders`名称空间内。

- **std::bind的返回值是可调用实体，可以直接赋给std::function**。

- **bind绑定类非静态成员函数时，第一个参数表示对象的成员函数的指针，第二个参数表示对象的地址，这是因为对象的成员函数需要有this指针**。并且编译器不会将对象的成员函数隐式转换成函数指针，需要通过&手动转换（符合成员函数指针的赋值语法）。静态成员函数无需此操作。因为没有this指针。

```c++
class my_class{
    public:
    int val;
    my_class(int x):val(x){}

    void getval(){
        cout << val << endl;
    }
    void add(int another){
        val = val + another;
        cout << val << endl;
    }
    static void staticfunc(int val){
        cout << "static" << val << endl;
    }
};
int main(){
    my_class obj1(10);
    auto task2 = bind(&my_class::getval, &obj1); 	//调用无参函数，this参数预绑定。成员函数指针遵循语法。
    auto task3 = bind(&my_class::add, &obj1, placeholders::_1);	//调用有参函数，this参数预绑定。
    auto task4 = bind(&my_class::add, placeholders::_1, placeholders::_2); //调用有参函数，this参数使用占位形式。
    auto task5 = bind(&my_class::staticfunc, placeholders::_1); //静态成员函数没有this指针。无需传入。
    task2();
    task3(3); 
    task4(&obj1, 3); //this使用占位形式，需要调用时传入。
    task5(3);
    return 0;
}
```



 ## mem_fn 成员函数适配器 把成员函数转为函数对象，使用对象指针或对象(引用)进行绑定

**个人实验得出的结论：`mem_fn`是`bind`的子集**。

注意`mem_fn`不能调用类静态成员函数。因为没有this指针。

`mem_fn`就是强制给你把类对象塞进去。

比较：

```c++
class my_class{
    public:
    int val;
    my_class(int x):val(x){}

    void getval(){
        cout << val << endl;
    }
    void add(int another){
        val = val + another;
        cout << val << endl;
    }
    static void staticfunc(int val){
        cout << "static" << val << endl;
    }
};
int main(){
    my_class obj1(10);

    auto task1 = mem_fn(&my_class::getval); 
    task1(&obj1); //把对象地址传入

    auto task2 = mem_fn(&my_class::add);
    task2(&obj1, 5);

    //auto task3 = mem_fn(&my_class::staticfunc); 错误！静态成员函数不行。

    auto task1_1 = bind(&my_class::getval, placeholders::_1); //bind就得多写个参数
    task1_1(&obj1);
    
    auto task1_2 = bind(&my_class::getval, &obj1);
    task1_2();

    return 0;
}
```






## std::placeholders

我们提到了，我们使用`bind`的时候，`placeholder`是待填充参数。什么叫待填充？这是一种具象解释。其实它相当于生成了一个新的可调用对象，拥有两个参数。但是结合原本的可调用对象来看，我们有三个参数。所以站在原本的可调用对象角度来看，相当于待填充。

语法和例子：

```c++
void testfunc(int x, int y, int z){
    cout << x << endl;
    cout << y << endl;
    cout << z << endl;
}
int main(){

    auto callable1 = bind(testfunc, placeholders::_1, placeholders::_2, 5);
    callable1(8,80);
    //输出8 80 5
    auto callable2 = bind(testfunc, placeholders::_2, placeholders::_1, 5);
    callable2(8,80);
    //输出80 8 5

    auto callable3 = bind(testfunc, placeholders::_1, 5, placeholders::_2);
    callable3(8,80);
    //输出8 5 80
    auto callable4 = bind(testfunc, placeholders::_1, 5, placeholders::_3); //错误。新的调用对象只有两个参数。这里3超了。
    callable4(8,80);
    
    auto callable5 = bind(testfunc, placeholders::_1, 5, placeholders::_1); //极端情况。占位符可以重复。
    callable5(8);
    //输出8 5 8
}
```



参考资料：https://elloop.github.io/c++/2015-12-15/learning-using-stl-12-std-bind





## std::function

大家都用过函数指针。具体就不赘述了。稍微回忆一下函数指针的语法：

```c++
void(*another_a_ptr_ptr)(void) = (void(*)(void))*(long long*)(*a_ptr);
void(*another_a_ptr_ptr)(void); 这个函数指针的类型是void(*)(void)
```

成员函数指针的用法和声明在杂记2。

**std::function是一个可调用对象包装器，是一个类模板，可以容纳除了类成员函数指针之外的所有可调用对象，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟它们的执行**。







一个例子让你知道`function`怎么用：

```c++
int myfunc(int a){
    cout << a << endl;
    return a;
}

int myfunc1(const int& a){
    cout << a << endl;
    return a;
}

int myfunc2(int&& a){
    cout << a << endl;
    return a;
}

int main(){
    function<int(int)> func = myfunc;
    func(4);

    function<int(const int&)> func1 = myfunc1;
    func1(4);

    function<int(int&&)> func2 = myfunc2;
    func1(4);

    return 0;
}

```

**说白了就是类型是你的函数返回值类型+参数类型。**

我们前面提到过 `bind`的返回值是可调用实体，可以直接赋给`std::function`

```c++
function<void(void)> task1_2 = bind(&my_class::getval, &obj1);
task1_2();

function<void(int)> task2 = bind(&my_class::add, &obj1, placeholders::_1);
task2(5);
```

**有一个问题是，这里必须要显式把对象地址直接塞进去，不能把对象地址用占位符。因为参数对不上了。（个人实验）**

**故而，std::function的作用可以归结于：**

- std::function对C++中各种可调用实体(普通函数、Lambda表达式、函数指针、以及其它函数对象等)的封装，形成一个新的可调用的std::function对象，简化调用；
- std::function对象是对C++中现有的可调用实体的一种类型安全的包裹(如：函数指针这类可调用实体，是类型不安全的)。

# std::call_once 和 std::once_flag

通过`call_in_once`执行的可调用对象可以保证在多线程的状态下仅被（一个线程）执行一次

```c++
once_flag my_flag1; //这个flag是一次性使用的。必须要全局。而且如果有两个东西需要call_once就要两个flag
once_flag my_flag2;
void func1(){
    cout <<"func1" << endl;
}

void func2(int s){
    cout <<"func2" << s << endl;
}
void thread_exe(){
    //once_flag my_flag1; //错误 放在这里就是线程函数的局部变量。这样每个线程就会有自己的flag
    //once_flag my_flag2;
    call_once(my_flag1, func1);
    call_once(my_flag2, func2, 1);
}

int main(){
    thread mythread1(thread_exe);
    thread mythread2(thread_exe);
    mythread1.join();
    mythread2.join();

    return 0;
}
```

注意事项：

- `once_flag`对象对于所有线程来说应该是全局变量（或等同于全局变量的形式）。因为`once_flag`对象只能被使用一次。如果是局部变量，则放在这里就是线程函数的局部变量。这样每个线程就会有自己的`once_flag`对象，就无法起作用。
- 因为每一个`once_flag`对象是一次性的。所以如果有两个东西需要call_once就要两个`once_flag`对象
- 如果某个线程抛出异常，则`call_once`会选择下一个等候的线程重新执行`call_once`动作。

参考：https://blog.csdn.net/qq_31175231/article/details/77916028

https://blog.csdn.net/XJF199001/article/details/51435845
