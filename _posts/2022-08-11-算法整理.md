---
title: 算法相关
date: 2022-07-20 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true
  
---



# 时间复杂度

时间复杂度主要就是看基本操作是啥，然后基本操作要进行几次

## O1

```c++
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

这代码操作都是执行一次。

## On

```c++
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

我们能看到，for循环的代码会执行n次。所以消耗的时间是随着n变化而变化。所以是On

**二叉树的遍历就是On，因为每个节点访问一次**

## O logN

```c++
int i = 1;
while(i<n)
{
    i = i * 2;
}
```

我们看到，while循环的i虽然随着n变化而变化，但是每次i是指数增长。所以复杂度也就是对数。

## O NlogN

```c++
for(m=1; m<n; m++)
{
    i = 1;
    while(i<n)
    {
        i = i * 2;
    }
}
```

我们看到，外层for循环时间随着n改变，所以是On。内层i每次是指数增长，所以是对数复杂度。所以是NlogN

## O n^2

```c++
for(x=1; i<=n; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
```

俩循环嵌套



# 空间复杂度

就是看开辟空间了没有。

比如二叉树遍历，如果要记录节点，所以开辟额外空间的空间复杂度是N。递归调用栈深度是树的高度。树的高度是logn因为每一层节点翻倍。

所以如果包含额外空间，则递归调用遍历二叉树节点并储存的话是O N+logN，（N是保存节点，logN是调用栈深度, 保存节点的数量和栈深度没有关联，所以不是nlogn, 而是n+logn）

如果不看这个储存的节点的空间，就是单纯的O logN

