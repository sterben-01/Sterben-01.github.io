---
title: 算法相关
date: 2022-07-20 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true
  
---



# 时间复杂度

时间复杂度主要就是看基本操作是啥，然后基本操作要进行几次

## O1

```c++
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

这代码操作都是执行一次。

## On

```c++
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

我们能看到，for循环的代码会执行n次。所以消耗的时间是随着n变化而变化。所以是On

**二叉树的遍历就是On，因为每个节点访问一次**

## O logN

```c++
int i = 1;
while(i<n)
{
    i = i * 2;
}
```

我们看到，while循环的i虽然随着n变化而变化，但是每次i是指数增长。所以复杂度也就是对数。

## O NlogN

```c++
for(m=1; m<n; m++)
{
    i = 1;
    while(i<n)
    {
        i = i * 2;
    }
}
```

我们看到，外层for循环时间随着n改变，所以是On。内层i每次是指数增长，所以是对数复杂度。所以是NlogN

## O n^2

```c++
for(x=1; i<=n; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
```

俩循环嵌套



# 空间复杂度

就是看开辟空间了没有。

比如二叉树遍历，如果要记录节点，所以开辟额外空间的空间复杂度是N。递归调用栈深度是树的高度。树的高度是logn因为每一层节点翻倍。

所以如果包含额外空间，则递归调用遍历二叉树节点并储存的话是O N+logN，（N是保存节点，logN是调用栈深度, 保存节点的数量和栈深度没有关联，所以不是nlogn, 而是n+logn）

如果不看这个储存的节点的空间，就是单纯的O logN

# 堆排序

就是排序一个堆。

最大堆和最小堆只保证父节点比子节点大或者小，他不保证子节点的绝对顺序。

把数据组织成一个最大堆或者最小堆。然后整个堆都是待排序状态。

这时候把堆顶的数（一定是最大的或者是最小的）和最后一个节点的数交换(或者是直接拿出来)。

交换后整个堆的顺序会被破坏，所以需要重新调整以符合最大堆/最小堆定义。然后重复交换-》拿出-》排序的过程。

# STL的sort

复合排序

- 在数据量很大时采用正常的快速排序，此时效率为O(logN)。
- 一旦分段后的数据量小于某个阈值，就改用插入排序，因为此时这个分段是基本有序的，这时效率可达O(N)。
- 在递归过程中，如果递归层次过深，分割行为有恶化倾向时，它能够自动侦测出来，使用堆排序来处理，在此情况下，使其效率维持在堆排序的O(N logN)，但这又比一开始使用堆排序好。

https://feihu.me/blog/2014/sgi-std-sort/#stdsort%E9%80%82%E5%90%88%E5%93%AA%E4%BA%9B%E5%AE%B9%E5%99%A8

# 排序算法稳定性

## 稳定的算法：

- 插入排序
- 冒泡排序
- 归并排序



## 快速排序

找到一个pivot，比如数组中间的值。从左往右找，在左边找到第一个比中间的值大的，在右边找到第一个比中间值小的，他俩交换。直到左侧的都比中间值小，右侧的都比中间值大。然后进行递归分别处理左侧的和右侧的。

- 注意我们写法的递归操作，是`start,right` 和 `left, end`。因为我们一定会走到两个下标相等的部分。也就是left = right。也就是刚好处于pivot的位置。然后我们会把left+1， right - 1。这样一来，right就跑到了左边，left就跑到了右边。



## 归并排序

归并排序的过程：

- **必须创建一个额外空间的数组。这也是归并稳定的原因**
- 递归把数组切成两个的大小
- 然后对这个大小为2的数组进行排序
- 这个数组排序完成后，对下一个大小为2的数组进行排序
- 然后对这两个大小为2的数组进行排序
- .....

具体的排序过程：

- 我们有我们的额外数组。
- 在原数组中选择中间值。
- 使用双指针法，两个指针分别指向第一个元素和中间值后的第一个元素。
- 如果第一个元素比中间值后的第一个元素大，那么把这个元素放到额外数组。反之亦然。
- 如果原数组当中的左半部分和右半部分（中间值后面的部分）有未遍历完的，则原样复制到额外数组。
- 把额外数组的值赋值回原数组。
  - 此处必须格外注意。把额外数组赋值回原数组，起始位置和结束为止是函数的入参。不是从0开始。因为接下来排序整个原数组的后半部分的时候，前半部分已经是相对有序的了。



```python
self.merge_sort(a, 0, 7, temparr)                           |1

        self.merge_sort(a, 0, 3, temparr)  # left               |2
        
            self.merge_sort(a, 0, 1, temparr)  # left               |3
                self.merge_sort(a, 0, 0, temparr)  # left               |4
                self.merge_sort(a, 1, 1, temparr)  # right              |4
                self.sort(a, 0, 1, temparr)  # sort                     |4
                
            self.merge_sort(a, 2, 3, temparr)  # right              |3
                self.merge_sort(a, 2, 2, temparr)  # left               |4
                self.merge_sort(a, 3, 3, temparr)  # right              |4
                self.sort(a, 2, 3, temparr)  # sort                     |4
                
            self.sort(a, 0, 3, temparr)  # sort                     |3
            
        self.merge_sort(a, 4, 7, temparr)  # right              |2
            self.merge_sort(a, 4, 5, temparr)  # left               |3
                self.merge_sort(a, 4, 4, temparr)  # left               |4
                self.merge_sort(a, 5, 5, temparr)  # right              |4
                self.sort(a, 4, 5, temparr)  # sort                     |4
                
            self.merge_sort(a, 6, 7, temparr)  # right              |3
                self.merge_sort(a, 6, 6, temparr)  # left               |4
                self.merge_sort(a, 7, 7, temparr)  # right              |4
                self.sort(a, 6, 7, temparr)  # sort                     |4
                
            self.sort(a, 4, 7, temparr)  # sort                     |3
            
        self.sort(a, 0, 7, temparr)  # sort                     |2

```

