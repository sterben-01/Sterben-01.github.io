---
title: 计算机网络 - 传输层1
date: 2022-06-23 08:55:00 -0500
categories: [笔记]
tags: [计算机网络]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true

---

# 计算机网络 - 传输层1



## 传输层

### 传输层的功能

1. 传输层提供**进程与进程**之间的逻辑通信。使用网络层的服务为应用层提供通信服务
2. 复用和分用

   - 复用：应用层所有的应用进程都可以通过传输层传输到网络层。
- 分用：传输层从网络层收到的数据可以交付给不同的应用进程。

3. 对收到的报文进行差错检测



## TCP

### 三次握手![QQ截图20220623022220](/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220623022220.png)

 **`ACK不消耗seq`**，所以如果自己的上一个包是`ACK`的话（报文不携带数据），这次的`seq`还是上次的`seq`

**图里说的上一次自己是ACK则这次seq就是上一次的seq，指的是纯ACK包。也就是报文不传输数据的时候**

这里`ack = seq + 1` 里面的1其实是接收到的数据的大小。 但是握手阶段不存在这个数据，为了更好理解为何握手/挥手阶段`seq/ack`还是要`+1`，我们统一给她一个解释：这个握手阶段除了`ack`以外的包所搭载的数据叫ghost byte，大小为1。第二种解释是数据大小依旧为0。但是FIN/SYN按照一个字节算。所以+1 

`ack`确认号是我们下一次希望收到的发送数据的第一个字节的序号 。当丢包发生的时候。`ack`确认号就是接收方所期待的是序号最小的没拿到的数据包。所以这种确认机制可以实现累计确认。

所以在**握手阶段** 我们客户端首次发送的`seq = x`，则我们下一次希望收到的发送数据的第一个字节的序号 应为`x+1`  所以服务器发回的`ack = x + 1`

所以`ack`计算方式是 `ack(out) = seq(last_time_in) + size_of_received_data + (in)SYN/FIN(1)`

` seq`序列号是本次所发送数据的第一个字节的序号。假如我们发送 `1 2 3` 所以`seq`为`1` 接着我们发送`4 5 6 `所以`seq`为`4 `也就是`上一次序号+上一次自己的数据量 = 1 + 3 = 4`

`seq`的计算方式是 `seq(out) = 上一次自己的seq + 上一次自己的size_of_data + 上一次自己的SYN/FIN(1)`

**一般来讲，对方发回的`ack`就是自己下一次的`seq`**  。

因为采用了延迟确认，客户端连续多次发送数据后，服务器传回的`ack`将会是最后一次接收到的客户端报文的`seq + 收到的data`。如下图。最后一次接收到的`seq`是5121，证明5121之前的数据包都拿到了，大小是1024。所以截止至客户端新发送数据之前，服务器回复的每一次`ack`都是`5121+1024 = 6145`

![QQ截图20220623195418](/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220623195418.png)








### 延迟确认
简单的说，Delay Ack就是延时发送ACK，在收到数据包的时候，会检查是否需要发送ACK，如果需要的话，进行快速ACK还是延时ACK，在无法使用快速确认的条件下，就会使用Delay Ack。

TCP在何时发送ACK的时候有如下规定：

1.当有响应数据发送的时候，ACK会随着数据一块发送

2.如果没有响应数据，ACK就会有一个延迟，以等待是否有响应数据一块发送，但是这个延迟一般在40ms~500ms之间，一般情况下在40ms左右，如果在40ms内有数据发送，那么ACK会随着数据一块发送，对于这个延迟的需要注意一下，这个延迟并不是指的是收到数据到发送ACK的时间延迟，而是内核会启动一个定时器，每隔200ms就会检查一次，比如定时器在0ms启动，200ms到期，180ms的时候data来到，那么200ms的时候没有响应数据，ACK仍然会被发送，这个时候延迟了20ms.

3.如果在等待发送ACK期间，第二个数据又到了，这时候就要立即发送ACK！

优点：减少了数据段的个数，提高了发送效率

缺点：过多的delay会拉长RTT




### 四次挥手

![QQ截图20220623024124](/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220623024124-16559727402733.png)





- 当客户端发送链接释放报文段之后，客户端停止发送数据。主动关闭TCP链接。也就是第一次FIN。之后客户端进入 `FIN_WAIT_1` 状态。
- 服务器接受到客户端发送的释放报文段后，回送一个ack报文段。客户到服务器的这个方向的连接也就被释放了。此时是**半关闭状态**。服务端进入 `CLOSED_WAIT` 状态。
- 客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。
- 服务器发送/处理完剩余数据后，也发送链接释放报文段。主动关闭TCP链接。也就是第二次FIN。之后服务端进入 `LAST_ACK` 状态。
- 客户端接受到后，回送一个ack报文段。进入 `TIME_WAIT` 状态。服务器收到了 `ACK` 应答报文后，就进入了 `CLOSED` 状态，至此服务端已经完成连接的关闭。再等到时间等待计时器设置的2MSL（最长报文段寿命）后，客户端进入 `CLOSED` 状态，链接彻底关闭。

如果客户端发送的确认报文段

### 注意事项

1. 主动关闭连接的，才有 `TIME_WAIT 状态`。
2. 四次挥手之所以为四次就是因为可以半关闭状态。也就是服务器可能还要发送一些数据给客户端。理论上四次挥手也可以换成三次。如果服务器在收到客户端的 `FIN` 时没有更多数据或根本没有数据要发送，则可以将 ack 和 fin 合并为一个包。
3. 需要三次握手而不是两次握手的原因之一是：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。
   - 假设客户端先发了一个序列号为90的`SYN`请求报文, 但是它在网络中某个节点被阻塞了, 然后客户端又发送了另一个新的`SYN`请求报文, 序列号为100, 但是旧的请求报文比新的先到达服务端, 然后服务端回返回一个`SYN ACK`报文, 其中`ACK`确认号为91, 这显然是错的, 客户端收到该`ACK`报文之后, 发现确认号为91而不是101, 判定这是一个历史连接, 客户端就发送一个`RST`报文回去告知服务端, 终止这次连接。
4. **在连接建立后，所有传送的报文段都必须把ACK置为1。**
5. TCP **不会为没有数据的`ACK`**包进行重传。**当没有数据的`ACK` 包丢失了，就由对方重传对应的报文**。
6. 握手阶段的前两次不可以携带数据。第三次`ACK`可以携带数据。也就是`SYN=1`的报文段不可以携带数据。

## 握手丢失会发生什么？

### 第一次握手丢失了，会发生什么？

客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 `SYN_SENT` 状态。

在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文。

不同版本的操作系统可能超时时间不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。

当客户端在 1 秒后没收到服务端的 SYN-ACK 报文后，客户端就会重发 SYN 报文，那到底重发几次呢？

在 Linux 里，客户端的 SYN 报文最大重传次数由 `tcp_syn_retries`内核参数控制，这个参数是可以自定义的，默认值一般是 5。

通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，**每次超时的时间是上一次的 2 倍**。

当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。

所以，总耗时是 1+2+4+8+16+32=63 秒，大约 1 分钟左右。

### 第二次握手丢失了，会发生什么？

当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 `SYN_RCVD` 状态。

第二次握手的 `SYN-ACK` 报文其实有两个目的 ：

- 第二次握手里的 ACK， 是对第一次握手的确认报文；
- 第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；

所以，如果第二次握手丢了，就会发送比较有意思的事情，具体会怎么样呢？

因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是**客户端就会触发超时重传机制，重传 SYN 报文**。

然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。

那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是**服务端这边会触发超时重传机制，重传 SYN-ACK 报文**。

在 Linux 下，SYN-ACK 报文的最大重传次数由 `tcp_synack_retries`内核参数决定，默认值是 5。

因此，当第二次握手丢失了，客户端和服务端都会重传：

- 客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 `tcp_syn_retries`内核参数决定；
- 服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 `tcp_synack_retries` 内核参数决定。



### 第三次握手丢失了，会发生什么？

客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 `ESTABLISH` 状态。

因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。







## 挥手丢失会发生什么？

### 第一次挥手丢失了，会发生什么？

当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 `FIN_WAIT_1` 状态。

正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 `FIN_WAIT2`状态。

如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 `tcp_orphan_retries` 参数控制。

当客户端重传 FIN 报文的次数超过 `tcp_orphan_retries` 后，就不再发送 FIN 报文，直接进入到 `close` 状态。

### 第二次挥手丢失了，会发生什么？

当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 `CLOSE_WAIT` 状态。

在前面我们也提了，ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。

这里提一下，当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 `FIN_WAIT2` 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。

对于 close 函数关闭的连接，由于无法再发送和接收数据，所以`FIN_WAIT2` 状态不可以持续太久，而 `tcp_fin_timeout` 控制了这个状态下连接的持续时长，默认值是 60 秒。

**这意味着对于调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭。**

但是注意，如果主动关闭方使用 shutdown 函数关闭连接且指定只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 `FIN_WAIT2` 状态（`tcp_fin_timeout` 无法控制 shutdown 关闭的连接）。

### 第三次挥手丢失了，会发生什么？

当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 `CLOSE_WAIT` 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。

此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。

服务端处于` CLOSE_WAIT `状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 `LAST_ACK` 状态，等待客户端返回 ACK 来确认连接关闭。

如果客户端迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 `tcp_orphan_retrie`s 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。

### 第四次挥手丢失了，会发生什么？

当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 `TIME_WAIT` 状态。

在 Linux 系统，`TIME_WAIT` 状态会持续 2MSL 后才会进入关闭状态。

然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于` LAST_ACK` 状态。

如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 `tcp_orphan_retries` 参数控制。







## 关于 TIME_WAIT 

### 为什么 TIME_WAIT 等待的时间是 2MSL？

`MSL` 是 Maximum Segment Lifetime，**报文最大生存时间**，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 `TTL` 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。

MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 **MSL 应该要大于等于 TTL 消耗为 0 的时间**，以确保报文已被自然消亡。

**TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了**。

TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以**一来一回需要等待 2 倍的时间**。

比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 `FIN` 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。

可以看到 **2MSL时长** 这其实是相当于**至少允许报文丢失一次**。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。

`2MSL` 的时间是从**客户端接收到 FIN 后发送 ACK 开始计时的**。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 **2MSL 时间将重新计时**。

在 Linux 系统里 `2MSL` 默认是 `60` 秒，那么一个 `MSL` 也就是 `30` 秒。**Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒**。





### 为什么需要 TIME_WAIT 状态？

需要 TIME-WAIT 状态，主要是两个原因：

- 防止历史连接中的数据，被后面相同四元组的连接错误的接收。

  服务端在关闭连接之前发送的报文，被网络延迟了。接着，服务端以相同的四元组重新打开了新连接，前面被延迟的报文这时抵达了客户端，而且该数据报文的序列号刚好在客户端接收窗口内，因此客户端会正常接收这个数据报文，但是这个数据报文是上一个连接残留下来的，这样就产生数据错乱等严重的问题。为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，因此 TCP 设计了 TIME_WAIT 状态，状态会持续 `2MSL` 时长，这个时间**足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。**

- 保证「被动关闭连接」的一方，能被正确的关闭

  如果客户端（主动关闭方）最后一次 ACK 报文（第四次挥手）在网络中丢失了，那么按照 TCP 可靠性原则，服务端（被动关闭方）会重发 FIN 报文。假设客户端没有 TIME_WAIT 状态，而是在发完最后一次回 ACK 报文就直接进入 CLOSED 状态，如果该 ACK 报文丢失了，服务端则重传的 FIN 报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN 报文后，就会回 RST 报文。服务端收到这个 RST 并将其解释为一个错误（Connection reset by peer），这对于一个可靠的协议来说不是一个优雅的终止方式。

  为了防止这种情况出现，客户端必须等待足够长的时间确保对端收到 ACK，如果对端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL 的时间。





### 半连接队列和全连接队列

在服务端当中，对socket执行bind方法可以绑定监听端口，然后执行`listen方法`后，就会进入监听（`LISTEN`）状态。内核会为每一个处于`LISTEN`状态的`socket` 分配两个队列，分别叫**半连接队列和全连接队列**。

![QQ截图20220629093515](/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220629093515.png)





- **半连接队列（SYN队列）**，服务端收到**第一次握手**后，会将`这个连接对应的文件描述符`加入到这个队列中，队列内的`文件描述符对应的连接`都处于`SYN_RCVD` 状态。
- **全连接队列（ACCEPT队列）**，在服务端收到**第三次握手**后，会将半连接队列的`文件描述符`取出，放到全连接队列中。队列里的`文件描述符对应的连接`都处于 `ESTABLISHED`状态。这里面的文件描述符，就**等着服务端执行accept()后被取出了。**

**全连接队列（`icsk_accept_queue`）是个链表**，而**半连接队列（`syn_table`）是个哈希表**。

所以建立连接的过程中根本不需要`accept()` 参与， **执行accept()只是为了从全连接队列里取出对应的文件描述符。**

**`listen`函数的`backlog`控制的是全连接队列（ACCEPT队列）队列的大小。**

#### 为什么半连接队列要设计成哈希表

先对比下**全连接里队列**，他本质是个链表，因为也是线性结构，说它是个队列也没毛病。它里面放的都是已经建立完成的连接，这些连接正等待被取走。而服务端取走连接的过程中，并不关心具体是哪个连接，只要是个连接就行，所以直接从队列头取就行了。这个过程算法复杂度为`O(1)`。

而**半连接队列**却不太一样，因为队列里的都是不完整的连接，嗷嗷等待着第三次握手的到来。那么现在有一个第三次握手来了，则需要从队列里把相应IP端口的连接取出，**如果半连接队列还是个链表，那我们就需要依次遍历，才能拿到我们想要的那个连接，算法复杂度就是O(n)。**

而如果将半连接队列设计成哈希表，那么查找半连接的算法复杂度就回到`O(1)`了。因此出于效率考虑，全连接队列被设计成链表，而半连接队列被设计为哈希表。





#### 全连接队列满了会怎么样？

如果队列满了，服务端还收到客户端的第三次握手ACK，默认当然会丢弃这个ACK。但除了丢弃之外，还有一些附带行为，这会受 `tcp_abort_on_overflow` 参数的影响。

- `tcp_abort_on_overflow`设置为 0，全连接队列满了之后，会丢弃这个第三次握手ACK包，并且开启定时器，重传第二次握手的SYN+ACK，如果重传超过一定限制次数，还会把对应的**半连接队列里的连接**给删掉。

![QQ截图20220629094504](/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220629094504.png)





- `tcp_abort_on_overflow`设置为 1，全连接队列满了之后，就直接发RST给客户端，效果上看就是连接断了。

![QQ截图20220629094528](/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220629094528.png)



#### 半连接队列要是满了会怎么样

**一般是丢弃**，但这个行为可以通过 `tcp_syncookies` 参数去控制。但比起这个，更重要的是先了解下半连接队列为什么会被打满。

首先我们需要明白，一般情况下，半连接的"生存"时间其实很短，只有在第一次和第三次握手间，如果半连接都满了，说明服务端疯狂收到第一次握手请求，如果是线上游戏应用，能有这么多请求进来，那说明你可能要富了。但现实往往比较骨感，你可能遇到了**SYN Flood攻击**。

所谓**SYN Flood攻击**，可以简单理解为，攻击方模拟客户端疯狂发第一次握手请求过来，在服务端憨憨地回复第二次握手过去之后，客户端死活不发第三次握手过来，这样做，可以把服务端半连接队列打满，从而导致正常连接不能正常进来。

那这种情况怎么处理？有没有一种方法可以**绕过半连接队列**？

有，`tcp_syncookies`派上用场了。它被设置为1的时候，客户端发来**第一次握手**SYN时，服务端**不会将其放入半连接队列中**，而是直接生成一个`cookies`，这个`cookies`会跟着**第二次握手**，发回客户端。客户端在发**第三次握手**的时候带上这个`cookies`，服务端验证到它就是当初发出去的那个，就会建立连接并放入到全连接队列中。可以看出整个过程不再需要半连接队列的参与。

![QQ截图20220629094704](/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220629094704.png)



##### **cookies方案为什么不直接取代半连接队列？**

目前看下来`syn cookies`方案省下了半连接队列所需要的队列内存，还能解决 **SYN Flood攻击**，那为什么不直接取代半连接队列？

凡事皆有利弊，`cookies`方案虽然能防 **SYN Flood攻击**，但是也有一些问题。因为服务端并不会保存连接信息，所以如果传输过程中数据包丢了，也不会重发第二次握手的信息。

另外，编码解码`cookies`，都是比较**耗CPU**的，利用这一点，如果此时攻击者构造大量的**第三次握手包（ACK包）**，同时带上各种瞎编的`cookies`信息，服务端收到`ACK包`后**以为是正经cookies**，憨憨地跑去解码（**耗CPU**），最后发现不是正经数据包后才丢弃。

这种通过构造大量`ACK包`去消耗服务端资源的攻击，叫**ACK攻击**，受到攻击的服务器可能会因为**CPU资源耗尽**导致没能响应正经请求。

### 全连接队列，半连接队列总结

- **每一个**`socket`执行`listen`时，内核都会自动创建一个半连接队列和全连接队列。
- 第三次握手前，TCP连接会放在半连接队列中，直到第三次握手到来，才会被放到全连接队列中。
- `accept方法`只是为了从全连接队列中拿出一条连接，本身跟三次握手几乎**毫无关系**。
- 出于效率考虑，虽然都叫队列，但半连接队列其实被设计成了**哈希表**，而全连接队列本质是链表。
- 全连接队列满了，再来第三次握手也会丢弃，此时如果`tcp_abort_on_overflow=1`，还会直接发`RST`给客户端。
- 半连接队列满了，可能是因为受到了`SYN Flood`攻击，可以设置`tcp_syncookies`，绕开半连接队列。
- 客户端没有半连接队列和全连接队列，但有一个**全局hash**，可以通过它实现自连接或TCP同时打开。


### 杂项

- 同步位`SYN = 1` 时表明这是一个连接请求/接受报文。

- 紧急位`URG = 1` 的时候表明此报文段有紧急数据。不用在缓存队列中排队。配合紧急指针使用。

- 紧急指针指向的是紧急数据在此报文段中的末位位置。假如紧急指针 = 100，则1~100为紧急数据。

- 复位`RST = 1`的时候表明TCP连接出现严重错误。需要释放连接再重新连接

- 推送位`PSH = 1`时表明接收方应尽快将数据交付给应用程序，不需要等到缓存填满再交付。

- 终止位`FIN = 1`时表明此报文段发送方数据已经发送完毕，需要释放连接
- bind()设置套接字的本地（源）地址。这是接收数据包的地址。套接字发送的数据包将此作为源地址，因此其他主机将知道将其数据包发送回哪里。 这句话的意思就是你接收到了数据包之后，bind告诉系统你发到这个端口和ip的数据包要发给某个特定的文件描述符。所以只有接受需求的时候才会用bind。客户端不写bind是因为内核自动选择了一个端口。 如果不需要接收，则套接字源地址是无用的。像 TCP 这样的协议需要启用接收才能正确发送，因为当一个或多个数据包到达时，目标主机会发回确认（即确认）。 
- 被动接收的一端都要绑定一个端口，主动发送的一端一般都是系统分配端口
- 标准TCP只有单播因为是点对点，只有UDP有多播和组播
- 调用send函数仅仅是把数据拷贝到发送的缓存区。具体发送不是应用程序可控的。所以说send就算不返回错误也有可能发送失败。
- 如果服务器重启，大量客户端重新连接进来，如果服务器处理accept队列不及时将会发生连接被拒绝的错误。

### 为什么TCP、UDP套接字服务器端需要绑定端口号客户端不需要？

1. IP地址和端口号是用来标识具体某一台主机上的具体一个进程的。也就是说，端口号可以用来标识主机上的某一个进程。
2.  因此，操作系统需要对端口号进行管理，并且计算机中的端口号是有限的。 
3. 如果不进行绑定，操作系统会随机生成一个端口号给服务器。如果操作系统给服务器分配这个端口号的同时，有其他程序也准备使用这个端口号或者说端口号已经被使用，则可能会导致服务器一直启动不起来。 
4. 其次，服务器运行起来就不会在停止了，我们将服务器端的端口号绑定有助于有规划的对主机中的端口号进行使用。 
5. 客户端需要主动向服务器端发送请求，因此客户端就需要知道服务器端的IP地址和端口号，如果不绑定让系统随机生成，客户端将无法知道服务器端的端口号，即使知道也需要每次都去获取。 
6. 对于客户端来说，服务器端并不需要主动给客户端发送数据，客户端是主动的而服务器端是被动的。客户端给服务器端发送数据时，会将自己的IP地址和端口号一起发送过去，服务器端可以方便的找到客户端。 
7. 同时，客户端并不是一直运行的，只需要每次系统随机分配即可。 
8. 因此，服务器端需要绑定而客户端不需要绑定。







