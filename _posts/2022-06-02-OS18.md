---
title: 王道操作系统笔记-进程（15）-- 预防死锁
date: 2022-06-02 07:55:00 -0500
categories: [笔记]
tags: [操作系统]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true

---

# 王道操作系统笔记-进程（15）-- 预防死锁

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=410446173&amp;auto=1&amp;height=66"> </iframe>

## 破坏互斥条件

**只有对必须互斥使用的资源的争抢才会导致死锁。**

如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如: SPOOLing技术。操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备...

![QQ截图20220602081446](/assets/blog_res/2022-06-02-OS18.assets/QQ%E6%88%AA%E5%9B%BE20220602081446.png)



**缺点：并不是所有的资源都可以被改造成可共享使用的资源。并且为了系统安全，很多地方必须保护互斥性。因此很多时候无法破坏互斥资源**



## 破坏不剥夺条件

**不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。**

方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。

方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如:剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用)。

**缺点：**

1. 实现较为复杂。
2. 释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。
3. 反复地申请和释放资源会增加系统开销，降低系统吞吐量。
4. 若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。



## 破坏请求和保持条件

请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。

可以采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。

**缺点：有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。**



## 破坏循环等待条件



![QQ截图20220602082636](/assets/blog_res/2022-06-02-OS18.assets/QQ%E6%88%AA%E5%9B%BE20220602082636.png)

## 总结

![QQ截图20220602082722](/assets/blog_res/2022-06-02-OS18.assets/QQ%E6%88%AA%E5%9B%BE20220602082722.png)