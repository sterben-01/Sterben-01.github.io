---
title: 模板
date: 2022-12-14 09:50:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true

---



# C++ template

此笔记应和杂记3的模板相关部分搭配查看。

## 第1章 函数模板

- 在声明模板变量类型的时候，尽量使用typename而非class。尽管没有区别。
- ~~所有的模板类型参数都应该被使用。不应该有未使用的模板参数，会导致错误。（个人推理）~~
- 函数模板有两种类型的参数：
  - 模板参数：位于函数模板名称的前面，在一对尖括号内部进行声明：
  
  ```c++
  template <typename T>　　　　　　 //T是模板参数
  ```
  
- 调用参数：位于函数模板名称之后，在一对圆括号内部进行声明：

```c++
T max (T const& a, T const& b)　　 //a和b都是调用参数
```


- **一定要让函数模板的所有重载版本的声明都位于它们被调用的位置之前（一般都放在同一个头文件中）**



### 1.1.3 二阶段检查。搭配深度探索对象模型里面的模板一起看。

- **模板的工作原理，并不是把模板编译成一个可以处理任何类型的单一实体；而是对于实例化模板参数的每种类型，都从模板产生出一个不同的实体。**

在实例化模板的时候，如果模板参数类型不支持所有模板中用到的操作符，将会遇到编译期错误。

**但是在定义的地方并没有遇到错误提示。这是因为模板是被分两步编译的。所以我们可以说：在实例化时，模板被编译了两次，分别发生在模板定义阶段（实例化之前），和模板实例化阶段（实例化期间）**

- 在**模板定义阶段**，模板的检查并**不包含类型参数的检查**。只包含下面几个方面：
  -  语法检查。比如少了分号。
  - 使用了未定义的不依赖于模板参数的名称（类型名，函数名，......）。
  - 未使用模板参数的 `static assertions`。
  - 简而言之，就是先检查模板代码本身，查看语法是否正确；在这里会发现错误语法，如遗漏分号等。 

- 在**模板实例化阶段**，为确保所有代码都是有效的，**模板会再次被检查，尤其是那些依赖于类型参数的部分**。
  - 检查模板代码，查看是否所有的调用都有效。在这里会发现无效的调用，如该实例化类型不支持某些函数调用等。

举例：

```c++
template<typename T>
void foo(T t)
{
	undeclared(); // 如果 undeclared()未定义，第一阶段就会报错，因为与模板参数无关
	undeclared(t); //如果 undeclared(t)未定义，第二阶段会报错，因为与模板参数有关
	static_assert(sizeof(int) > 10,"int too small"); // 与模板参数无关，总是报错
	static_assert(sizeof(T) > 10, "T too small"); //与模板参数有关，只会在第二阶段报错
}
```

**需要注意的是，有些编译器并不会执行第一阶段中的所有检查。因此如果模板没有被至少实例化一次的话，你可能一直都不会发现代码中的常规错误。**



### 1.1.4 编译和链接

- 由于 **C++中使用的是静态模板的机制**，所以当使用函数模板，并且引发模板实例化的时候，编译器（在某时刻）需要查看模板的定义。这就不同于普通函数中编译和之间的区别，因为对于普通函数而，只要有该函数的声明（不需要定义），就可以顺利通过编译因为在这里需要的是定义，所以可以考虑在头文件内部实现每个模板以使用编译器能够顺利的找到模板的定义。



## 1.2 函数模板参数推导

### 1.2.1 函数模板参数类型推导中的类型转换

- 在类型推断的时候自动的类型转换是受限制的：
  - **如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数 T 定义的两个参数，它们实参的类型必须完全一样。每个 T 都必须正确匹配。**。
  - **如果调用参数是按值传递的（P是非引用的时候），那么只有退化（decay）这一类简单转换是被允许的**：（和杂记里面的函数模板参数推导一样）
    - `const` 和 `volatile `限制符会被忽略 （A 的 cv 限定符被忽略.）
    - 引用被忽略（A 的引用属性被忽略.）
    - raw array（原始数组） 和函数被转换为相应的指针类型。（如果 A 是数组或函数, P 是值时, 数组和函数退化为指针. ）
    - （隐藏，此处不相干，但还是谢在这里。和杂记中的函数模板参数推导一样）如果 P 是无 cv 限定符的转发引用 (即 T&&), 且 A 是左值时, T 被推导为左值引用.
    - **通过模板类型参数 T 定义的两个参数，它们实参的类型在退化（decay） 后也必须一样**

通常而言，你必须指定**最后一个不能被隐式推导的模板实参之前的**所有实参类型。也就是我们必须显式指定所有模板参数的类型，直到某一个模板参数的类型可以被推断出来为止。

**然而，模板的实参推导并不适合返回类型（可以把推导看成是重载解析的一部分--重载解析是一个不依赖于返回类型选择的过程，唯一的例外就是转型操作符成员的返回类型）。**

### 1.2.2 对默认调用参数的类型推断

需要注意的是，类型推断并不适用于默认调用参数。例如：

```c++
template<typename T>
void func(T a = 12){
    cout << "called" << endl;
}
int main(){
    func(1); //OK 没问题 推导为int
    func(); //编译器发出抱怨，甚至想骂人。
    return 0;
}
```

为应对这一情况，你需要给模板类型参数也声明一个默认参数

```c++
template<typename T = int> //注意这里
void func(T a = 12){ //这里
    cout << "called" << endl;
}
int main(){
    func(); //OK
    return 0;
}
```

**注意，给定的模板默认参数应该和函数默认参数的类型一致。**



## 1.3 多个模板参数

好像是废话，但是水还是蛮深的。我们一起看一下。

```c++
template<typename T1, typename T2>
T1 func(T1 a, T2 b){
    return b < a ? a : b;
}
int main(){
    auto ret = func(1,2.345);
    return 0;
}
```

- 看上去就和我们想的一样，它可以接受两个不同类型的调用参数。但是如示例代码所示，这也导致了一个问题:
  - **如果你使用其中一个类型参数的类型作为返回类型，不管是不是和调用者预期地一样，当应该返回另一个类型的值的时候，返回值会被做类型转换。这将导致返回值的具体类型和参数的传递顺序有关。**
  - 例子：如果传递 2.345 和 1 给这个函数模板，返回值是 double 类型 的 2.345，但是如果传递 1 和 2.345，返回值却是 int 类型的 2。因为我们固定返回较大的数字。但是返回值类型会被进行隐式转换。

所以我们有三个方法解决这个问题：

1. 引入第三个模板参数作为返回类型。
2. 让编译器找出返回类型。
3. 将返回类型定义为两个参数类型的“公共类型。

### 1.3.1 做为返回类型的模板参数

我们还记得模板有两种参数：模板参数和调用参数。

- 当模板参数和调用参数之间没有必然的联系，且模板参数不能确定的时候，就要显式的指明模板参数。比如你可以引入第三个模板来指定函数模板的返回类型

```c++
template<typename RT, typename T1, typename T2>
RT func(T1 a, T2 b){
    cout << "called" << endl;
}
```

- **但是模板类型推断不会考虑返回类型，而 `RT` 又没有被用作调用参数的类型。因此 `RT` 不会被推导。**这样就必须显式的指明模板参数的类型。比如：

```c++
template<typename RT, typename T1, typename T2>
RT func(T1 a, T2 b){
    cout << "called" << endl;
}
int main(){ 
    func<int>(1,2.345); //注意。后面两个可以省略。因为可以被推导。
    return 0;
}
```

**通常而言，我们必须显式指定所有模板参数的类型，直到某一个模板参数的类型可以被推断出来为止。**



### 1.3.2 利用auto，decltype 和（可选的）尾置返回类型进行返回类型推导

C++14开始可以使用`auto`和`decltype `搭配（可选的）尾置返回类型对返回值类型进行推导。

```c++
template<typename T1, typename T2> //不使用尾置返回类型
auto func(T1& a, T2& b){
    return b < a? a: b;
}


template<typename T1, typename T2> //使用尾置返回类型
auto func(T1& a, T2& b) -> decltype(b<a? a:b){
    return b < a? a: b;
}
```

- **在不使用尾置返回类型（trailing return type）的情况下将` auto` 用于返回类型，要求返回类型必须能够通过函数体中的返回语句推断出来。**当然，这**首先要求返回类型能够从函数体中推断出来**。因此，必须要有这样可以用来推断返回类型的返回语句，而且**多个返回语句之间的推断结果必须一致。**
- 注意`decltype`推导过程是在编译期完成的，**并且不会真正计算表达式的值**。
- 此处要注意可能返回值类型可能会被推导为引用类型。请查看下面的文章。

`decltype`过于复杂，可以看这里[decltype详解](https://www.cnblogs.com/5iedu/p/11222078.html)

### 1.3.3 利用std::common_type将返回类型声明为公共类型（common type)

不是很能理解。参见书籍吧。

## 1.4 模板默认参数

- 可以在模板默认参数中使用`common_type`或者是`decay`
- 和函数默认值不同，在函数模板参数中，即使后面的模板参数没有默认值，我们依然可以让第一个模板参数有默认值。并且此时调用时可以不显式指定`<>`

```c++
template<typename RT = int, typename T1, typename T2>
RT func(T1 a, T2 b){
    return a;
}
int main(){
    auto c = func(1,2.234); //并且此时调用时可以不显式指定<>
    return 0;
}
```

## 1.5 函数模板重载

像普通函数一样，模板也是可以重载的。也就是说，你可以定义多个有相同函数名的函数，当实际调用的时候，由 C++编译器负责决定具体该调用哪一个函数。即使在不考虑模板的时候，这一决策过程也可能异常复杂。

- 和普通函数一样，函数模板可以被重载。不止可以被重载，还可以进行特化。函数模板只能全特化。

  -  如果函数模板和普通函数都可以实现（同名的函数模板可以被实例化为与非模板函数具有相同类型的调用参数），**在所有其它因素都相同的情况下，优先调用普通函数而不是从模板实例化出来的函数。**
  - **如果模板可以实例化出一个更匹配的函数，那么就会优先调用函数模板。**（比如如果普通函数涉及到类型转换的时候，则如果模板更加匹配则会调用模板函数）
  - **可以使用空模板参数列表来强制调用函数模板**
  - **在模板参数推断时不允许自动类型转换，而常规函数是允许的**
  - **当有多个特化的函数模板可以被匹配的时候，会有二义性导致报错。**

  

```c++
void test(int a, int b){
    cout << "普通函数" << endl;
}

template <typename T>
void test(T a, T b){
    cout << "模板函数" << endl;
}

template <typename T>
void test(T a, T b, T c){
    cout << "重载的模板函数" << endl;
}

int main(){
    test(1,2); //输出普通函数
    test<>(1,2); //使用空模板参数列表 输出模板函数
    test(1,2,3); //输出重载的模板函数
}
```

- 通常而言，在重载模板的时候，要尽可能少地做改动。你应该只是改变模板参数的个数或者显式的指定某些模板参数。比如不要一会儿值传递一会儿引用传递。

## 第2章 类模板

- 类模板的声明：

```c++
类模板的声明：
template<typename T>
class Stack{
    Stack(Stack<T> const &);
    ~Stack();
    Stack<T> operator=(Stack<T> const &);
};
```

- 区分两种写法：类的类名 `Stack`、类的类型 `Stack<T>`
  - 当在声明中需要使用类的类型时，你必须使用` Stack<T>`（大部分情况）
  - 然而当使用类名而不是类的类型时，就应该只用 `Stack`（比如指定类的名称、构造和析构函数名）
- 类模板可以偏特化也可以全特化。

```c++
template<未被特化的部分>
class obj<特化的部分>{
  ...  
};
template<typename T1, typename T2>
class test{
    T1 data1;
    T2 data2;
};
//全特化
template<>
class test<int, float>{
    int data1;
};
//偏特化
template<typename T2>
class test<int, T2>{
    int data1;
};
```

- 类模板调用顺序： 对主版本模板类、全特化类、偏特化类的调用优先级从高到低进行排序是：全特化类>偏特化类>主版本模板类。这样的优先级顺序对性能也是最好的。 
  
- **只有那些被调用的成员函数，才会产生这些函数的实例化代码。对于类模板，成员函数只有在被使用的时候才会实例化。**
  - 因为在编译阶段，编译器无法确认模板的参数类型，所以无法创建模板类成员函数
  - 显然，这样可以节省空间和时间；另一个好处是对于那些 未能提供所有 “ 成员函数中所有操作的类型“，你也可以使用该类型来实例化类模板，只要对那些 未能提供 “  某些操作的” 成员函数，模板内部不使用就可以。而且现在的 C++标准要求编译器要尽可能的延迟实例化的时机。
  
- **静态成员的无条件实例化：如果类模板中含有静态成员，那么用来实例化的每种类型，都会实例化这些静态成员。**



## 2.6 多模板参数的偏特化

偏特化有多种形式。下面的几种都可以。

```c++
template<typename T1, typename T2>
class MyClass {
    //主模板
};

template<typename T>
class MyClass<T,T> {
    //两个参数同一个类型。
    //注意这里不一定非得写T1 T1。类型具体叫什么没所谓
};

template<typename T>
class MyClass<T,int> {
    //第二个参数是int
};

template<typename T1, typename T2>
class MyClass<T1*,T2*> {
    //两个参数为指针。
};
```



## 2.7 类模板默认参数

类模板自然可以有默认参数。比如很多STL的实现。下面是一个小例子

```c++
template<typename T1, typename T2 = int>
class obj{
     public:
     obj(T1 a, T2 b):val1(a), val2(b){};
     T1 val1;
     T2 val2;
};
```



## 2.8 类型别名 Aliases

一般来说，我们有两种方式可以给类型定义别名。`using` 和 `typedef`

- typedef

  ```c++
  template<typename T>
  class myobj{
      public:
      myobj(T a):val(a){};
      T val;
  };
  
  typedef myobj<int> INTmyobj;
  typedef myobj<double> DOUBLEmyobj;
  
  int main(){
      INTmyobj im(2);
      DOUBLEmyobj dm(2.345);
      cout << im.val << endl;
      cout << dm.val << endl;
      return 0;
  }
  ```

- using

```c++
using usingINTmyobj = myobj<int>;
using usingDOUBLEmyobj = myobj<double>;

usingINTmyobj im(2);
usingDOUBLEmyobj dm(2.345);
```

## 2.9.1 别名模板 Alias Templates

注意。这里是typedef和using在别名方面唯一区别。这里只有using。typedef不可以。

比如我们不可以：

```c++
template<typename T>
typedef myobj<T> intobj;
```

但是可以：

```c++
template<typename T>
using intobj = myobj<T>;]

intobj<int> myobj(2);
```

## 2.9.2 必须显式使用typename的情况

参看笔记STL2

## 2.9.3 类模板的类型推导

直到C++17，我们都必须显式指出所有类模板参数的类型。除非拥有默认值。

剩下的看书。

## 2.9.4 聚合类型的模板化

可以定义聚合类的类模板。关于聚合类，参考聚合初始化。



# 第三章 非类型模板参数

杂记3有写。这里重新整理

## 3.1 类模板的非类型模板参数 - 3.2 函数模板的非类型模板参数

```c++
template<typename T>
void func(T obj){
    //...
}

int main(){
    func<int>(5);
    return 0;
}
```

我们都知道模板参数一般都是类型。比如这里，T就是int。是类型。

但是如果我们有时候需要一些特殊情况， 例如想要传点奇怪东西的时候。

```c++
template<typename T, int MAXSIZE> //注意语法。这里非类型模板参数不再是typename了
void func1(T obj){
    vector<T>a;
    a.reserve(MAXSIZE);
    cout << a.capacity() << endl;
    a.push_back(obj);
    cout << a[0] << endl; 			//干啥了不解释了 忽略即可
}

```

这里的`int MAXSIZE`就是非类型模板参数。因为他不是类型，而是变量。

使用非类型模板参数是有限制的。通常它们只能是：

1. 整型常量或字面值（包含枚举，或可隐式转换的比如`bool`）（`string` `double`都不可以。前者是类对象，后者是浮点数）
2. 指向对象/函数/成员变量的指针
3. 对象/函数的左值引用
4. `std::nullptr_t`

当传递对象的指针或者引用作为模板参数时，对象不能是字符串常量，临时变量或者数据成员以及其他子对象。由于C++17之前，C++每次版本更新都会放宽以上限制，因此还有一些针对不同版本的限制：

- C++11中，对象必须要有外部链接
- C++14中，对象必须是外部链接或者内部链接

所以：传入的`s`必须是常量。

```c++
const int s = 8;	//必须是const
func1<int, s>(5);
func2<int, 4>(5); //或者直接传入字面值。
```



### 搭配类模板偏特化的小例子

```c++
template<typename T, bool option>
class myclass; //主模板不实现

template<typename T>
class myclass<T, true>{ //偏特化1，注意语法。T在这里依旧要写上。
    public:
    void func(){
        cout <<"true one" << endl;
    }
};


template<typename T>
class myclass<T, false>{ //偏特化2，注意语法。T在这里依旧要写上。
    public:
    void func(){
        cout <<"false one" << endl;
    }
};

int main(){
    const bool myoption = true;
    myclass<int, false> obj; //直接使用字面值
    obj.func();
    myclass<int, myoption> obj1; //或必须用const常量变量。
    obj1.func();
    return 0;
}
```



- 两者的非类型模板参数都可以指定默认值：

```c++
template<typename T, int TS = 5> //注意语法。这里非类型模板参数不再是typename了
class myobj{
    public:
    myobj(T a):val(a){my_vec.reserve(TS);};
    T val;
    vector<T> my_vec;
};

template <typename T, int TS = 10> //注意语法。这里非类型模板参数不再是typename了
void func(T a){
    vector<T> my_vec(TS);
    cout <<"called" << endl;
    cout << my_vec.capacity() << endl;
}
int main(){
    myobj<int,8> instance(10);
    cout << instance.my_vec.capacity() << endl;
    //输出8
    func<int, 9>(2);
    //输出 called 9
    
    return 0;
}
```

## 3.3 避免无效表达式

非类型模板参数可以是任何编译器表达式。比如：

```c++
//函数模板
template <int size, bool judge> //注意表达式不写在这。
void func(){
    cout << size << endl;
    if(judge == true){
        cout << "true" << endl;
    }
    else{
        cout << "false" << endl;
    }
}

//类模板
template <int size, bool judge>
class myobj{
    public:
    myobj(){
        my_vec.reserve(size);
        testfunc();
    };
    void testfunc(){
        cout << my_vec.capacity() << endl;
        if(judge == true){
            cout << "true" << endl;
        }
        else{
            cout << "false" << endl;
        }    
    }
    vector<int> my_vec;
};
int main(){
    func<10, sizeof(int) == 4>(); //注意表达式写在这。写在实例化位置而非模板参数位置。
    //输出true
    func<10, (sizeof(int) > 4 )>(); //注意这里表达式要额外一组括号。
    //输出false
    myobj<10, sizeof(int) == 4> instance;
    //输出10 true
    myobj<10, (sizeof(int) > 4 )> instance1;
    //输出10 false
    return 0;
}
```

- **不过如果在表达式中使用了` operator >`，就必须将相应表达式放在括号里面，否则`>`会被作为模板参数列表末尾的`>`，从而截断了参数列表**



## 3.4 使用auto做为非模板类型参数 （C++17）

暂略。看书。







# 杂项

## 类成员函数不可以既是虚函数又是模板函数

- 首先简单来说，虚函数是动态多态。模板属于静态多态。这里不能动静结合。
- 其次，我们知道了函数模板在编译的时候会看哪些地方调用了。根据T的不同，每一份T都会导致实例化出一份T类型的函数。这就导致了会有多个入参类型不同的成员函数。但是我们又知道虚函数的虚函数表必须预先确定。而此时父类看不到子类的模板虚函数到底有几个版本，难不成都写一遍？
- 另一个原因是如果我们有模板虚函数，那么编译器为了确定类的虚函数表的大小，就必须要知道我们一共为该成员模板函数实例化了多少个不同版本的虚函数。显然编译器需要查找所有的代码文件，才能够知道到底有几个虚函数，这对于多文件的项目来说，代价是非常高的。
- 也就是说，如果这样做的话，虚函数表的确定时间就需要从编译器推迟到链接期。因为编译期指的是我不需要看具体实现。我只要发现你是`virtual`我就可以把你放到表内。如果支持模板虚函数，那么就需要链接的时候把每一个实现都扫一遍然后再整理后放入虚函数表。
