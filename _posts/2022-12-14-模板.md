---
title: 模板
date: 2022-12-14 09:50:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true

---



# C++ template

此笔记应和杂记3的模板相关部分搭配查看。

## 第1章 函数模板

- 在声明模板变量类型的时候，尽量使用typename而非class。尽管没有区别。
- 所有的模板类型参数都应该被使用。不应该有未使用的模板参数，会导致错误。（个人推理）
- 函数模板有两种类型的参数：
  - 模板参数：位于函数模板名称的前面，在一对尖括号内部进行声明：
  
  ```c++
  template <typename T>　　　　　　 //T是模板参数
  ```
  
- 调用参数：位于函数模板名称之后，在一对圆括号内部进行声明：

```c++
T max (T const& a, T const& b)　　 //a和b都是调用参数
```


- **一定要让函数模板的所有重载版本的声明都位于它们被调用的位置之前（一般都放在同一个头文件中）**



### 1.1.3 二阶段检查。搭配深度探索对象模型里面的模板一起看。

- **模板的工作原理，并不是把模板编译成一个可以处理任何类型的单一实体；而是对于实例化模板参数的每种类型，都从模板产生出一个不同的实体。**

在实例化模板的时候，如果模板参数类型不支持所有模板中用到的操作符，将会遇到编译期错误。

**但是在定义的地方并没有遇到错误提示。这是因为模板是被分两步编译的。所以我们可以说：在实例化时，模板被编译了两次，分别发生在模板定义阶段（实例化之前），和模板实例化阶段（实例化期间）**

- 在**模板定义阶段**，模板的检查并**不包含类型参数的检查**。只包含下面几个方面：
  -  语法检查。比如少了分号。
  - 使用了未定义的不依赖于模板参数的名称（类型名，函数名，......）。
  - 未使用模板参数的 `static assertions`。
  - 简而言之，就是先检查模板代码本身，查看语法是否正确；在这里会发现错误语法，如遗漏分号等。 

- 在**模板实例化阶段**，为确保所有代码都是有效的，**模板会再次被检查，尤其是那些依赖于类型参数的部分**。
  - 检查模板代码，查看是否所有的调用都有效。在这里会发现无效的调用，如该实例化类型不支持某些函数调用等。

举例：

```c++
template<typename T>
void foo(T t)
{
	undeclared(); // 如果 undeclared()未定义，第一阶段就会报错，因为与模板参数无关
	undeclared(t); //如果 undeclared(t)未定义，第二阶段会报错，因为与模板参数有关
	static_assert(sizeof(int) > 10,"int too small"); // 与模板参数无关，总是报错
	static_assert(sizeof(T) > 10, "T too small"); //与模板参数有关，只会在第二阶段报错
}
```

**需要注意的是，有些编译器并不会执行第一阶段中的所有检查。因此如果模板没有被至少实例化一次的话，你可能一直都不会发现代码中的常规错误。**



### 1.1.4 编译和链接

- 由于 **C++中使用的是静态模板的机制**，所以当使用函数模板，并且引发模板实例化的时候，编译器（在某时刻）需要查看模板的定义。这就不同于普通函数中编译和之间的区别，因为对于普通函数而，只要有该函数的声明（不需要定义），就可以顺利通过编译因为在这里需要的是定义，所以可以考虑在头文件内部实现每个模板以使用编译器能够顺利的找到模板的定义。



## 1.2 函数模板参数推导

### 1.2.1 函数模板参数类型推导中的类型转换

- 在类型推断的时候自动的类型转换是受限制的：
  - **如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数 T 定义的两个参数，它们实参的类型必须完全一样。每个 T 都必须正确匹配。**。
  - **如果调用参数是按值传递的（P是非引用的时候），那么只有退化（decay）这一类简单转换是被允许的**：（和杂记里面的函数模板参数推导一样）
    - `const` 和 `volatile `限制符会被忽略 （A 的 cv 限定符被忽略.）
    - 引用被忽略（A 的引用属性被忽略.）
    - raw array（原始数组） 和函数被转换为相应的指针类型。（如果 A 是数组或函数, P 是值时, 数组和函数退化为指针. ）
    - （隐藏，此处不相干，但还是谢在这里。和杂记中的函数模板参数推导一样）如果 P 是无 cv 限定符的转发引用 (即 T&&), 且 A 是左值时, T 被推导为左值引用.
    - **通过模板类型参数 T 定义的两个参数，它们实参的类型在退化（decay） 后也必须一样**

通常而言，你必须指定**最后一个不能被隐式推导的模板实参之前的**所有实参类型。也就是我们必须显式指定所有模板参数的类型，直到某一个模板参数的类型可以被推断出来为止。

**然而，模板的实参推导并不适合返回类型（可以把推导看成是重载解析的一部分--重载解析是一个不依赖于返回类型选择的过程，唯一的例外就是转型操作符成员的返回类型）。**

### 1.2.2 对默认调用参数的类型推断

需要注意的是，类型推断并不适用于默认调用参数。例如：

```c++
template<typename T>
void func(T a = 12){
    cout << "called" << endl;
}
int main(){
    func(1); //OK 没问题 推导为int
    func(); //编译器发出抱怨，甚至想骂人。
    return 0;
}
```

为应对这一情况，你需要给模板类型参数也声明一个默认参数

```c++
template<typename T = int> //注意这里
void func(T a = 12){ //这里
    cout << "called" << endl;
}
int main(){
    func(); //OK
    return 0;
}
```

**注意，给定的模板默认参数应该和函数默认参数的类型一致。**



## 1.3 多个模板参数

好像是废话，但是水还是蛮深的。我们一起看一下。

```c++
template<typename T1, typename T2>
T1 func(T1 a, T2 b){
    return b < a ? a : b;
}
int main(){
    auto ret = func(1,2.345);
    return 0;
}
```

- 看上去就和我们想的一样，它可以接受两个不同类型的调用参数。但是如示例代码所示，这也导致了一个问题:
  - **如果你使用其中一个类型参数的类型作为返回类型，不管是不是和调用者预期地一样，当应该返回另一个类型的值的时候，返回值会被做类型转换。这将导致返回值的具体类型和参数的传递顺序有关。**
  - 例子：如果传递 2.345 和 1 给这个函数模板，返回值是 double 类型 的 2.345，但是如果传递 1 和 2.345，返回值却是 int 类型的 2。因为我们固定返回较大的数字。但是返回值类型会被进行隐式转换。

所以我们有三个方法解决这个问题：

1. 引入第三个模板参数作为返回类型。
2. 让编译器找出返回类型。
3. 将返回类型定义为两个参数类型的“公共类型。

### 1.3.1 做为返回类型的模板参数

我们还记得模板有两种参数：模板参数和调用参数。

- 当模板参数和调用参数之间没有必然的联系，且模板参数不能确定的时候，就要显式的指明模板参数。比如你可以引入第三个模板来指定函数模板的返回类型

```c++
template<typename RT, typename T1, typename T2>
RT func(T1 a, T2 b){
    cout << "called" << endl;
}
```

- **但是模板类型推断不会考虑返回类型，而 `RT` 又没有被用作调用参数的类型。因此 `RT` 不会被推导。**这样就必须显式的指明模板参数的类型。比如：

```c++
template<typename RT, typename T1, typename T2>
RT func(T1 a, T2 b){
    cout << "called" << endl;
}
int main(){ 
    func<int>(1,2.345); //注意。后面两个可以省略。因为可以被推导。
    return 0;
}
```

**通常而言，我们必须显式指定所有模板参数的类型，直到某一个模板参数的类型可以被推断出来为止。**



### 1.3.2 利用auto，decltype 和（可选的）尾置返回类型进行返回类型推导

C++14开始可以使用`auto`和`decltype `搭配（可选的）尾置返回类型对返回值类型进行推导。

```c++
template<typename T1, typename T2> //不使用尾置返回类型
auto func(T1& a, T2& b){
    return b < a? a: b;
}


template<typename T1, typename T2> //使用尾置返回类型
auto func(T1& a, T2& b) -> decltype(b<a? a:b){
    return b < a? a: b;
}
```

- **在不使用尾置返回类型（trailing return type）的情况下将` auto` 用于返回类型，要求返回类型必须能够通过函数体中的返回语句推断出来。**当然，这**首先要求返回类型能够从函数体中推断出来**。因此，必须要有这样可以用来推断返回类型的返回语句，而且**多个返回语句之间的推断结果必须一致。**
- 注意`decltype`推导过程是在编译期完成的，**并且不会真正计算表达式的值**。
- 此处要注意可能返回值类型可能会被推导为引用类型。请查看下面的文章。

`decltype`过于复杂，可以看这里[decltype详解](https://www.cnblogs.com/5iedu/p/11222078.html)

### 1.3.3 利用std::common_type将返回类型声明为公共类型（common type)

不是很能理解。参见书籍吧。

## 1.4 模板默认参数

- 可以在模板默认参数中使用`common_type`或者是`decay`
- 和函数默认值不同，在函数模板参数中，即使后面的模板参数没有默认值，我们依然可以让第一个模板参数有默认值。并且此时调用时可以不显式指定`<>`

```c++
template<typename RT = int, typename T1, typename T2>
RT func(T1 a, T2 b){
    return a;
}
int main(){
    auto c = func(1,2.234); //并且此时调用时可以不显式指定<>
    return 0;
}
```

## 1.5 函数模板重载

像普通函数一样，模板也是可以重载的。也就是说，你可以定义多个有相同函数名的函数，当实际调用的时候，由 C++编译器负责决定具体该调用哪一个函数。即使在不考虑模板的时候，这一决策过程也可能异常复杂。

- 和普通函数一样，函数模板可以被重载。不止可以被重载，还可以进行特化。函数模板只能全特化。

  -  如果函数模板和普通函数都可以实现（同名的函数模板可以被实例化为与非模板函数具有相同类型的调用参数），**在所有其它因素都相同的情况下，优先调用普通函数而不是从模板实例化出来的函数。**
  - **如果模板可以实例化出一个更匹配的函数，那么就会优先调用函数模板。**（比如如果普通函数涉及到类型转换的时候，则如果模板更加匹配则会调用模板函数）
  - **可以使用空模板参数列表来强制调用函数模板**
  - **在模板参数推断时不允许自动类型转换，而常规函数是允许的**
  - **当有多个特化的函数模板可以被匹配的时候，会有二义性导致报错。**

  

```c++
void test(int a, int b){
    cout << "普通函数" << endl;
}

template <typename T>
void test(T a, T b){
    cout << "模板函数" << endl;
}

template <typename T>
void test(T a, T b, T c){
    cout << "重载的模板函数" << endl;
}

int main(){
    test(1,2); //输出普通函数
    test<>(1,2); //使用空模板参数列表 输出模板函数
    test(1,2,3); //输出重载的模板函数
}
```

- 通常而言，在重载模板的时候，要尽可能少地做改动。你应该只是改变模板参数的个数或者显式的指定某些模板参数。比如不要一会儿值传递一会儿引用传递。

## 第2章 类模板

- 类模板的声明：

```c++
类模板的声明：
template<typename T>
class Stack{
    Stack(Stack<T> const &);
    ~Stack();
    Stack<T> operator=(Stack<T> const &);
};
```

- 区分两种写法：类的类名 `Stack`、类的类型 `Stack<T>`
  - 当在声明中需要使用类的类型时，你必须使用` Stack<T>`（大部分情况）
  - 然而当使用类名而不是类的类型时，就应该只用 `Stack`（比如指定类的名称、构造和析构函数名）
- **只有那些被调用的成员函数，才会产生这些函数的实例化代码。对于类模板，成员函数只有在被使用的时候才会实例化。**
  - 显然，这样可以节省空间和时间；另一个好处是对于那些 未能提供所有 “ 成员函数中所有操作的类型“，你也可以使用该类型来实例化类模板，只要对那些 未能提供 “  某些操作的” 成员函数，模板内部不使用就可以。而且现在的 C++标准要求编译器要尽可能的延迟实例化的时机。
-  **静态成员的无条件实例化：如果类模板中含有静态成员，那么用来实例化的每种类型，都会实例化这些静态成员。**
