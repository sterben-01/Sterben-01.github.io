---
title: 模板
date: 2022-12-14 09:50:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true


---



# C++ template

此笔记应和杂记3的模板相关部分搭配查看。

# 第一章 函数模板

## 0.0 一些深度理解，必须提前知道

- 只有函数模板（function template), 没有模板函数（templated function)

- 函数（主）模板并不是函数。函数模板没有类似于函数的行为。
  - 函数主模板本身并不能调用。
  - 我们表面上是调用了函数主模板，但是实际上是编译器推导出（或我们自己指定出）类型后，编译器将所有的`T`替换为对应类型。然后合成出来的一个新的实例。这就是实例化。
  - 所以，函数主模板本身从不是重载决议候选人（candidate）。候选人是编译器帮助我们替换了`T`之后的实例化的函数。

![QQ截图20221225200646](/assets/blog_res/2022-12-14-%E6%A8%A1%E6%9D%BF.assets/QQ%E6%88%AA%E5%9B%BE20221225200646.png)

https://youtu.be/NIDEjY5ywqU

- **编译器会通过函数的（主）模板，合成（synthesize）一个特化的函数声明（declaration）[其实是签名signature]。然后实例化（instantiate)这个函数的定义（definition）。**
  - 它会首先检验函数的调用，通过查看传入的参数或显式指定的参数获取类型。
  - 然后替换所有的占位符`T`
  - 最后我们得到了一个用于重载决议的候选对象，也就是个函数。

## 0.1 部分名词解析

- 我们知道编译器处理模板代码的时候会进行替换，也就是把每一个`T`替换成传入的模板参数。这个过程被称之为模板的实例化（ instantiation）
- 一旦我们有了实例化的动作，我们就拥有了一个函数。这个函数被称之为特化（specialization）。在这个时候，`T`已经被替换为对应类型。特化是特定于类型的。他们关心类型，现在不再是类型不可知得了。
- 但是我们依旧可以使用`<>`来显式指定一个被关联到模板参数的、被进行了特殊替换的声明。比如这样：
  - 为了区分编译器帮助我们进行的特化，针对这种情况，我们称之为显式(全)特化(explicit specialization)
  - 一般来讲，显式特化被认为是通用模板的一种特殊形式。

```c++
template<typename T1, typename T2> // 主模板
class MyClass { 
    //一些内容
};
template<> // 显式全特化。
class MyClass<std::string,float> {
    //一些内容
};
```

- 如果在显式全特化后，仍需要添加一些模板参数，我们就称之为[显式]部分特化（偏特化）

```c++
template<typename T> // 偏特化
class MyClass<T,T> {
    //一些内容
};
template<typename T> // 偏特化
class MyClass<bool,T> { 
    //一些内容
};
```



## 0.2 显示实例化，隐式实例化和特化。

```c++
template<typename T>
void func(T a){
    cout << a << endl;
}

template
void func<float>(float a); //2 显式实例化

int main(){
    func(10); //1 隐式实例化
    return 0;
}
```

1. 这个过程叫做隐式实例化。隐式实例化指的是函数或类模板被使用或调用的时候，由编译器帮助我们处理的过程。因为编译器帮助我们合成了这个函数的声明，实例化了函数的定义。这个`func(10)`本身是一个特化的函数。
2. 这个过程叫做显式实例化，也叫做外部实例化。显示实例化的意义在于在不发生函数调用的时候就已经将函数模板实例化，或者在不使用类模板的时候就已经将类模板实例化称之为模板显示实例化。这个`void func<float>(float a)`函数本身也是一个特化的函数。
   - 显式实例化只需要写声明，不需要写定义。也就是我们通知编译器，直接根据这个声明，实例化这个函数定义。

- 无论是编译器帮助我们合成后实例化的，还是我们自己显式特化的，只要这个函数有了明确的类型要求，这就是一个特化的函数。（和函数模板相比）

- 显式特化在上一节。


## 0.3 声明和定义

我们在杂记当中已经解释了什么是声明和定义，这里针对上下文再次强化一下认知：

- “声明”将一个名称引入或者再次引入到一个 C++作用域内。引入的过程中可能会包含这个名称的一部分类别，但是一个有效的声明并不需要相关名称的太多细节。比如：

```c++
class C; // 类C的声明
void f(int p); // 函数f的声明
extern int v; // 变量v的声明。注意这里使用了extern
```

- 对于声明 ,如果其细节已知, 或者是需要申请相关变量的存储空间，那么声明就变成了定义。
  - 对于 类类型的定义和函数定义，意味着需要提供一个包含在`{}`中的主体，或者是对函数使用了`=defaut/=delete`。
  - 对于变量，如果进行了初始化或者**没有使用 `extern`**，那么声明也会变成定义。下面是一些“定义”的例子：

```c++
class C {}; // 声明并定义 类C
void f(int p) { //声明并定义函数f
	std::cout << p << ’\n’;
}
extern int v = 1; // 因为初始化了，所以这里也是声明并定义了变量v
int w; // 全局变量，就算没有初始化，由于没有使用extern，所以也是声明并定义变量w
```

- 如果一个类模板或者函数模板有包含在`{}`中的主体的话，那么声明也会变成定义。所以

```c++
template<typename T>
void func (T); //这个是声明。

template<typename T>
class S {}; //这个是定义。
```

## 0.4 模板形参和模板实参

```c++
template<typename T1> // T1 是模板形参，形式上的参数。 parameter
class test;
int main(){
  test<int> obj; //int 是模板实参，实际传入的参数。 argument
}
```



## 1.1.2 基本信息

- 在声明模板变量类型的时候，尽量使用typename而非class。尽管没有区别。

- ~~所有的模板类型参数都应该被使用。不应该有未使用的模板参数，会导致错误。（个人推理）~~

- 函数模板有两种类型的参数：

  - 模板参数：位于函数模板名称的前面，在一对尖括号内部进行声明：

  ```c++
  template <typename T>　　　　　　 //T是模板参数
  ```

  - 调用参数：位于函数模板名称之后，在一对圆括号内部进行声明：


```c++
T max (T const& a, T const& b)　　 //a和b都是调用参数
```


- **一定要让函数模板的所有重载版本的声明都位于它们被调用的位置之前（一般都放在同一个头文件中）**



### 1.1.3 二阶段检查。搭配深度探索对象模型里面的模板一起看。

- **模板的工作原理，并不是把模板编译成一个可以处理任何类型的单一实体；而是对于实例化模板参数的每种类型，都从模板产生（合成）出一个不同的实体。**

在实例化模板的时候，如果模板参数类型不支持所有模板中用到的操作符，将会遇到编译期错误。

**但是在定义的地方并没有遇到错误提示。这是因为模板是被分两步编译的。所以我们可以说：在实例化时，模板被编译了两次，分别发生在模板定义阶段（实例化之前），和模板实例化阶段（实例化期间）**

- 在**模板定义阶段**，模板的检查并**不包含类型参数的检查**。只包含下面几个方面：
  -  语法检查。比如少了分号。
  -  使用了未定义的不依赖于模板参数的名称（类型名，函数名，......）。
  -  未使用模板参数的 `static assertions`。
  -  简而言之，就是先检查模板代码本身，查看语法是否正确；在这里会发现错误语法，如遗漏分号等。 

- 在**模板实例化阶段**，为确保所有代码都是有效的，**模板会再次被检查，尤其是那些依赖于类型参数的部分**。
  - 检查模板代码，查看是否所有的调用都有效。在这里会发现无效的调用，如该实例化类型不支持某些函数调用等。

举例：

```c++
template<typename T>
void foo(T t)
{
	undeclared(); // 如果 undeclared()未定义，第一阶段就会报错，因为与模板参数无关
	undeclared(t); //如果 undeclared(t)未定义，第二阶段会报错，因为与模板参数有关
	static_assert(sizeof(int) > 10,"int too small"); // 与模板参数无关，总是报错
	static_assert(sizeof(T) > 10, "T too small"); //与模板参数有关，只会在第二阶段报错
}
```

**需要注意的是，有些编译器并不会执行第一阶段中的所有检查。因此如果模板没有被至少实例化一次的话，你可能一直都不会发现代码中的常规错误。**



### 1.1.4 编译和链接

- 由于 **C++中使用的是静态模板的机制**，所以当使用函数模板，并且引发模板实例化的时候，编译器（在某时刻）需要查看模板的定义。这就不同于普通函数中编译和链接之间的区别，因为对于普通函数而言，只要有该函数的声明（不需要定义），就可以顺利通过编译。因为在这里需要的是定义，所以可以考虑在头文件内部实现每个模板以使编译器能够顺利的找到模板的定义。

- 假设我们有一个模板类的`.h`和一个`.cpp`文件，还有一个使用了模板类的`.cpp`文件，这个文件`include`了`.h`文件而不是`.cpp`文件。首先头文件不编译。声明被拷贝至使用的文件。这时候我们使用了这个模板。由于C++是分离编译。所以在当前文件下没有问题，会留下函数符号让链接器去寻找。然后我们开始编译模板的`.cpp`文件。模板是二段式编译。也是由于是分离编译，但是在模板的`.cpp`中，我们只有函数定义但是没有使用函数。所以只会进行第一段也就是检查是否有错误。因为没有实例化所以根本不会进行第二段的编译。所以这时候我们使用的文件中就会有无法解析的外部符号了。
- 所以这个时候我们要么把`.h`和`.cpp`文件放到一起写然后`include` `.hpp`文件，
- 要么就在在使用文件中不`include` `.h` 而是`include` `.cpp`

## 1.2 函数模板参数类型推断

### 1.2.1 函数模板参数类型推导中的类型转换

- 在类型推断的时候自动的类型转换是受限制的：
  - **首先入参的引用属性被忽略（A 的引用属性被忽略.）**
  - **如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数 T 定义的两个参数，它们实参的类型必须完全一样。每个 T 都必须正确匹配。**。
  - **如果调用参数是按值传递的（P是非引用的时候），那么只有退化（decay）这一类简单转换是被允许的**：（和杂记里面的函数模板参数推导一样）
    - `const` 和 `volatile `限制符会被忽略 （A 的 cv 限定符被忽略.）
    - raw array（原始数组） 和函数被转换为相应的指针类型。（如果 A 是数组或函数, P 是值时, 数组和函数退化为指针. ）
    - （隐藏，此处不相干，但还是放在这里。和杂记中的函数模板参数推导一样）如果 P 是无 cv 限定符的转发引用 (即 T&&), 且 A 是左值时, T 被推导为左值引用.
    - **通过模板类型参数 T 定义的两个参数，它们实参的类型在退化（decay） 后也必须一样**
  

通常而言，你必须指定**最后一个不能被隐式推导的模板实参之前的**所有实参类型。也就是我们必须显式指定所有模板参数的类型，直到某一个模板参数的类型可以被推断出来为止。

**然而，模板的实参推导并不适合返回类型（可以把推导看成是重载解析的一部分--重载解析是一个不依赖于返回类型选择的过程，唯一的例外就是转型操作符成员的返回类型）。**

**这里搭配7.2看。**



### 注意区别显式指定模板实参类型（不推导）和显式全特化

显式全特化是替换定义。

显式指定模板的实参类型是这样：

```c++
template <typename T>
void func(T a, T b){
    cout <<"success" << endl;
}
int main() {
    long lng = 2000;
    func<int>(lng, 2); //显式指定模板实参类型
}

```

- **我们显式指定模板实参类型就等于避免了参数类型推断。所以可以隐式转换了！**

比如上面的函数

```c++
func(lng, 2);//不行。一个是long一个是int。但是只有一个T类型
func<int>(lng, 2); //可以。显式指定T为int，lng被隐式转换了。
```





### 1.2.2 对默认调用参数的类型推断

需要注意的是，类型推断并不适用于默认调用参数。例如：

```c++
template<typename T>
void func(T a = 12){
    cout << "called" << endl;
}
int main(){
    func(1); //OK 没问题 推导为int
    func(); //编译器发出抱怨，甚至想骂人。
    return 0;
}
```

为应对这一情况，你需要给模板类型参数也声明一个默认参数

```c++
template<typename T = int> //注意这里
void func(T a = 12){ //这里
    cout << "called" << endl;
}
int main(){
    func(); //OK
    return 0;
}
```

**注意，给定的模板默认参数应该和函数默认参数的类型一致。**



## 1.3 多个模板参数

好像是废话，但是水还是蛮深的。我们一起看一下。

```c++
template<typename T1, typename T2>
T1 func(T1 a, T2 b){
    return b < a ? a : b;
}
int main(){
    auto ret = func(1,2.345);
    return 0;
}
```

- 看上去就和我们想的一样，它可以接受两个不同类型的调用参数。但是如示例代码所示，这也导致了一个问题:
  - **如果你使用其中一个类型参数的类型作为返回类型，不管是不是和调用者预期地一样，当应该返回另一个类型的值的时候，返回值会被做类型转换。这将导致返回值的具体类型和参数的传递顺序有关。**
  - 例子：如果传递 2.345 和 1 给这个函数模板，返回值是 double 类型 的 2.345，但是如果传递 1 和 2.345，返回值却是 int 类型的 2。因为我们固定返回较大的数字。但是返回值类型会被进行隐式转换。

所以我们有三个方法解决这个问题：

1. 引入第三个模板参数作为返回类型。
2. 让编译器找出返回类型。
3. 将返回类型定义为两个参数类型的“公共类型。

### 1.3.1 做为返回类型的模板参数

我们还记得模板有两种参数：模板参数和调用参数。

- 当模板参数和调用参数之间没有必然的联系，且模板参数不能确定的时候，就要显式的指明模板参数。比如你可以引入第三个模板来指定函数模板的返回类型

```c++
template<typename RT, typename T1, typename T2>
RT func(T1 a, T2 b){
    cout << "called" << endl;
}
```

- **但是模板类型推断不会考虑返回类型，而 `RT` 又没有被用作调用参数的类型。因此 `RT` 不会被推导。**这样就必须显式的指明模板参数的类型。比如：

```c++
template<typename RT, typename T1, typename T2>
RT func(T1 a, T2 b){
    cout << "called" << endl;
}
int main(){ 
    func<int>(1,2.345); //注意。后面两个可以省略。因为可以被推导。
    return 0;
}
```

**通常而言，我们必须显式指定所有模板参数的类型，直到某一个模板参数的类型可以被推断出来为止。**



### 1.3.2 利用auto，decltype 和（可选的）尾置返回类型进行返回类型推导

C++14开始可以使用`auto`和`decltype `搭配（可选的）尾置返回类型对返回值类型进行推导。

```c++
template<typename T1, typename T2> //不使用尾置返回类型
auto func(T1& a, T2& b){
    return b < a? a: b;
}


template<typename T1, typename T2> //使用尾置返回类型
auto func(T1& a, T2& b) -> decltype(b<a? a:b){
    return b < a? a: b;
}
```

- **在不使用尾置返回类型（trailing return type）的情况下将` auto` 用于返回类型，要求返回类型必须能够通过函数体中的返回语句推断出来。**当然，这**首先要求返回类型能够从函数体中推断出来**。因此，必须要有这样可以用来推断返回类型的返回语句，而且**多个返回语句之间的推断结果必须一致。**
- 注意`decltype`推导过程是在编译期完成的，**并且不会真正计算表达式的值**。
- 此处要注意可能返回值类型可能会被推导为引用类型。请查看下面的文章。

`decltype`过于复杂，可以看这里[decltype详解](https://www.cnblogs.com/5iedu/p/11222078.html)

### 1.3.3 利用std::common_type将返回类型声明为公共类型（common type)

不是很能理解。参见书籍吧。

## 1.4 模板默认参数

- 可以在模板默认参数中使用`common_type`或者是`decay`
- 和函数默认值不同，在函数模板参数中，即使后面的模板参数没有默认值，我们依然可以让第一个模板参数有默认值。并且此时调用时可以不显式指定`<>`

```c++
template<typename RT = int, typename T1, typename T2>
RT func(T1 a, T2 b){
    return a;
}
int main(){
    auto c = func(1,2.234); //并且此时调用时可以不显式指定<>
    return 0;
}
```

## 1.5 函数模板重载和显式全特化

像普通函数一样，函数模板也是可以重载的。也就是说，你可以定义多个有相同函数名的函数，当实际调用的时候，由 C++编译器负责决定具体该调用哪一个函数。即使在不考虑模板的时候，这一决策过程也可能异常复杂。

- 和普通函数一样，函数模板可以被重载。不止可以被重载，还可以进行特化。但是函数模板只能全特化。

  - 决议顺序：普通函数 > 主模板（未特化的模板） > 全特化版本。因为越特化的可能越是需要的
    - **当两个都为模板版本，则调用更特化的模板函数**
    - 因为越特化的可能是越实际要求的。

>- 如果函数名指名了某个函数模板，那么首先进行模板实参推导
>  - 如果它成功，那么将会生成一个单独的模板特化并添加到所要考虑的重载集合中。
>    - 这一步骤结合0中提到的，通过函数模板合成一个函数，然后添加进重载决议候选人集合中
>  - 如果集合中有多于一个函数与目标匹配，且至少一个函数是非模板，那么从考虑集合中去除模板特化。
>    - 这一步是**普通函数优先于模板合成出的函数**。
>  - 如果所有剩余候选者都是模板特化，那么当存在更特殊的模板特化时，移除[较不特殊](https://zh.cppreference.com/w/cpp/language/partial_specialization)者。如果在各项移除之后还有多于一个候选者，那么程序非良构。
>    - 这一步是**如果剩余的函数都是模板函数，那么最特化的优先**。如果在这之后还是多个函数，则会有隐含问题。

***关于重载决议和匹配，写在文末。***


  -  如果函数模板和普通函数都可以实现（同名的函数模板可以被实例化为与非模板函数具有相同类型的调用参数），**在所有其它因素都相同的情况下，优先调用普通函数而不是从模板实例化出来的函数。**
  -  **如果模板可以实例化出一个更匹配的函数，那么就会优先调用函数模板。**（比如如果普通函数涉及到类型转换的时候，则如果模板更加匹配则会调用模板函数）
  -  **可以使用空模板参数列表来强制调用函数模板**
  -  **在模板参数推断时不允许自动类型转换，而常规函数是允许的**
  -  **当有多个特化的函数模板可以被匹配的时候，会有二义性导致报错。**

- **函数模板显式全特化不能包含默认实参值。然而，对于被特化的模板所指定的任何默认实参，显式特化版本都可以应用这些默认实参值（其参数默认值会被保留）。**

```c++
template<typename T>
T f(T a, T b = 42)
{   
    cout <<"general" << endl;
    cout << b << endl;
    return b;
}
template<> 
float f <float>(float a, float b = 42.2) // 错误
{
    cout <<"special" << endl;
    cout << b << endl;
    return b;
}
template<> 
double f <double>(double a, double b) // 可以
{
    cout <<"special" << endl;
    cout << b << endl;
    return b;
}
f(4); //输出general 42
f(4.444); //输出special 42
```

-   **！！！注意，只有非模板和主模板重载参与重载决议。显式全特化并不是重载也从不参与重载决议，因此此时不受考虑。只有在重载决议选择最佳匹配的主函数模板后，才会考虑它的全特化版本以查看最佳匹配者。**
    -   **因为显式全特化的函数模板没有独立名称。也就是不引入名称。因为它只是一个替换的定义，而不是一个替换的声明。**
    -   显式全特化不是重载。


```c++
template<class T>
void f(T);    // #1：所有类型的重载
template<>
void f(int*); // #2：#1 的特化，针对指向 int 的指针
template<class T>
void f(T*);   // #3：所有指针类型的重载
 
f(new int(1)); // 调用 #3，虽然 #1 的特化是完美匹配
```

```c++
void test(int a, int b){
    cout << "普通函数" << endl;
}

template <typename T>
void test(T a, T b){
    cout << "模板函数" << endl;
}

template <typename T>
void test(T a, T b, T c){
    cout << "重载的模板函数" << endl;
}
template<>
void test<int>(int a, int b, int c){
//void test(int a, int b, int c){ //可以去掉 <int>
    cout <<"全特化" << endl;
}
int main(){
    test(1,2); //输出普通函数
    test<>(1,2); //使用空模板参数列表 输出模板函数
    test(1.1,2.2,3.3); //输出重载的模板函数
    test(1,2,3); //输出全特化
    test<int>(1,2,3); //输出全特化
    return 0;
    
}
```

- 为什么后两个都输出全特化？因为他们都是`int`。多个候选者都为模板的时候，更特化的优先。
  - 目前只有两个模板可以接受三个参数。而此时`int`可以匹配到下面的全特化版本，所以全特化版本优先。
- 倒数第三个因为是`float`。这样由于模板匹配的优先级大于类型转换。所以会被匹配到重载的模板函数。
- 通常而言，在重载模板的时候，要尽可能少地做改动。你应该只是改变模板参数的个数或者显式的指定某些模板参数。比如不要一会儿值传递一会儿引用传递。
- **函数的全特化是非常不好的设计。全特化提供的是一个替换的定义，而不是一个替换的声明。在调用函数模板的时点，该调用已经完全基于函数模板而完成解析了 [16.3.2]。所以：**
  - 无法在没有主模板的时候对函数模板进行全特化。
    - **再次重申全特化的函数没有新的mangled的名字。也就是全特化函数没有独立名字。**
  
  - **类成员函数的全特化必须写在类外。**
  
- **如果是分文件编译，为了预防重定义导致的链接错误，必须把全特化的函数模板定义为`inline`防止重定义。**



https://blog.csdn.net/qq_41453285/article/details/104447573

### 关于不要全特化函数和函数全特化的问题写在了最后面




# 第二章 类模板

- 类模板的声明：

```c++
类模板的声明：
template<typename T>
class Stack{
    Stack(Stack<T> const &);
    ~Stack();
    Stack<T> operator=(Stack<T> const &);
};
```

- 区分两种写法：类的类名 `Stack`、类的类型 `Stack<T>`
  - 当在声明中需要使用类的类型时，你必须使用` Stack<T>`（大部分情况）
  - 然而当使用类名而不是类的类型时，就应该只用 `Stack`（比如指定类的名称、构造和析构函数名）
- 类模板可以偏特化也可以全特化。
  - **注意，特化的部分我们塞进去的是实参argument。这部分非常关键**


```c++
template<未被特化的部分>
class obj<特化的部分, 未被特化的部分>{
  ...  
};
template<typename T1, typename T2>
class test{
    T1 data1;
    T2 data2;
};
//全特化
template<>
class test<int, float>{
    int data1;
};
//偏特化
template<typename T2>
class test<int, T2>{
    int data1;
};
```

- **注意，特化的类模板不能改变整体的模板形参数量。也就是在特化的时候，我们不可以改变特化的模板实参的数量**

```c++
template<typename T1>
class test;
template<typename T1, typename T2> //这样做错误 ERROR。主模板只有一个形参。但是特化的时候我们塞进去了俩。不行。
class test<T1, T2>{//改变了特化的模板实参数量。错误

};

int main(){
    test<int, double> obj
}

```

- 类模板调用顺序： 对主版本模板类、全特化类、偏特化类的调用优先级从高到低进行排序是：全特化类>偏特化类>主版本模板类。这样的优先级顺序对性能也是最好的。 

- **只有那些被调用的成员函数，才会产生这些函数的实例化代码。对于类模板，成员函数只有在被使用的时候才会实例化。**
  - 因为在编译阶段，编译器无法确认模板的参数类型，所以无法创建模板类成员函数
  - 显然，这样可以节省空间和时间；另一个好处是对于那些 未能提供所有 “ 成员函数中所有操作的类型“，你也可以使用该类型来实例化类模板，只要对那些 未能提供 “  某些操作的” 成员函数，模板内部不使用就可以。而且现在的 C++标准要求编译器要尽可能的延迟实例化的时机。

- **静态成员的无条件实例化：如果类模板中含有静态成员，那么用来实例化的每种类型，都会实例化这些静态成员。**

- **类模板不能被重载**

## 2.6 多模板参数的偏特化

偏特化有多种形式。下面的几种都可以。但是**注意约束**：

- **类模板偏特化的形参参数个数是可以和主模板不一样的，它既可以多于主模板，也可以少于主模板。但是偏特化的实参必须与主模板对应的参数相匹配。**------*出自16.4章* 
  - 非常重要！！在特化类模板的时候，可以改变特化版本的形参列表的参数数量。但是最终落实（传入/应用）到实参上面的时候，参数数量不可变。
  - 此外，显式书写的模板实参数量与主模板的模板参数数量甚至也可能不同。尤其会在拥有默认模板实参或拥有可变模板时发生
- 偏特化的参数列表不能具有默认实参；作为替代，主类模板的默认实参会被使用。
- 偏特化的非类型实参要么是一个非依赖型值，要么是一个普通的非类型模板参数。它们不能是更加复杂的表达式，诸如`2*N`（`N`是一个模板参数）。
- 偏特化的模板实参列表不应该与主模板的参数列表完全相同（忽略重命名）。
- **如果模板实参的某一个是包展开，那么它必须位于模板实参列表的最后。**

```c++
template<typename T1, typename T2>
class MyClass {
    //主模板
};

template<typename T>
class MyClass<T,T> {
    //两个参数同一个类型。
    //注意这里不一定非得写T1 T1。类型具体叫什么没所谓
    //特化模板的形参列表的参数数量可以变。但是实参列表的参数数量不可变。主模板是两个形参，我们就要传入两个实参。
};

template<typename T>
class MyClass<T,int> {
    //第二个参数是int
};

template<typename T1, typename T2>
class MyClass<T1*,T2*> {
    //两个参数为指针。
};
```

- 我们之前提到过特化的时候塞进去的是实参argument。塞进去的实参必须和主模板的形参数量匹配。为什么这么重要？我们理解一下：

```c++
template<typename T1> //主模板只有一个形参
class test;
//----------VERSION 1---------------------
template<typename T1, typename... T2>
class test<T1, T2 ...>{ //实参数量不匹配

};

int main(){
    test<int,float, double> obj;
}

//-----------VERSION 2----------------------

template<typename T1>
class test;
template<typename T1, typename... T2> //形参可以不同但是实参必须匹配
class test<T1(T2 ...)>{//实参匹配

};

int main(){
    test<int(float, double)> obj; //实参和实参必须数量对应。
}
```

- 为啥version1不行，version2可以？

我们说了，特化的时候必须匹配**主模板**的模板形参数量。我们version 1塞进去了两个模板实参。这样发生了问题。

version2为啥可以？尽管我们特化的时候，针对这个特化的模板形参是两个。但是我们在实际传入实参的时候，`T1` 和` T2...`被合成了一个“函数”类型`T1(T2...)`。这一整个打包起来会变成主模板的`T1`。**注意这是函数类型并非函数指针类型**

- 所以说甚至可以对成员指针进行特化：

```c++
template<typename T>
class List {//主模板
};
template<typename T, typename C>
class Class<T* C::*> { //针对成员指针的特化。T* C::*在主模板眼里是它的整个T
    
};
```



- 为什么我们下面的实例化也要写成`int(float, double)`的形式？因为实参和实参必须相匹配。举个最简单的例子：

```c++
template<typename T1, typename T2>
class MyClass {
    //主模板
};

template<typename T>
class MyClass<T,T> {
};
```

这是我们提到的例子。我们实例化的时候应该怎么写？是不是应该写`Myclass<int, int>`这种形式的？不能写`Myclass<int>`对吧？

- 为啥我这么关心这个？因为这是`packaged_task`的模板实现方式

```c++
template< class > 
class packaged_task; //主模板
template< class R, class ...ArgTypes >
class packaged_task<R(ArgTypes...)>; //特化。
```





## 2.7 类模板默认参数

类模板自然可以有默认参数。比如很多STL的实现。下面是一个小例子

```c++
template<typename T1, typename T2 = int>
class obj{
     public:
     obj(T1 a, T2 b):val1(a), val2(b){};
     T1 val1;
     T2 val2;
};
```



## 2.8 类型别名 Aliases

一般来说，我们有两种方式可以给类型定义别名。`using` 和 `typedef`

- typedef

  ```c++
  template<typename T>
  class myobj{
      public:
      myobj(T a):val(a){};
      T val;
  };
  
  typedef myobj<int> INTmyobj;
  typedef myobj<double> DOUBLEmyobj;
  
  int main(){
      INTmyobj im(2);
      DOUBLEmyobj dm(2.345);
      cout << im.val << endl;
      cout << dm.val << endl;
      return 0;
  }
  ```

- using

```c++
using usingINTmyobj = myobj<int>;
using usingDOUBLEmyobj = myobj<double>;

usingINTmyobj im(2);
usingDOUBLEmyobj dm(2.345);
```

### 2.8.1 别名模板 Alias Templates

注意。这里是typedef和using在别名方面唯一区别。这里只有using。typedef不可以。

比如我们不可以：

```c++
template<typename T>
typedef myobj<T> intobj;
```

但是可以：

```c++
template<typename T>
using intobj = myobj<T>;

intobj<int> myobj(2);
```

### 2.8.2 必须显式使用typename的情况

参看笔记STL2

## 2.9 类模板的类型推导

直到C++17，我们都必须显式指出所有类模板参数的类型。除非拥有默认值。

剩下的看书。

## 2.10 聚合类型的模板化

可以定义聚合类的类模板。关于聚合类，参考聚合初始化。

## 2.11 类模板成员函数或变量的类外实现[自己添加]

基本类代码

```c++
template<typename T>
class test{
    public:
    T val;
    static T s_val;
    void func(T val);
    T func1();
    void func2();

};
```

#### 类静态成员变量

```c++
template<typename T>
T test<T>::s_val = 102;


int main(){
    test<int> obj;
    test<double> obj2;
    cout << obj.s_val<< endl; //输出102
    cout << obj2.s_val << endl; //输出102
    obj2.s_val = 12345;
    cout << obj.s_val<< endl; //输出102
    cout << obj2.s_val << endl; //输出12345
    return 0;
}
```

- 类静态成员变量在模板类中依旧遵循全类共享。**但是注意这里是实例化后的全类共享。也就是`T`为`int`的`test`和`T`为`double`的`test`是两种类类型。自然二者是独立开来的。因为会分别实例化代码**。



#### 类成员函数

```c++
template<typename T>
T test<T>::s_val = 102;


template<typename T>
void test<T>::func(T val){
    cout <<"func" << endl; 
}

template<typename T>
T test<T>::func1(){
    cout <<"func1" << endl; 
}

template<typename T>
void test<T>::func2(){
    cout <<"func2" << endl; 
}
```

- 可以看见，必须加模板头，且必须在指明类作用域的时候添加`T`
  - 也就是不能`test::func` 必须是`test<T>::func`



# 第三章 非类型模板参数

杂记3有写。这里重新整理

## 3.1 类模板的非类型模板参数 - 3.2 函数模板的非类型模板参数

```c++
template<typename T>
void func(T obj){
    //...
}

int main(){
    func<int>(5);
    return 0;
}
```

- **我们都知道模板参数一般都是类型。比如这里，`T`就是`int`。是类型。当我们希望传入一个不是类型的参数的时候，比如如果我们有时候需要一些特殊情况， 例如想要传点奇怪东西的时候就可以使用非类型模板参数。**

```c++
template<typename T, int MAXSIZE> //注意语法。这里非类型模板参数不再是typename了
void func1(T obj){
    vector<T>a;
    a.reserve(MAXSIZE);
    cout << a.capacity() << endl;
    a.push_back(obj);
    cout << a[0] << endl; 			//干啥了不解释了 忽略即可
}

```

- **这里的`int MAXSIZE`就是非类型模板参数。因为他不是类型，而是变量。**

使用非类型模板参数是有限制的。通常它们只能是：

1. 整型常量或字面值（包含枚举，或可隐式转换的比如`bool`）（`string` `double`都不可以。前者是类对象，后者是浮点数）
2. 指向对象/函数/成员变量的指针
3. 对象/函数的左值引用
4. `std::nullptr_t`

当传递对象的指针或者引用作为模板参数时，对象不能是字符串常量，临时变量或者数据成员以及其他子对象。由于C++17之前，C++每次版本更新都会放宽以上限制，因此还有一些针对不同版本的限制：

- C++11中，对象必须要有外部链接
- C++14中，对象必须是外部链接或者内部链接

所以：传入的`s`必须是常量。

```c++
const int s = 8;	//必须是const
func1<int, s>(5);
func2<int, 4>(5); //或者直接传入字面值。
```



### 搭配类模板偏特化的小例子

```c++
template<typename T, bool option>
class myclass; //主模板不实现

template<typename T>
class myclass<T, true>{ //偏特化1，注意语法。T在这里依旧要写上。
    public:
    void func(){
        cout <<"true one" << endl;
    }
};


template<typename T>
class myclass<T, false>{ //偏特化2，注意语法。T在这里依旧要写上。
    public:
    void func(){
        cout <<"false one" << endl;
    }
};

int main(){
    const bool myoption = true;
    myclass<int, false> obj; //直接使用字面值
    obj.func();
    myclass<int, myoption> obj1; //或必须用const常量变量。
    obj1.func();
    return 0;
}
```



- 两者的非类型模板参数都可以指定默认值：

```c++
template<typename T, int TS = 5> //注意语法。这里非类型模板参数不再是typename了
class myobj{
    public:
    myobj(T a):val(a){my_vec.reserve(TS);};
    T val;
    vector<T> my_vec;
};

template <typename T, int TS = 10> //注意语法。这里非类型模板参数不再是typename了
void func(T a){
    vector<T> my_vec(TS);
    cout <<"called" << endl;
    cout << my_vec.capacity() << endl;
}
int main(){
    myobj<int,8> instance(10);
    cout << instance.my_vec.capacity() << endl;
    //输出8
    func<int, 9>(2);
    //输出 called 9
    
    return 0;
}
```

## 3.3 避免无效表达式

非类型模板参数可以是任何编译器表达式。比如：

```c++
//函数模板
template <int size, bool judge> //注意表达式不写在这。
void func(){
    cout << size << endl;
    if(judge == true){
        cout << "true" << endl;
    }
    else{
        cout << "false" << endl;
    }
}

//类模板
template <int size, bool judge>
class myobj{
    public:
    myobj(){
        my_vec.reserve(size);
        testfunc();
    };
    void testfunc(){
        cout << my_vec.capacity() << endl;
        if(judge == true){
            cout << "true" << endl;
        }
        else{
            cout << "false" << endl;
        }    
    }
    vector<int> my_vec;
};
int main(){
    func<10, sizeof(int) == 4>(); //注意表达式写在这。写在实例化位置而非模板参数位置。
    //输出true
    func<10, (sizeof(int) > 4 )>(); //注意这里表达式要额外一组括号。
    //输出false
    myobj<10, sizeof(int) == 4> instance;
    //输出10 true
    myobj<10, (sizeof(int) > 4 )> instance1;
    //输出10 false
    return 0;
}
```

- **不过如果在表达式中使用了` operator >`，就必须将相应表达式放在括号里面，否则`>`会被作为模板参数列表末尾的`>`，从而截断了参数列表**



## 3.4 使用auto做为非模板类型参数 （C++17）

暂略。看书。



# 第四章 变参模板

## 4.1 函数的变参模板

- 基本定义

```c++
template <typename T, typename... Args>  //注意这里的Args叫模板参数包
// 如果函数参数列表中一个参数的类型是一个模板参数包,
// 则此参数也是一个函数参数包
void func(const T& t, const Args&... rest); //这里的rest叫函数参数包
```

- **一定要注意区分开在模板头声明的模板参数包和函数头的函数参数包的区别。**
- 注意，模板参数包只能接受同一个类型的参数。要么全是类型模板参数，要么全是非类型模板参数。要么全是模板类型模板参数。不能混用。这也是下面5.7匹配问题关于`array`的问题 ----- *12.3.4章节*
- C++17之前的写法：因为没有折叠表达式

```c++
void print (){
//必须要有无参重载，否则会无限递归。也就是最后一次无参无法被调用。
//最后一次被解包后，参数包会为空。所以会调用无参函数。
}
template<typename T, typename... Args>
void print (T firstArg, Args... args)
{
    cout << firstArg << endl; //print first argument
    print(args...); // call print() for remaining arguments
}
int main() 
{
    print(1, 1000, "b23", 1.123, "HahaahaH", 42);
    return 0;
}
```

- C++17之后的写法：有了折叠表达式
  - 此处折叠表达式和逗号运算符语法会在下文补充。


```c++
template<typename T> //要有单参打印的重载。不然会无限调用。
void print(T t){
    cout << t << endl;
}


template<typename... Args>
void print(Args... args){
    (print(args), ...); //这里外部一定要加括号。注意语法。这里的,是逗号运算符。
}


int main() 
{
    print(1, 1000, "b23", 1.123, "HahaahaH", 42);
    return 0;
}
```

- **多种变长参数模板可以同时存在 尽管直观看起来会有二义性**

### 搭配列表初始化

- 函数变长参数模板搭配列表初始化。
  - 这个函数会返回一个`T`类型的`vector`，元素是`args`

```c++
template<typename T, typename... Args>
vector<T> func(const Args&... args){
    return {args...};
}
int main(){
    auto vec = func<int>(1,2,3,4,5,6,7);
    for(auto& i:vec){
        cout << i << endl;
    }
}
/*
输出：
1
2
3
4
5
6
7
*/
```



### 4.1.2 变参和非变参模板的重载

我们提到了多种变长参数模板可以同时存在 尽管直观看起来会有二义性。所以上面C++17前的写法可以写成这样子：

```c++
template<typename T>
void print (T arg){
    cout << arg << endl;
}
template<typename T, typename... Args>
void print (T firstArg, Args... args)
{
    print(firstArg); //注意这里。这里调用了无模板参数包的函数。单独打印这次解包出来的这一个变量。
    print(args...); // call print() for remaining arguments
}
int main() 
{
    print(1, 1000, "b23", 1.123, "HahaahaH", 42);
    return 0;
}
```

- **简单来说，当两个函数模板的区别只在于尾部的参数包的时候，会优先选择没有尾部参数包的那一个函数模板。**



### 4.1.3 sizeof运算符在变长模板中的特殊应用。

等看到8.5再来整理这部分。



## 4.2 折叠表达式 (fold expression)

**折叠表达式的展开过程并不是递归。更多的是类似于一种替换，一种编译时展开替换。个人理解。**

折叠表达式分为四种：

- 左折：参数从左侧开始计算  

  - 一元左折叠

  ```
  ( ... 运算符 形参包 )
  会被拓展为
  (((E1 运算符 E2) 运算符 ...) 运算符 EN)
  ```

  - 二元左折叠

  ```
  ( 初值 运算符 ... 运算符 形参包 )	
  会被拓展为
  ((((初值 运算符 E1) 运算符 E2) 运算符 ...) 运算符 EN)
  ```

- 右折：参数从右侧开始计算

  - 一元右折叠

  ```
  ( 形参包 运算符 ... )
  会被拓展为
  (E1 运算符 (... 运算符 (EN-1 运算符 EN)))
  ```

  - 二元右折叠

  ```
  ( 形参包 运算符 ... 运算符 初值 )	
  会被拓展为
  (E1 运算符 (... 运算符 (EN−1 运算符 (EN 运算符 初值))))
  ```

- 左折叠右折叠在有顺序要求的时候尤其重要。比如减法和除法。

  - 注意左右不是指的是单个顺序颠倒。而是每一组顺序颠倒。

  - 比如` ((a+b)+c)` 变成右折并不是`(a+(c+b))`。而是`(a+(b+c))`

- **将一元折叠用于长度为零的包展开时，只能使用下列运算符：**

  - 逻辑与（&&）。空包的值是 true

  - 逻辑或（||）。空包的值是 false

  - 逗号运算符（,）。空包的值是 void()

  - 其他操作符为不合规。

- **在二元折叠中，两个运算符必须相同**

  - 不可以一加一减。

- 语法示范：

```c++
//一元左折叠加法
template<typename... T>
auto foldSumLeft(T... s)
{
    return (... + s); // ((s1+s2)+s3)...
}

//一元右折叠加法
template<typename... T>
auto foldSumRight(T... s)
{
    return (s + ...); // (s1+...+(Sn-1 + sn)))...)
}
//一元左折叠减法
template<typename... T>
auto foldMinLeft(T... s)
{
    return (... - s); // ((s1-s2)-s3)...
}
//一元右折叠减法
template<typename... T>
auto foldMinRight(T... s)
{
    return (s - ...); // (s1-...-(Sn-1 - sn)))...)
}

int main(){
    auto sumLeft = foldSumLeft(1,2,3,4,5,6,7); //((((((1+2)+3)+4)+5)+6)+7)
    auto sumRight = foldSumRight(1,2,3,4,5,6,7);
    cout << sumLeft << endl; //28
    cout << sumRight << endl;//28
    auto sumLeftmin  = foldMinLeft(1,2,3); //((1-2)-3)
    auto sumRightmin  = foldMinRight(1,2,3);//(1-(2-3))
    cout << sumLeft << endl; //-4
    cout << sumRight << endl;//2
}


//二元左折
template <typename... T>
auto foldBinLeft(T... s)
{
    //操作对象有两个，一个是888 初值，一个是ts形参包,
    //初始值位于左边，所以为二元左折
    return (888 + ... + s);
}
//二元右折
template <typename... T>
auto foldBinRight(T... s)
{
    //操作对象有两个，一个是888 初值，一个是ts参包,
    //初始值位于右边，所以为二元右折
    return (s + ... + 888);
}
int main(){
    auto binLeft = foldBinLeft(1,2,3); //894 (((888+1)+2)+3)
    auto binRight = foldBinRight(1,2,3); //894 (1+(2+(3+888)))
    cout << binLeft << endl;
    cout << binRight << endl;
}
```



- 如果用作 初值 或 形参包的表达式在顶层具有优先级低于转型的运算符，那么它必须加括号：
- 此处仅用二元右折做个示范。注意此时两个操作符都是`+`。所以合法。

```c++
template <typename... T>
auto foldBinRight(T... s)
{
    return (s + ... + (888*2)); //可以
    return (s + ... + 888*2); //不可以
}
```

### 序列点和逗号运算符在折叠表达式中的特殊性质

序列点的定义可以查一下文档。简单来说就是我们需要约束一个表达式的计算顺序。

我们上面提到了这个代码：

```c++
template<typename... Args>
void print(Args... args){
    (print(args), ...); //这里外部一定要加括号。注意语法
    (..., print(args));//??
}

```

我们发现第一行是右折叠。按理来说应该是逆序输出。但是为什么这里左折和右折效果一样？

**这就是序列点和逗号运算符的特殊性。**

- **C++有强制规定：内建[逗号运算符](https://zh.cppreference.com/w/cpp/language/operator_other#.E5.86.85.E5.BB.BA.E7.9A.84.E9.80.97.E5.8F.B7.E8.BF.90.E7.AE.97.E7.AC.A6) , 的第一个（左）参数的每个值计算和副作用都按顺序早于第二个（右）参数的每个值计算和副作用。**
- 也就是说，这里的左折叠和右折叠的优先级是低于逗号运算符的。所以说逗号运算符强制从左到右的运算顺序使得这里的左折和右折失效。产生了同等效果  。
- 所以，这里在展开后，依旧会从左至右进行运算。
- 再次重申：折叠表达式的展开过程并不是递归。
- 所以它展开后可以被化简看作：

```c++
print(1), print(1000), print("b23"),.....;
```

此部分参考：

https://stackoverflow.com/questions/46056268/order-of-evaluation-for-fold-expressions

https://stackoverflow.com/questions/59590426/variadic-template-argument-forwarding-uses-comma-operator

https://stackoverflow.com/questions/53330713/fold-expression-with-comma-operator-and-variadic-template-parameter-pack

https://stackoverflow.com/questions/45603533/how-does-folding-over-comma-work

## 4.3 变参模板的使用

之前关于常规模板参数的规则同样适用于变参模板参数。

- 比如，如果参数是按值传递的，那么其参数会按照正常理解被拷贝，类型也会退化（decay）。
- 如果是按引用传递的，那么参数会是实参的引用，并且类型不会退化



## 4.4 变参类模板和变参表达式

### 4.4.1 在变参中使用表达式

此处是针对4.2的一些扩展。也就是折叠表达式的一种应用。

我们可以将函数参数包参与到一些运算当中：

- **这里，我们把传入的每一个参数的数值都增加一倍**
  - 注意字面值是`const char*`类型。

```c++
template<typename T> //要有单参打印的重载。不然会无限调用。
void print(T t){
    cout << t << endl;
}


template<typename... Args>
void print(Args... args){
    (print(args), ...); //这里外部一定要加括号。注意语法。这里的,是逗号运算符。
}


template<typename... T>
void printDoubled (T const&... args)
{
    print (args + args...);
}   

int main(){
    printDoubled(1, 2.3, string("abcde")); //输出 2 4.6 abcdeabcde。注意字面值是`const char*`类型。
    //等于调用 print(1+1), print(2.3 + 2.3), print(string("abcde") + string("abcde"))
    return 0;
}
```

- **如果只是想每一个都加1，那么后面的参数包位置则必须字面值和数字分开。**

```c++
template<typename... T>
void printDoubled (T const&... args)
{
    print(1 + args...); //要么这么写
    print(args + 1 ...); //要么这么写。但是1和...必须分开。
    print((args + 1)...); //要么这么写。多加个括号。
}   
```

- 编译阶段的表达式同样可以像上面那样包含模板参数包。比如下面这个例子可以用来判断所有参数包中参数的类型是否相同
  - 注意这里是函数模板的例子。函数模板可以自动推导类型。

```c++
template<typename T1, typename... TN>
constexpr bool isSameType (T1, TN...)
{
    return (std::is_same<T1,TN>::value && ...); // since C++17
}

int main(){
    cout << isSameType(1,2,3,4) << endl; //输出1 true
    //这一行会被扩展为 std::is_same<int,int>::value && std::is_same<int,int>::value && std::is_same<int,int>::value
    cout << isSameType(1,2,"123",4) << endl; //输出0 false
    //这一行会被扩展为 std::is_same<int,int>::value && std::is_same<int,const char*>::value && std::is_same<const char*,int>::value
    cout << isSameType("abc", "abcde") << endl; //输出1 true 特别注意这里
    return 0;
}
```

- 注意最后一个调用。这里因为是按值传递，所以发生了类型退化，统一被推导为`const char*`。
- 否则类型将依次被推断为：`const char [3]` 和 `const char[5]`;
  - 所以如果`isSameType`写成这个样子就不会退化，导致输出`false`
  - `constexpr bool isSameType (T1&, TN&...)`
    - 这里参见函数模板参数推导规则。这里我们看到传入的是数组，然后模板函数的入参部分(不是模板参数部分)是引用了，所以这时候传入的参数不会退化。也就是里面的`T1`和`TN`维持住了非退化类型。







### 4.4.2 在变参中使用下标 (variadic indices)

这里看起来可能比较晦涩，但是是一个比较实用的功能。

- 假设我们有两个参数。第一个参数是一个容器，第二个参数是一个下标。我们想访问这个容器的这个下标的元素应该怎么做？

```c++
template<typename Container, typename Index>
void getItem(Container& container, Index idx){
    cout << container[idx] << endl;
}

int main(){
    //printDoubled(1, 2.3); //输出 2 4.6
    vector<string> my_vec{"abc", "def", "ghi", "123", "456"};
    getItem(my_vec, 3); //输出 123
    return 0;
}
```

- 好的。那么我们如果想要把这个功能融入到变参里面呢？比如我想要拿出多个元素，怎么做呢？
  - 注意这里我们参数包为下标，而不是容器。
  - 非常方便。

```c++
template<typename T> //要有单参打印的重载。不然会无限调用。
void print(T t){
    cout << t << endl;
}


template<typename... Args>
void print(Args... args){
    (print(args), ...); //这里外部一定要加括号。注意语法。这里的,是逗号运算符。
}
//--------------------------上面是之前我们一直在用的print模板，这里也放一个方便查看---------------------
template<typename Container, typename... Index> //模板参数包
void getMultipleItem(Container& container, Index... idx){//函数参数包
    print(container[idx]...); //参数包
}
int main(){
    vector<string> my_vec{"abc", "def", "ghi", "123", "456"};
    getMultipleItem(my_vec, 1,2,3,4);
    //输出def ghi 123 456
    return 0;
}
```

- `getMultipleItem(my_vec, 1,2,3,4);` 相当于调用了：
  - `print(my_vec[1], my_vec[2], my_vec[3], my_vec[4])`;





#### **同时我们也可以将非类型模板参数声明成参数包：**

```c++
template<int... Idx, typename Container> //细节1
void getMultipleItem(Container& container){ //细节2
    print(container[Idx]...);
}
int main(){
    vector<string> my_vec{"abc", "def", "ghi", "123", "456"};
    getMultipleItem<1,2,3,4>(my_vec); //细节3
    //输出def ghi 123 456
    return 0;
}
```

- 首先，非类型模板参数不是类型，是变量。所以无需传入函数参数。只需在模板参数中传入（细节1，2）
- 细节3，这里既然是模板参数而非函数参数，所以这里要用`<>`传入模板参数



### 4.4.3 在类模板中使用可变参数（变参类模板）

等25和26章

### 4.4.4 变参推断指引

看书

### 4.4.5 变参基类

等26章





# 第五章 基础技巧

## 5.1 typename关键字

**看STL2**

## 5.2 零初始化

**此处同时参考笔记 聚合初始化**

- 模板中依旧遵循和非模板相同的初始化规则，比如：

```c++
template <typename T>
void func(){
    T x; //如果T是内置类型，则模板实例化后，x为脏数据，也就是未确定值。
}
```

- 如果想要强制其初始化为0，则应该使用值初始化。关于值初始化依旧参考聚合初始化笔记。

```c++
template <typename T>
void func(){
    T x{}; //如果T是内置类型，则模板实例化后，x为0值。
}
```



### 一些之前的知识回顾

- 在 C++11 之前，确保一个对象得到显示初始化的方式是

```c++
T x = T();
```

- [这一条可以参考杂记的拷贝初始化和杂记2的explicit] 由于这是一种拷贝初始化，所以在 C++17 之前，只有在与拷贝初始化对应的构造函数没有被声明为 explicit 的时候，这一方式才有效（目前也依然被支持）
-  [强制拷贝省略技术可以参考杂记3的复制省略技术] 从 C++17 开始，由于强制拷贝省略（mandatory copy elision）的使用，这一限制被解除，因此在 C++17 之后以上两种方式都有效。不过对于用花括号初始化的情况，如果没有可用的默认构造函数，它还可以使用列表初始化构造函数（initializer-listconstructor）



### 继续话题

为确保类模板中类型被参数化了的成员得到适当的初始化，可以定义一个默认的构造函数并在其中对相应成员做初始化：

```c++
template<typename T>
class MyClass {
    private:
        T x;
    public:
        MyClass() : x{} {} //确保当T为内置类型时，x值为0。注意第一个花括号为值初始化。第二个花括号是构造函数的函数体。
};
```

- c++11之前的语法：

```c++
MyClass() : x() {}
```

- 从C++11开始，针对**非静态成员和非默认参数**部分，则也可以用这种方法。

```c++
template<typename T>
class MyClass {
	private:
		T x {}; // 使用值初始化，确保当T为内置类型时，x值为0。
};
```

- 如果针对默认参数这样使用，则会报错。

```c++
template<typename T>
void foo(T p{}){ 
    //错误
}
```

- 这样可以：

```c++
template<typename T>
void foo(T p = T{}){ 
    //正确。但如果C++11之前的话必须把T{}换成T()
}
```

## 5.3 使用this 

- **这里应参考 深度探索c++对象模型笔记中的7.1**
- 简而言之，当在模板类中使用定义于基类中的、依赖于模板参数的成员时，应当用 `this->`或者如` Base<T>::`这样显式指定作用域来使用它



## 5.4 正确处理传入模板的裸数组或字符串常量

- 当向模板传递裸数组或者字符串常量时，需要格外注意以下内容：

- 如果参数是按引用传递的，那么参数类型不会退化（decay）。

  - 也就是说当传递`hello`作为参数时，模板类型会被推断为 `const char[6]`。这样当向模板传递长度不同的裸数组或者字符串常量时就可能遇到问题，因为它们对应的模板类型不一样。

- 只有当按值传递参数时，模板类型才会退化（decay）
    - 这样字符串常量会被推断为`const char*`。


**关于具体选用按照值传递还是引用传递，可以看第七章。**

不过我们可以单独处理一下裸数组或者是字符串常量

```c++
template<typename T, int N, int M>
bool func (T(&a)[N], T(&b)[M]){
    cout << N << endl; //输出3
    cout << M << endl; //输出7
    for (int i = 0; i<N && i<M; ++i){
        if (a[i]<b[i]){
            return true; 
        }
        if (b[i]<a[i]){
            return false;
        }
    }
    return N < M;
}

int main(){
    int x[] = {1,2,3};
    int y[] = {1,2,3,4,5,6,7};
    func(x,y);
    return 0;
    
}
```

在上面的代码中，`func`中的`T`会被实例化为`int`，`N`会被实例化为`3`，`M`会被实例化为`7`。

同样适用于字符串常量。如果我们调用

```c++
func("abc", "abcde");
```

则`func`中的`T`会被实例化为`const char`，`N`会被实例化为`4`，`M`会被实例化为`6`。这里多了1是因为有字符串结束符。

## 5.5 成员模板

我们知道，写在尖括号`<>`内部的是模板参数，也就是类型信息。所以`stack<int>` 和 `stack<float>`理论上不可以相互赋值。因为没有合适的转换方式。但是我们可以重载 类内的`operator=`来实现这个不同类型间的相互赋值。比如`stack<float>`赋值给`stack<int>`。

具体实现还是看书比较好。

### 5.5.1 成员模板的特化

我们也可以给成员函数添加模板。同时成员函数模板也可以被全特化

```c++
class getInt{
    public:
        float val;
        getInt(float a): val(a){};
        template<typename T = int> //成员函数模板。此处模拟一个返回int
        T get() const{
            return val;
        }
};

template<> //全特化，此处模拟返回string。这里有细节
inline string getInt::get<string>() const{ //注意这里的inline
    return to_string(val);
}

int main(){
    getInt myobj(12.345);
    auto t = myobj.get();
    cout << t << endl; //12
    auto t1 = myobj.get<string>(); //12.345000
    cout << t1 << endl;
    return 0;
    
}
```

- 第一个细节：c++不允许成员函数模板在类内全特化（显式特化）。必须写在类外。
- 第二个细节：如果分离编译，则此处全特化版本函数必须inline，否则可能会重定义。

### 5.5.2 特殊成员函数的模板

- **如果能够通过特殊成员函数 拷贝或者 移动对象，那么相应的特殊成员函数（拷贝构造函数以及 移动 构造函数）也将可以被模板化。**

- 和前面定义的赋值运算符类似，**构造函数也可以是模板**。但是需要注意的是，**构造函数模板或者赋值运算符模板不会取代预定义的构造函数（此处尤指拷贝构造和移动构造）和赋值运算符（此处尤指拷贝赋值和移动赋值）**。**成员函数模板不会被算作用来 拷贝或移动  对象的特殊成员函数。在上面的例子中，如果在相同类型的 stack 之间相互赋值，调用的依然是默认赋值运算符。**
  - **这句话有毛病，省略了几个词。经过我的多方咨询，这句话的意思是：构造函数模板就算发现参数推导匹配，也不会为我们生成拷贝构造/拷贝赋值/移动构造和移动赋值。这几个函数必须是预定义的而不能是从模板实例化的。也就是说，就算模板实例化的函数长得表面和那四个函数一样，实例化出的函数也不会被认为是特殊成员函数。**


![QQ截图20230114134638](/assets/blog_res/2022-12-14-%E6%A8%A1%E6%9D%BF.assets/QQ%E6%88%AA%E5%9B%BE20230114134638.png)

![QQ截图20230114134644](/assets/blog_res/2022-12-14-%E6%A8%A1%E6%9D%BF.assets/QQ%E6%88%AA%E5%9B%BE20230114134644.png)



- 这种行为既有好处也有坏处：
  - 某些情况下，对于某些调用，构造函数模板或者赋值运算符模板可能比预定义的拷贝或移动 构造函数或者赋值运算符更匹配，虽然这些特殊成员函数模板可能原本只打算用于在不同类型的 stack 之间做初始化。详情请参见 6.2 节。
  - 想要对拷贝或移动构造函数进行模板化并不是一件容易的事情，比如该如何限制其存在的场景。详情请参见 6.4 节。

### 5.5.3 template 关键字 （如 .template , ::template, ->template)

template关键字是用来消除歧义的. 观察下面的代码:

```c++
template<class T>
 int f(T& x) {
     return x.template convert<3>(pi);
 }
```

如果没有template, 则

```c++
return x.convert<3>(pi);
```

 可能被理解为

```c++
return ((x.convert) < 3) > (pi);
```

- **所以使用template来显式说明convert不是一个数据成员, 而是一个模板函数. 下面把标准照抄一遍.**

**使用 template 的规则**

当成员模板特化的名字出现在一个后缀表达式中的`.`或`->`之后, 或者出现一个限定标识中的嵌套的名字修饰符之后, 并且后缀表达式或限定标识显示依赖于一个模板参数时, 成员模板名字必须加template关键字作为前缀, 否则该名字就被假定为一个非模板的名字.

如果后缀表达式或者限定标识不是出现在一个模板的作用域时, 成员模板的名字就不应该加上template关键字作为前缀.



**必须使用template的场合**

在通过“`.`”,“`->`”,“`::`”限定的依赖名访问成员模板之前, template关键字必不可少.

```c++
template<class T>
 void f(T& x, T& y) {
     int n = x.template convert<int>();
     int m = y->template convert<int>();
 }

 template<class T> struct other;
 template<class T>
 struct dirived : other <T>::template base<int> {};
```

**禁止使用template的场合**

禁止用在模板之外的任何地方, 包括显式(完全)模板特化. 禁止用在using声明中.







## 5.6 变量模板

### 5.6.1 普通变量模板

在C++14之后，我们可以对变量使用模板。

```c++
template<typename T>
T my_val = 20.1234;
int main(){
    cout << my_val<int> << endl; //20
    cout << my_val<double> << endl; //20.1234
}
```

- 注意，和其它几种模板类似，这个定义最好不要出现在函数内部或者块作用域内部。不可在`main`函数内。
- 变量模板可以有默认参数。

```c++
template<typename T = double> //默认参数
T my_val = 20.1234;
int main(){
    cout << my_val<int> << endl;  //20
    cout << my_val<> << endl; //20.1234
}
```

- 在使用变量模板的时候，必须显式指明它的类型。如果直接使用变量会报错。

```c++
cout << my_val << endl; //错误
```

- 同样可以用非类型参数对变量模板进行参数化，也可以将非类型参数用于参数器的初始化。

### 5.6.2 成员变量模板

虽然不知道有啥用，但是还是整理一下。

假如我们有如下类模板：

```c++
template<typename T>
class myobj{
    public:
        static const int val = 1000; //static 和 const一起修饰变量可以在类内赋初值
};

```

如果我们不用成员变量模板，类外想访问的话比较麻烦：

```c++
int out_val = myobj<int>::val;
int main(){
    cout << out_val << endl;
    return 0;
}
```

如果我们采用成员变量模板，则可以这样使用：

```c++
template <typename T>
int out_val_T = myobj<T>::val; //成员变量模板

int out_val1 = out_val_T<int>; //直接使用

int main(){
    cout << out_val1 << endl;
    return 0;
}
```



## 5.7 模板模板参数

我们有过非类型模板参数，意思就是模板参数并不指定类型。

所以这里的模板模板参数的意思就是让模板的参数也是模板。

模板的模板参数的经典应用是在某些自定义指定储存容器类型的时候不指定元素类型。 

比如，在我们不用模板模板参数的时候，指定`stack`可能需要这么写

```c++
Stack<int, std::vector<int>> vStack; //integer Stack that uses a vector
```

如果使用模板模板参数，我们就可以这么写：

```c++
Stack<int, std::vector> vStack; //intege stack that uses a vector
```

- 函数模板和变量模板没有模板模板参数、

- 最基本的举例

```c++
template<template<typename T> class container, typename T1, typename T2> // 最基本的举例
class test{
    container<T1> a1;
    container<T2> a2;
};
```

- 茴字的三种写法, 都可以

```c++
template <typename T, template <typename> class Container>
template <typename T, template <class> class Container>
template <typename T, template <typename> typename Container>
```

- 更好的理解的写法:

```c++
template <typename T, template <typename T1> typename Container>
```

- 在上面的例子里面，我们用不到模板模板参数里面的占位符，所以也可以忽略不写。



### 模板模板参数的匹配问题

- 我们的第一个例子使用模板模板参数 [C++14]：

```c++
template <typename T, template <typename Elem, typename = std::allocator<Elem>> typename Container = std::vector>
class Stack {
    public:
        Container<T> elems; // container<T>会默认调用对应的容器的默认分配器
};
int main(){
    
    Stack<int, deque> sss; //一个stack，实现基于deque类，储存int类型数据
    Stack<int> ssss; //一个stack，使用默认值实现基于vector类，储存int类型数据 

}
```

- 上面的这段代码，是基于C++14的。我们有一个默认值。但是为什么我们显式指明了分配器？因为在C++17之前，模板模板参数必须和实际参数的模板参数匹配。因为`vector`和`deque`有两个模板参数，第一个是元素类型，第二个是分配器。虽然分配器有默认参数，但是默认参数也要被匹配。所以如果不写分配器就会出现缺少参数的情况

所以如果到了C++17，我们就可以这么写。去掉分配器：

```c++
template <typename T, template <typename> typename Container = std::vector>
```

但是这个时候会有个问题，也就是此时这样做会让`stack`模板强制要求容器模板支持第二个参数。但是比如`std::Array`就不支持第二个参数。因为它的第二个参数是非类型模板参数。所以这样写就不行。

```c++
Stack<int, array> sss;
```



- 所以如果在C++17前，我们不想指定分配器怎么办？**方法一**，使用别名模板。这时候别名模板的分配器会支持默认值。
  - 如果我们想使用array，只需要别名模板就可以。注意array的第二个参数必须给。因为没有默认值。


```c++
template <typename T>
using deq = deque<T>; //要不然用别名模板也算是显式指定容器元素类型和分配器。
template <typename T>
using arr = array<T, 10>; //注意array的第二个参数必须给。因为没有默认值。
template <typename T, template <typename> typename Container>
class Stack {
    public:
        Container<T> elems; // container<T>会默认调用对应的容器的默认分配器
};
int main(){
    
    Stack<int, deq> sss; //一个stack，实现基于deque类，储存int类型数据
	Stack<int, arr> ssss; //一个stack，实现基于array类，储存int类型数据
}
```

- 方法二，使用可变参数模板在一定程度上简化写法。但是这里array依旧不可以。因为模板参数包只能匹配相同种类的模板参数。但是array的第一个是类型模板参数，而第二个是非类型模板参数。所以想要用array依旧需要用别名模板。 ---*12.3.4章节*

```c++
template <typename T, template <typename ...> class Container>   //使用可变参数模板简化后的方式 注意array不可以 array的第二个参数是非类型模板参数
class Stack {
    public:
        Container<T> elems; // container<T>会默认调用对应的容器的默认分配器
};
int main(){
    
    Stack<int,deque> ss; //一个stack，实现基于deque类，储存int类型数据

}
```



最后，我们梳理一下那一大堆模板头的含义：

```c++
                                       ↓container类的默认参数的类型。因为没用到可以忽略  ↓ container类的默认参数。可以不写
template <typename T, template <typename U, typename Alloc = allocator<U>> class Container = deque>  
           ↑这个T意思是储存T类型数据                    ↑这个Alloc是contain类的默认方法的U类型的分配器。因为没用到可以忽略  
//上面这样做会让stack模板强制要求容器模板支持第二个参数
template <typename T, template <typename ...> class Container>   //使用可变参数模板简化后的方式
template <typename T, template <typename, typename> class Container> //不能这么写，下面container<T>会少一个参数，但是你上面必须写俩必须写分配.
```





# 第六章 enable_if

**目前，类模板无法应用这个东西。针对于类模板，enable_if只能起到一种static_assert的作用。由于类和类模板不能重载，所以自然不存在候选集这个东西。也不存在SFINAE。enable_if在应用中的感觉是一种调整候选集的作用。**

**在函数模板中，enable_if起到的作用是活用了SFINAE的特性。**

https://stackoverflow.com/questions/48045559/how-do-i-declare-sfinae-class

https://stackoverflow.com/questions/16972684/how-to-use-enable-if-for-restricting-a-whole-class

## 6.2 特殊成员函数模板 (笔记这里尤其指构造函数模板)

特殊成员函数也可以是模板，比如构造函数，但是有时候这可能会带来令人意外的结果。

```c++
class Person
{
    private:
        string name;
    public:
    // constructor for passed initial name:
    explicit Person(const string& n) : name(n) { //构造函数。注意这里不是拷贝构造。参数不是person
        cout << "此处是拷贝字符串进来 " << name << endl;
    }
    explicit Person(string&& n) : name(move(n)) { //构造函数。注意这里不是移动构造。参数不是person
        //里面的move是为了给字符串自己转为右值。触发string的移动
        cout << "此处是移动字符串进来 " << name << endl;
    }
    // copy and move constructor:
    Person (const Person& p) : name(p.name) { //拷贝构造
        cout << "此处是拷贝person对象进来 " << name << endl;
    }
    Person (Person&& p) : name(move(p.name)) { //移动构造
        cout << "此处是移动person对象进来 " << name << endl;
        //里面的move是为了给传入对象自己的string转为右值。然后触发string的移动
    }
};

int main(){
    string names = "miku";
    Person p1(names); //拷贝字符串
    Person p2("miku");//"miku"是字面值，虽然字符串字面值是左值，但是现在它是个临时对象。所以会触发移动。这里是移动字符串。
    Person p3(p1); //拷贝对象
    Person p4(move(p1));//移动对象。这个move是转换p1为右值调用person的移动。
}
```

一切都看起来不错。我们注意到针对使用`string`来构造`person`对象的时候，我们写了两个函数。一个针对左值`string`,一个针对右值`string`。下面我们尝试使用一下万能引用+完美转发来把两个函数合到一起。

```c++
class Person
{
    private:
        string name;
    public:
    template <typename T>
    explicit Person(T&& n) : name(forward<T>(n)) {
        cout << "万能引用+forward兼顾左值和右值。" << name << endl;
    }
    // copy and move constructor:
    Person (Person const& p) : name(p.name) { //没有变化
        cout << "此处是拷贝person对象进来 " << name << endl;
    }
    Person (Person&& p) : name(move(p.name)) { //没有变化
        cout << "此处是移动person对象进来 " << name << endl;
    }
};
```

好的，让我们测试一下

```c++
int main(){
    string names = "miku";
    Person p1(names); //万能引用+forward兼顾左值和右值。
    Person p2("miku");//万能引用+forward兼顾左值和右值。
}
```

真不错，一切都看起来如我们所愿。针对左值和右值的`string`类，成功匹配到了万能引用的构造函数。

注意这里在构建` p2` 的时候并不会创建一个临时的 `string` 对象：`T`的类型不会退化，因为万能引用也是引用。所以`T`会被推断为`const char[4]`。但是将 `forward<T>`用于指针参数没有太大意义。成员 `name `将会被一个以`null` 结尾的字符串构造。

但是，当试图调用拷贝构造的时候，会遇到错误：

```c++
Person p3(p1); //拷贝对象
```

但是调用移动构造却没有问题：

```c++
Person p4(move(p1));//移动对象。输出此处是移动person对象进来 
```

而且使用一个`const Person`对象来（触发拷贝构造来）初始化也没问题

```c++
const Person cp1("miku");
Person cp2(cp1); //注意是使用const对象初始化，而不是自己是const对象
//输出：此处是拷贝person对象进来 
```

那么原因是什么呢？问题出现在重载决议。

- 首先我们知道两点：
  - 如果函数模板可以实例化出一个比普通函数更完美的函数，那么会优先使用模板。只有所有情况都相同的时候，才会优先使用普通函数（1.5）
  - 在重载决议的图当中，我们看到了`qualification conversion`是第三档。

所以在这个时候，编译器发现通过构造函数模板实例化的函数会比拷贝构造更匹配：

```c++
template<typename T> 
Person(T&& n)
```

在这里，`T`会被替换成`Person&`

> 去杂记看函数模板推导。这里传入的参数是`Person`，函数形参是`T&&`, 则模板参数T会被推导为`T&`。随后引用折叠会变成函数形参为`Person&`

这明显比 `const Person&`更好，因为使用这个的话还需要进行`qualification conversion`

但是问题在这里，我们的构造函数里面怎么写的？

```c++
name(forward<T>(n));
```

我们是尝试用`n`去初始化`name`。但是`name`是`string`，`n`是`Person`。你能用一个`Person`对象初始化`string`对象吗？肯定不行，这啥玩意呀。

- 所以这时候，如果我们额外提供一个非`const`的拷贝构造，那么没有问题

```c++
Person (Person& p) : name(p.name) { //非const的拷贝构造
    cout << "此处是拷贝person对象进来, 非const的拷贝构造" << name << endl;
}
string names = "miku";
Person p1(names); //拷贝字符串
Person p3(p1); //输出：此处是拷贝person对象进来, 非const的拷贝构造
```

但是这样做不够优雅，我们6.3会讲一些关于`enable_if`的知识。然后我们在6.4会介绍如何搭配`enable_if`来禁用一些模板



- **无法为构造函数显式指定模板参数类型。**

```c++
Person<int> f = Person<int>();
```

**如上是不可以的。因为`int`被视为是`Person`的模板参数类型而不是其构造函数的模板参数类型。构造函数的模板参数类型只能通过型别推导。这也是为什么模板构造函数非常适合搭配完美转发进行使用。**

## 6.3 使用enable_if

`enable_if`可以让我们在某些**编译期条件**下忽略掉函数模板。

比如，如果函数模板`func`的定义如下：

```c++
template<typename T>
typename std::enable_if<(sizeof(T) > 4)>::type func() {
	//一些内容
}
```

这一模板定义会在 `sizeof(T) > 4` 不成立的时候被忽略掉。如果` sizeof(T) > 4` 成立，函数模板会展开成：

```c++
template<typename T>
void func() {
    //一些内容
}
```

在`enable_if`拥有第二个模板参数的时候，如果满足第一个参数的表达式，就会扩展成第二个模板参数。

```c++
template<typename T>
typename std::enable_if<(sizeof(T) > 4, MyType)>::type func() {
	//一些内容
}
```

那么在 `sizeof(T) > 4`时，`enable_if `会被扩展成其第二个模板参数。因此如果与` T `对应的模板参数被推断为` MyType`，而且其 `size` 大于 4，那么其等效于：`MyType func();`



也就是说 `std::enable_if<>`是一种类型萃取（type trait），它会根据一个作为其（第一个）模板参数的编译期表达式决定其行为：

- 如果这个表达式结果为 true，它的 type 成员会返回一个类型：
  - 如果没有第二个模板参数，返回类型是 `void`。
  - 否则，返回类型是其第二个参数的类型。

- 如果表达式结果 false，则其成员类型是未定义的。根据模板的一个叫做 SFINAE（substitute failure is not an error，替换失败不是错误的规则，这会导致包含 `std::enable_if<>`表达式的函数模板被忽略掉。

- **简而言之，意思就是，前面的表达式为真，后面的类型定义才有意义。**

简单看一下原型

```c++
template <bool, typename T=void>
struct enable_if {
};
template <typename T>
struct enable_if<true, T> { ///< 第一个模板参数为 true
  using type = T;           ///< type 才有定义
};
```

一般三种用法：

- 控制函数返回类型
- 校验函数模板参数类型
- 类型偏特化

这里就随便写个控制函数返回类型的例子：

```c++
template<int stat> //这里是非模板类型参数。上面提到了。注意一下
typename enable_if<stat == 1, bool>::type checkstate(){
    cout <<"type is bool" << endl;
    return true;
}
template<int stat>
typename enable_if<stat == 0, int>::type checkstate(){
    cout <<"type is int" << endl;
    return 5;
}

template<bool stat>			//bool也可以。隐式转换为整型了，但是必须要常量。
typename enable_if<stat == true, int>::type checkstate1(){
    cout <<"type is int" << endl;
    return 5;
}

int main(){
    const int myobj = 1; 	//必须是const
    checkstate<myobj>();	//输出"type is bool" 
    checkstate<0>();		//输出"type is int" 
    return 0;
}
```

- 注意事项：在C++14前，不使用`enable_if_t`的时候，返回类型前必须加`typename`来告知`enable_if::type`是个类型。还有就是非模板类型参数的限制。



**到了c++14，我们可以使用`enable_if_t`来简化这一部分。我们无需在后面指定`::type`，自然同时也无需在前面使用`typename`。如这样：**

```c++
template <int stat>
enable_if_t<stat == 1, bool> anotherCheck(){ //没有::type 也没有typename
    cout <<"type is bool" << endl;
    return true;
}
anotherCheck<1>();//一样使用
anotherCheck<0>(); //绝对不可以。就算有SFINAE,那是告诉你匹配不对的时候继续找，不报错。但是这里我们没写stat = 0情况，自然无论如何都找不到，重载决议找不到函数，调用一定会失败。所以报错。
```

### 给enable_if 添加一个额外的带默认值的参数

- 我们也可以给`enable_if_t`的第二个参数加上一个默认参数。但是长得会和之前的不太一样。之前我们是直接把整个`enable_if_t`或者是`typename enable_if::type `当成函数返回值。

```c++
template<typename T, typename = std::enable_if_t<(sizeof(T) > 4)>>
T foo(T a) {
    cout << a << endl;
    return a;
}
foo<double>(20.123);//没问题
```

- 当然了，也可以使用非类型模板参数，像是这样：

```c++
template <int value, typename = enable_if_t<value == 2>>
void myfunc(){
    cout <<"2" << endl;
}
myfunc<2>();//也没问题
```

- 有一点需要澄清。这里的模板头如何解释？

我们这里的第二个`typename`是一个独立的模板参数，仅仅是没有加名字。因为我们没有使用到它。所以如果你愿意，你也可以这样写

```c++
template <int value, typename whatever = enable_if_t<value == 2>>
```

我们知道了如果`enable_if_t`的第一个表达式为真，则这里是通过的。又由于在当下这个例子，我们是非类型模板参数而且`enable_if_t`没有给第二个参数，所以函数返回值就是`void`。

如果表达式为假，则会走SFINAE这一套。此处不会编译。针对当下的例子，如果没有做不等于`2`的条件的处理，则会报错找不到对应的函数。

但是这时候有个问题了，如果针对第一个函数，我们想让`sizeof(T) < 4`也成为一个模板怎么办？我们可能会直接这么写：

```c++
template<typename T, typename = std::enable_if<(sizeof(T) > 4)>>
T foo(T a) {
    cout << ">4" << endl;
    return a;
}
template<typename T, typename = std::enable_if<(sizeof(T) <= 4)>> //错误，重定义了。
T foo(T a) {
    cout << "<=4" << endl;
    return a;
}
```

 这样是错误的，提示重定义了。为什么？

### enable_if 导致的的函数模板重定义问题

我们知道了，enable_if 第二个参数的默认值是void（也就是表达式为真的时候，没有指定第二个参数就默认值是void）

所以当如果前面表达式为真的时候，这个函数会被展开成这个样子

```c++
template<typename T, typename = std::enable_if_t<(sizeof(T) > 4)>>
void func() {
    
}
//展开后：
template<typename T, typename = void>
void func() {
}
```

所以如果我们还有一个`<=4`，当也为真的时候，那这个整个模板头的参数就都一样了。

**但是函数模板参数的默认值的不同并不足以区分两个函数模板是重载关系。**官方是这么说的：

> 常见错误是声明二个函数模板，而它们仅于其默认模板实参相异。这是无效的，因为这些函数声明被当做同一函数模板的再声明（默认模板实参不为[函数模板等价](https://zh.cppreference.com/w/cpp/language/function_template#.E5.87.BD.E6.95.B0.E6.A8.A1.E6.9D.BF.E9.87.8D.E8.BD.BD)所考虑）。

所以。上面的代码。在编译器看来是这样的：

```c++
template<typename T, typename>
T foo(T a);
template<typename T, typename>
T foo(T a);
```

这就很明显是重定义了。因为我们只有第二个模板参数的默认值是不同的。但是默认值不在签名范围内。就好比不能通过默认值不同重载不同函数一样。

那么我们如何解决这个问题呢？我们可以让第二个参数本身不同即可。

我们刚说过，上面那种的模板类型区分不开：`template<typename, typename> `。那么我们应该这么写：

```c++
typename<typename T, std::enable_if_t<condition>* whatever = nullptr>
//或老版本的
typename<typename T, typename std::enable_if<condition>::type* whatever = nullptr>
//老版本依旧必须有typename，为了告知type是个类型
```

在这里，编译器看到的模板类型是这样的：`template<typename, X*>`。这里的`X*`的类型依赖于第一个参数的类型。所以此时足以区分

这里的`whatever`可以去掉。因为我们函数内并不使用它。

详细例子：

```c++
template <typename T1, enable_if_t<(sizeof(T1) > 4)>* whatever = nullptr> //带t的新版
T1 functions(T1 a){
    cout << a << endl;
    cout <<" <=4" << endl;
    return a;
}
template <typename T1, enable_if_t<(sizeof(T1) <= 4)>* whatever = nullptr>
T1 functions(T1 a){
    cout << a << endl;
    cout <<" <=4" << endl;
    return a;
}



template <typename T1,  typename enable_if<(sizeof(T1) > 4)>::type* whatever = nullptr> //不带t的老版
T1 functions(T1 a){
    cout << a << endl;
    cout <<" > 4" << endl;
    return a;
}
template <typename T1,  typename enable_if<(sizeof(T1) <= 4)>::type* whatever = nullptr>
T1 functions(T1 a){
    cout << a << endl;
    cout <<" <= 4" << endl;
    return a;
}

functions<double>(10.123);
functions<int>(10);



//模板参数和非类型模板参数混用：
template <typename T, int T1,  enable_if_t<(T1 > 4)>* whatever = nullptr>
T functions(T a){
    cout << a << endl;
    cout <<" > 4" << endl;
    return a;
}
template <typename T, int T1,  enable_if_t<(T1 <= 4)>* whatever = nullptr>
T functions(T a){
    cout << a << endl;
    cout <<" <= 4" << endl;
    return a;
}
functions<double, 8>(10.123);
functions<string, 2>("12345");
```



当然了，这时候我们也可以使用`using`别名模板来让代码看起来更加简单。





https://stackoverflow.com/questions/52083873/c-sfinae-enable-if-t-in-member-function-how-to-disambiguate

https://stackoverflow.com/questions/31500426/why-does-enable-if-t-in-template-arguments-complains-about-redefinitions



## 6.4 使用enable_if 禁用某些模板

我们在6.2当中介绍了一个例子，在6.3当中学习了一下enable_if，这里我们就针对6.2当中的例子进行优化。

- 6.2中我们想解决的问题是：如果传入的参数不能被转换为string，则不要使用其构造函数模板。
  - 我们在6.2当中解决问题的方式是添加一个非`const`的拷贝构造。我们在这里不这样做，而是使用`enable_if`在某些条件下禁用构造函数模板。

也就是当传递的模板参数的类型不正确的时候（比如不是 `std::string`或者可以转换成` std::string `的类型），禁用如下构造函数模板：

```c++
template<typename T>
Person(T&& n)
```

所以我们搭配`is_convertiable<FROM, TO>`来进行使用（此处看下面讲解）

```c++
template <typename T, typename = std::enable_if_t<std::is_convertible_v<T,std::string>>>
Person(T&& n)
```

如果T可以被转换为string，则这个定义会被扩展为：

```c++
template<typename T, typename = void>
Person(T&& n);
```

否则这个函数模板会被忽略。

- 所以现在代码是这个样子 **[c++17]**：

```c++
class Person
{
    private:
        string name;
    public:
    template <typename T, typename = std::enable_if_t<std::is_convertible_v<T,std::string>>>
    explicit Person(T&& n) : name(forward<T>(n)) {
        cout << "万能引用+forward兼顾左值和右值。" << name << endl;
    }
    Person (Person const& p) : name(p.name) { //没有变化
        cout << "此处是拷贝person对象进来 " << name << endl;
    }
    Person (Person&& p) : name(move(p.name)) { //没有变化
        cout << "此处是移动person对象进来 " << name << endl;
    }
};
int main(){
    string names = "miku";
    Person p1(names); //拷贝字符串 输出万能引用+forward兼顾左值和右值。
    Person p3(p1); //拷贝对象 输出此处是拷贝person对象进来。
}
```

当然此处也可以使用别名模板简化，比如

```c++
using EnableIfString = std::enable_if_t<std::is_convertible_v<T,std::string>>;
```

一切皆大欢喜！

- 由于**c++14**没有给产生一个值的类型萃取定义带`_v` 的别名，所以得这么写：

```c++
template <typename T, typename = std::enable_if_t<std::is_convertible<T,std::string>::value>>
```

- 由于**c++11**没有给产生一个类型的类型萃取定义带`_t` 的别名，所以得这么写：

```c++
template <typename T, typename = typename std::enable_if<std::is_convertible<T,std::string>::value>::type>
```

以上都可以使用别名模板。



00

## 6.5 禁用某些特殊成员函数

- 注意我们不能通过使用 `enable_if<>`来禁用 **拷贝或移动 构造函数以及其赋值函数**。这是因为**成员函数模板不会被算作拷贝构造或移动构造函数（依然会生成其默认版本）**，而且在需要使用这些函数的地方，相应的成员函数模板会被忽略掉。

所以就算我们有这样的类模板：

```c++
class C {
	public:
		template<typename T>
		C (T const&) {
			std::cout << "tmpl copy constructor\n";
        }
};
```

- 在需要拷贝构造的时候，依然会调用到编译器合成的拷贝构造。
- 删掉拷贝构造函数也不行，因为这样在需要 拷贝构造函数的地方会报错说该函数被删除了。

如果你硬要弄成模板的话，这么做：定义一个接受 `const volatile` 的 拷贝构造函数并将其标示为`delete`。这样做编译器就不会再隐式合成一个接受 `const` 参数的拷贝构造函数。在此基础上，可以定义一个**构造函数模板**，对于 non-volatile 的类型，它会优选被选择（相较于已删除的 copy 构造函数）**注意这里是定义一个构造函数模板而不是拷贝构造函数模板。具体分析在最后“特殊成员函数能否是函数模板**

- 这个东西叫做**使用模板构造函数替代拷贝构造函数**。这样做是极度不推荐的！！！

```c++
class C{
    public:
        int val;
        C() = default;

        C(int a):val(a){};

        C(const volatile C&) = delete;

        template<typename T>
        C(const T&){ //这是构造函数模板不是拷贝构造函数模板。
            cout <<"template" << endl;
        }
};
int main(){
    C obj1(10);
    C obj2(obj1); //template
}
```

- **注意，构造函数除外。**

## 6.6 关于对整个类使用enable if

**目前，类模板无法应用这个东西。针对于类模板，enable_if只能起到一种static_assert的作用。由于类和类模板不能重载，所以自然不存在候选集这个东西。也不存在SFINAE。enable_if在应用中的感觉是一种调整候选集的作用。**

**在函数模板中，enable_if起到的作用是活用了SFINAE的特性。**

如果硬要昂做static_assert是什么样的？

```c++
template<typename T, typename = void> //主模板。注意这里。必须有默认值。但是类型需要判断一下
struct test{

};
template<typename T>
struct test<T, typename std::enable_if<(sizeof(T) <= 1)>::type>{ //偏特化。
    void func(){
        cout << "called" << endl;
    }
};
//template<typename T> 不可这么写
// struct test<T, typename std::enable_if<(sizeof(T) <= 1)>::type>{
//     void func(){
//         cout << "called" << endl;
//     }
// };
```



- 第一点。必须采用偏特化的形式。而且因为类模板没有重载所以不能写最下面那一组。只能要么主模板，要么一个偏特化版本。
- 第二点：主模板的第二个对应了enable_if的模板参数必须有默认值为 为什么？
  - 首先，我们主模板有了两个模板参数。我们如果没有默认值，则调用的时候比如`test<int> objs1;`此时我们只显式指定了一个模板参数。类模板没法自动推导参数，那么第二个参数是空白的。编译不通过。
  - 其次，因为一旦enable_if的要求我们不能满足，在这里enable_if我们没有第二个参数，所以这个type会是void。
- 第三点：为什么默认值这里用了void，别的可以不？
  - 我们要把默认值理解为：虽然我们不需要显式指定，但是它依旧存在。什么意思？

假设我们现在把上面的默认值换位了`double`。现在是这样

```c++
template<typename T, typename = double>
struct test{
    void func(){
        cout << "default" << endl;
    }
};
template<typename T>
struct test<T, typename std::enable_if<(sizeof(T) <= 1)>::type>{
    void func(){
        cout << "called" << endl;
    }
};
int main() {
    test<char> objs1;
    objs1.func(); //输出default
    test<int> objs2;
    objs2.func(); //还是输出default
}
```

为什么两个都是`default`？

我们思考一下刚才说的：我们要把默认值理解为：虽然我们不需要显式指定，但是它依旧存在。

我们显式补齐参数类型来看一下：

```c++
test<char, double> objs1;
objs1.func();
test<int, double> objs2;
objs2.func();
```

因为我们提到了：在这里`enable_if`我们没有第二个参数，所以这个type会是`void`。

- 所以针对`objs1`，编译时发现第二个条件满足，所以此时模板参数的第二个参数会是`void`。

但是我们的默认值是`double`。相当于我们传入了`<char, double>`。但是偏特化版本实例化出来的是`<char, void>`。我们发现明显是默认版本符合参数要求。所以一定会调用`default`。

- 此时针对`obj2`，编译时发现第二个条件不满足，但是发现主模板匹配。则匹配主模板。

此时，如果我们显式的使用`<char, void>`，则可以正确满足条件。

```c++
test<char, void> objs3; // called
```

这个时候，我们显式指定的值会覆盖掉默认值。此时第二个参数是`void`。而针对于偏特化版本`enable_if`推断的第二个参数也是`void`。此时明显偏特化版本符合。所以这时候会调用偏特化。



所以按理说，如果我们把特化版本的`enable_if`，让他的第二个参数和主模板的类型默认值相等，这样做就可以。

```c++
template<typename T, typename = double>
struct test{
    void func(){
        cout << "default" << endl;
    }
};
template<typename T>
struct test<T, typename std::enable_if<(sizeof(T) <= 1), double>::type>{ //第二个参数和默认值相等
    void func(){
        cout << "called" << endl;
    }
};
test<char> objs1;
objs1.func();
test<int> objs2;
objs2.func();
```

- 此时针对`obj1`， 编译时发现第二个条件满足，且有第二个参数。所以此时模板参数的第二个参数会是`double`。

  - 又因为默认值是`double`，但是类模板的调用顺序是 全特化类>偏特化类>主模板类。这个时候主模板和偏特化类都符合，则优先调用偏特化类。

- 此时针对`obj2`，编译时发现第二个条件不满足，但是发现主模板匹配。则匹配主模板。




https://stackoverflow.com/questions/48045559/how-do-i-declare-sfinae-class

https://stackoverflow.com/questions/16972684/how-to-use-enable-if-for-restricting-a-whole-class

https://stackoverflow.com/questions/75154649/why-when-use-enable-if-in-class-tempalte-have-to-set-the-second-parameters-defa/75154785?noredirect=1#comment132622904_75154785

# 第七章 到底是按值传递还是按引用传递？

一般来说，我们在使用引用传递的时候，会有三种情况。

虽然已经是老生常谈，但是这里还是写一下做一下recall。下面的`X`指的是具体类型。

- 按照常量左值引用传递

  - `const X&`
    - 由于什么类型的参数都可以接。包括右值。但是不可修改参数。所以主要目的是防止拷贝，并且接收任意类型数据。

- 按照左值引用传递

  - `X&` 
    - 主要目的是为了更改参数，并且防止拷贝。

- 按照右值引用传递

  - `X&&`

    - 主要是为了接收形参为右值的参数。参数可以被更改或被窃取。

    ```c++
    //更改的例子
    //注意不能直接写，要写完美转发。因为具名右值是左值。
    void func(int&& a){
        a = 200;
    }
    
    template<typename T>
    void capsule(T&& c){
        cout << c << endl; //20
        func(forward<T>(c));
        cout << c << endl;//200
    }
    int main(){
        capsule(20);
        return 0;
    }
    ```

    

**一般来说，在如下情况下我们需要使用引用传递参数。**

- 对象不允许被拷贝的时候
- 入参需要被修改的时候（参数被用于返回数据）
- 参数及其所有属性需要被模板转发到别的地方的时候。

- 拷贝开销极大，所以使用引用传递可以获得明显的性能提升之时。

**其余情况可以使用值传递。**

## 7.1 按值传递

> 有关临时对象，隐式类型转换的笔记在杂记2
>
> 有关各种拷贝构造相关的在杂记

我们先来简单看看按值传递的情况

当按值传递参数时，原则上所有的参数都会被拷贝。因此每一个参数都会是被传递实参的一份拷贝。对于 `T`类的对象，参数会通过 `T`类的拷贝构造函数来做初始化。

事实上，编译器自己可以通过移动语义（move semantics）来优化掉对象的拷贝，这样即使是对复杂类型的拷贝，其成本也不会很高。

假设我们有如下函数模板:

```c++
template<typename T>
void func(T obj){
    //一些内容
}
```

在我们应用于`myobj`类型参数后，实例化后的代码为

```c++
void func(myobj obj){
    //一些内容
}

myobj v1(10);
func(v1);
```

传递`myobj`类型的时候，`obj`会是传入参数v1的拷贝。如果`myobj`类型对象的拷贝的成本非常高，那么会很痛苦。但并不是所有情况都会调用拷贝构造

```c++
//假设myobj类对象提供了全部6个特殊成员函数，所以

myobj a(20); //构造

func(a); //拷贝构造

func(myobj(20)); //构造 注意，只有一次构造。

func(move(a)); //移动构造
```

在第一次调用中，被传递的参数是左值（lvalue)，因此拷贝构造函数会被调用。

但是在第二次调用中，被传递的参数是纯右值 （prvalue 多在临时对象或者某个函数的返回值)，此时编译器会优化参数传递，使得拷贝构造函数不会被调用。**从C++17开始，C++标准要求这一优化方案必须被实现。在C++17之前，如果编译器没有优化掉这一类拷贝，它至少应该先尝试使用移动语义，这通常也会使拷贝成本变得比较低廉**。

> 编译器会尝试拷贝优化，如果不行，会尝试移动语义。

在最后一次调用中，被传递参数是将亡值（xvalue ，一个使用了`move()`的已经存在的对象), 这会通过告知编译器我们不再需要`a`的值。通过这种方式，我们强制调用移动构造。

> NRV优化在杂记2。复制省略在杂记3

- 再次重申按照值传递会导致参数类型退化。`auto`也会退化。(杂记3)




## 7.2 按引用传递

### 7.2.1 按常量左值引用传递 `const&`

为了避免（不必要的）拷贝，在传递非临时对象作为参数时，可以使用` const `引用传递。

- **比如这个函数模板就永远不会拷贝被传递对象**

```c++
template <typename T>
void func(const T&){
    //一些内容
}
```

- **内置类型通过引用传递不会提升性能。**

之所以不能提高性能，**是因为在底层实现上，按引用传递还是通过传递参数的地址实现的。地址会被简单编码，这样可以提高从调用者向被调用者传递地址的效率。不过按地址传递可能会使编译器在编译调用者的代码时有一些困惑：被调用者会怎么处理这个地址？理**
**论上被调用者可以随意更改该地址指向的内容。这样编译器就要假设在这次调用之后，所有缓存在寄存器中的值可能都会变为无效。**而重新载入这些变量的值可能会很耗时（可能比拷贝对象的成本高很多）。你或许会问在按 `const` 引用传递参数时：为什么编译器不能推断出
被调用者不会改变参数的值？不幸的是，确实不能，**因为调用者可能会通过它自己的非` const`引用修改被引用对象的值（这个解释太好，另一种情况是被调用者可以通过` const_cast `移除参数中的` const`）**。

inline可能会对此情况有所优化。

- 按照引用传递不会引发类型退化。**也就是说数组不退化为指针，也不会移除CV限定。但是要注意函数模板参数类型。**
  - `T`的类型推断不会是一个`const`类型，因为`const`已经是函数参数的一部分了，所以不会是模板参数类型的一部分。这里搭配1.2和函数模板参数推导看。


```c++
template <typename T>
void f(T& param) { //注意这里是T& 
    std::puts(__PRETTY_FUNCTION__);
}

int main() {
    const int p = 2;
    f(p); //T的类型为const int。很好理解。因为引用不会去除cv
    //所以在f函数内使用T声明的变量自然会带const
}
```

但是如果是这样的：

```c++
template <typename T>
void f(const T& param) { //注意这里是const T&
    std::puts(__PRETTY_FUNCTION__);
}

int main() {
    const int p = 2; //T的类型为int。也很好理解。因为const已经被函数模板参数匹配了。T自然就剩下了int。
    //所以在f函数内使用T声明的变量自然不会带const
    f(p);
}
```



### 7.2.2 按照普通（左值/右值）引用传递

如果想通过调用参数来返回变量值（比如修改被传递变量的值），就需要使用非 `const` 引用（要么就使用指针）。同样这时候也不会拷贝被传递的参数。被调用的函数模板可以直接访问被传递的参数。

假如我们有如下函数模板：

```c++
template<typename T>
void func (T& arg) { 
    //一些内容
}
int main() {
    string s = "miku";
    func(s); 
    func(string("miku"));//不可以。左值引用不可绑定右值
    func(move(s));//不可以。左值引用不可绑定右值
}
```

左值引用不可绑定右值（废话）

- 但是有个问题。如果传入的参数是`const`的。则在一些情况下参数类型会被推导为`const`引用。也就是这时候可以传递右值。

  - 原因：`const`引用的初始化方式：在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。----《C++ Primer》第五版2.4.1第55页

    - 这就是为什么常量左值引用可以接任何类型参数。
    - 也就是你可以这样：

    ```c++
    const string& a = string("abc");
    string s = "miku";
    const string& b = move(s); //注意这里并不调用移动构造或移动赋值。因为并没有构造对象或者是进行赋值。
    ```

所以说一旦我们把东西换成这样：

```c++
template<typename T>
void func (T& arg) { 
    //一些内容
}
int main() {
    const string s = "miku"; //换成const
    func(s); 
    func(string("miku"));//不可以。左值引用不可绑定右值
    func(move(s));//可以。T被推导为const string
}
```

- **在这种情况下，在函数模板内部，任何试图更改被传递参数的值的行为都是错误的。**所以我们可以使用`enable_if`或`static_assert`搭配`is_const`来禁止向非`const`应用传递`const`对象

```c++
//使用static_assert
template<typename T>
void func (T& arg) { 
    static_assert(!is_const<T>::value, "can't use const type variable");
    cout << "called" << endl;
}

//使用enable_if
template<typename T, typename = enable_if_t<!is_const<T>::value>>
void func (T& arg) { 
    cout << "called" << endl;
}
```



### 7.2.3 按照万能引用传递 `T&&`

在杂记中我们详细说明了万能引用和引用折叠的部分。这里就不赘述了。

**唯一要再次提醒的是，万能引用是唯一一种可能把`T`推导为引用类型的情况。因为有引用折叠。**

比如

```c++
template <typename T>
void f(T&& param) {
    std::puts(__PRETTY_FUNCTION__);
}


int s =5;
int& ref = s;
const int& ref2 = s;
f(5); //T推导为 int
f(ref);//T推导为 int&
f(ref2);//T推导为 const int&
```

- 在第二次调用中，如果在模板内部直接用 T 声明一个未初始化的局部变量，就会触发一个错误（引用对象在创建的时候必须被初始化）所以需要格外的注意。



## 7.3 使用ref和cref

看下面的ref和cref介绍即可。



## 7.5 处理返回值。

返回值也可以被按引用或者按值返回。但是按引用返回可能会带来一些麻烦，因为它所引用的对象不能被很好的控制。不过在日常编程中，也有一些情况更倾向于按引用返回：

- 返回容器或者字符串中的元素（比如通过`[]`运算符或者 `front()`方法访问元素）---EFFSTL笔记提到过。
- 允许修改类对象的成员
- 为链式调用返回一个对象（比如`>>`和`<<`运算符以及**赋值运算符**）

**但是使用不当可能会造成悬空引用。因此如何保证函数模板可以采用按值返回是一个问题。**

因为：

- **在某些情况下，尤指万能引用的时候，`T`会被隐式推断为引用类型**

```c++
template<typename T>
T retR(T&& p){ // p 是万能引用
	return T{…}; // 一旦传入的T类型是左值或左值引用，则T会被统一推导为引用类型。此时T就变成引用了。
}
```

- 即使函数模板被声明为按值传递，也可以显式地将 `T` 指定为引用类型：

```c++
template<typename T>
T retV(T p){  //T完全可以被指定为引用类型 比如：
	return T{…}; 
}
int x;
retV<int&>(x); // 在这里，显式指定这个函数模板的模板参数T为int&。
```

**所以，解决方案有两个。**

- 第一个：使用类型萃取的`remove_reference`去掉`T`类型的引用。（下面有提到该部分）
  - `decay`也可以。目前还没有看到这一部分。

```c++
template<typename T>
typename remove_reference<T>::type retV(T p){
	return T{…}; // T一定会被推导为非引用类型
}
```

- 第二个：声明返回值为`auto`类型。`auto`类型会导致类型退化，也就是隐式去掉类型的引用。杂记3中提到过。

```c++
template<typename T>
auto retV(T p){//返回值设置为auto
	return T{…}; //一定会被推导为非引用类型。
}
```

## 7.6 应该如何声明模板参数？

我们在拷贝构造一章中详细分析了如何构建构造函数和几种方法的优劣。这里谈一谈和模板参数结合的情况。

- **将参数声明成按值传递：**
  - 这一方法很简单，它会对字符串常量和裸数组的类型进行退化，但是对比较大的对象可能会受影响性能。在这种情况下，调用者仍然可以通过 `cref()`和 `ref()`按引用传递参数，但是要确保这一用法是有效的。
- **将参数声明成按引用传递：**
  - 对于比较大的对象这一方法能够提供比较好的性能。尤其是在下面几种情况下：
    - 将已经存在的对象（`lvalue`）按照左值引用传递，
    - 将临时对象（`prvalue`）或者被 `move()`转换为可移动的对象（`xvalue`）按右值引用传递，
  -  或者是将以上几种类型的对象按照万能引用+完美转发传递。
  - **由于这几种情况下参数类型都不会退化，因此在传递字符串常量和裸数组时要格外小心。**
  - **对于万能引用，需要意识到模板参数可能会被隐式推断为引用类型（引用折叠）。**

综上所述：

- 默认情况下，将参数声明为按值传递。这样做比较简单，即使对字符串常量也可以正常工作。对于比较小的对象、临时对象以及可移动对象，其性能也还不错。对于比较大的对象，为了避免成本高昂的拷贝，可以使用 `ref()`和` cref()`。
- 如果需要一个参数用于输出，或者即用于输入也用于输出，那么就将这个参数按非`const` 引用传递。但是需要按照 7.2.2 节介绍的方法禁止其接受 `const` 对象。因为针对普通引用类型为形参，如果传入一个`const`引用则会带着其形参推导为`const`引用。
- **如果使用模板是为了转发它的参数，那么就使用完美转发。**也就是将参数声明为万能引用并在合适的地方使用 `forward<>()`。考虑使用`decay<>`或者 `common_type<>`来处理不同的字符串常量类型以及裸数组类型的情况。
- 如果重点考虑程序性能，而参数拷贝的成本又很高，那么就使用` const` 引用。不过如果最终还是要对对象进行局部拷贝的话，这一条建议不适用

## 7.7 不要过分泛型化

通常来说，我们在使用函数模板的时候，不可能允许该函数传递任意类型的对象。因为针对不同的对象我们会有不同的操作。比如我们可能已经知道函数模板的参数只会是某些类型的` vector`。这时候最好不要将该函数模板定义的过于泛型化，否则，可能会有一些令人意外的副作用。针对这种情况应该使用如下的方式定义模板：

```c++
template<typename T>
void printVector (const vector<T>& v){ //为啥不是T v?
    //一些内容
}
```

- 为啥我们不直接`T v`？
  - 首先，我们可以确定`T`不可能是引用类型。因为传入的参数必定是一个`vector`，变动的只是`vector`存储的元素类型。因为容器不能使用引用作为其元素类型。
  - 其次，通常来说，针对容器我们会使用引用传递。因为不必要的拷贝会极大降低性能。甚至针对不修改的情况我们要使用`const`引用传递。
  - 最后，使用这种不过分泛型化的参数传递可以很容易的让其他人看出来我们这个函数的作用：它会干什么，它不会干什么。如果我们直接传入一个`T`，则会非常不清晰。



# 第八章 编译期编程

## 8.4 SFIANE

>  在一个函数调用的备选方案中包含函数模板时，编译器首先要决定应该将什么样的模板参数用于各种模板方案，然后用这些参数替换函数模板的参数列表以及返回类型，最后评估替换后的函数模板和这个调用的匹配情况（就像常规函数一样）。但是这一替换过程可能会遇到问题：**替换产生的结果可能没有意义。不过这一类型的替换不会导致错误，C++语言规则要求忽略掉这一类型的替换结果。**

但是上面讲到的替换过程和实际的实例化过程不一样：**即使对那些最终被证明不需要被实例化的模板也要进行替换（不然就无法知道到底需不需要实例化）**。**不过它只会替换直接出现在函数模板声明中的相关内容（不包含函数体）**

我们有下面的例子：

```c++
template<typename T, unsigned N>
std::size_t len (T(&)[N]){ //这个版本是为没有size_type成员的对象准备的。
    cout <<"no size" << endl;
    return N;
}

template<typename T>
typename T::size_type len (T const& t){ //这个版本是为有size_type成员的对象准备的。
    cout <<"size" << endl;
    return t.size(); //同时要求必须有size成员函数
}

std::size_t len (...) //使用可变参数来对其他任何没有size_type成员
{
    cout <<"other" << endl;
    return 0;
}

int main(){
    int a[10];
    len(a); // OK 原始数组没有size_type
    len("tmp"); //OK: 字符串没有size_type
    std::vector<int> v;
    len(v); // OK: vector有size_type
    int* p;
    len(p); //OK: 指针类型全都不匹配。走最下面的应急类型。
    return 0;
}
```

- 针对原始数组和字符串。因为他俩没有`size_type`所以会忽略第二个函数模板
- 针对`vector`，因为有`size_type`所以匹配第二个。
  - 注意，如果有一些类型有`size_type`，但是由于我们在第二个函数模板中使用了`size`成员函数。如果类型没有这个`size`成员函数，会报错说缺少`size`成员函数
- 针对指针，啥都匹配不了，只能匹配第三个。



## SFIANE 和重载解析：

> **除非在某些情况下，该模板不应该参与重载解析过程** 的意思就是在该情况下，使用 SFINAE 方法 SFINAE 掉了这个函数模板

我们在6.2，6.4和6.5详细说明了某些特殊成员函数模板（尤指构造函数模板）在一些情况下会导致一些错误的匹配。所以我们需要使用`enable_if`让其在某些特殊情况下禁用这个函数模板。也就是在某些情况下（`enable_if`不满足的条件下），让这个函数退出重载候选集。



## 8.4.1 使用decltype 和 SFIANE搭配解决我们上一部分的问题

首先说明，这一部分在decltype和逗号表达式的部分理解不透彻，而且属于奇技淫巧，非常复杂。我会把所有找得到的相关资料贴在这里。

我们之前一节说道：

> 注意，如果有一些类型有`size_type`，但是由于我们在第二个函数模板中使用了`size`成员函数。如果类型没有这个`size`成员函数，会报错说缺少`size`成员函数

这个问题还是挺痛苦的。我们如果没有在在函数声明中以某种方式要求 size()成员函数必须存在，这个函数模板就会被选择并在实例化过程中发生错误。

- 处理这一情况有一种常用模式或者说习惯用法：
  - 通过尾置返回类型语法（trailing return type syntax）来指定返回类型（在函数名前使用auto，并在函数名后面的->后指定返回类型）。
  - **通过` decltype` 和逗号运算符定义返回类型。将所有需要成立的表达式放在逗号运算符的前面（为了预防可能会发生的运算符被重载的情况，需要将这些表达式的类型转换为 void）。**
-  在逗号运算符的末尾定义一个类型为返回类型的对象。

例子：

```c++
template<typename T>
auto len (T const& t) -> decltype( (void)(t.size()), typename T::size_type()){
	return t.size();
}
```

类型指示符 `decltype` 的操作数是一组用逗号隔开的表达式，因此最后一个表达式 `T::size_type()`会产生一个类型为返回类型的对象（`decltype` 会将其转换为返回类型）。而在最后一个逗号前面的所有表达式都必须成立，在这个例子中逗号前面只有 `t.size()`。**之所以将其类型转换为`void`，是为了避免因为用户重载了该表达式对应类型的逗号运算符而导致的不确定性**

- `typename T::size_type()`为啥要这么写？
  - 首先，我们希望`size_type`是一个类型。但是必须要加`typename`指明`T::size_type`是个类型。其次，我们对一个类型使用`()`就创建了一个这个类型的匿名对象。这是一个表达式。这个表达式是返回类类型纯右值的函数调用（说人话就是类型名+()生成匿名临时对象，这个对象的类型自然是类类型。临时对象又是纯右值），所以推导出来的类型就是它本身的类型。就好比`decltype(int())`等于`int`一样。
  - 为啥要放对象不能放类型？因为你不能`decltype(int)`。我们是通过一个实体或表达式去推导出类型。而不是通过一个类型推导出一个类型。`T::size_type`是个类型所以不可以。我们唯一能做的是使用`T::size_type`这个类型实例化出一个这个类型的对象。

这一部分转换的粗浅理解 （其实是我理解错了，但是也还是有用信息）：

- 首先，根据N4140标准的13.3.1.2/9 [over.match.oper]部分：

> 对于` operator,`、一元 `operator& `和 `operator->`，如果候选函数集中没有可行函数（见后述），那么将运算符解释为内建运算符。

出自[这里](https://zh.cppreference.com/w/cpp/language/overload_resolution) 和 [这里](https://stackoverflow.com/questions/39514765/the-void-the-comma-operator-operator-and-the-impossible-overloading)

- 其次，`void()`是一个表达式。它产生一个类型为纯右值的`void`。但是它是一个不完整类型。出自[这里](https://stackoverflow.com/questions/59956374/is-void-a-valid-c-expression)
- 关于decltype的更多故事
  - https://stackoverflow.com/questions/16044514/what-is-decltype-with-two-arguments
  - https://stackoverflow.com/questions/69366618/the-full-story-about-the-decltype-comma-trick
  - https://stackoverflow.com/questions/28837332/sfinae-static-castvoid-or-void
  - https://stackoverflow.com/questions/14003366/what-does-the-void-in-auto-fparams-decltype-void-do#comment19335347_14003374
  - https://stackoverflow.com/questions/11775639/how-is-type-deduced-from-auto-return-type
  - https://stackoverflow.com/questions/39279074/what-does-the-void-in-decltypevoid-mean-exactly
  - https://stackoverflow.com/questions/4031228/why-is-operator-void-not-invoked-with-cast-syntax
  - https://stackoverflow.com/questions/69314599/casting-to-void-to-avoid-use-of-overloaded-user-defined-comma-operator

最终我的核心理解为何要转换为void？答案是**使用它来确认该函数具有返回值，我们已断言忽略它是安全的。也可以不使用c风格转换专用static_cast。**出自[这里](https://stackoverflow.com/questions/689677/why-cast-unused-return-values-to-void/689688#689688)和[这里](https://stackoverflow.com/questions/34288844/what-does-casting-to-void-really-do)

> 转换为`void`后，表达式的值被丢弃。

比如换成这样c++风格：

```c++
template<typename T>
auto len (T const& t) -> decltype(static_cast<void>(t.size()), typename T::size_type() ){
    return t.size();
}
```

所以说这里转换为void的目的是：先判断`t.size()`这个表达式是否成立，也就是这个函数调用是否能成功，也就是`t`是否有这个成员函数。因为我们不关心返回值，所以转成`void`。`decltype`可以在第一层接受如`void`这种不完整类型。其次，就算有人重载了`operator,()`做了一些乱七八糟的事情，由于左侧是空，所以也不会做一些什么奇怪的举动。逗号运算符只保留最右侧的作为结果。所以返回值最后还会是`T::size_type()`。

> 他防止的是comma的重载定义在`t.size()`的返回值类型上，因此添加到void的转换，使得这个返回值被丢弃，不能被利用，所以就不触发comma的重载 ----萧叶轩大佬的回答
>
> 和[这个](https://stackoverflow.com/questions/69314599/casting-to-void-to-avoid-use-of-overloaded-user-defined-comma-operator)很相似

我们之前链接里有，`operator void()`不会被覆盖[看这里](https://stackoverflow.com/questions/4031228/why-is-operator-void-not-invoked-with-cast-syntax)。

假设我们有个这样的残疾类型

```c++
struct foo {
    struct size_type {
        bool operator,(size_type) { return false;}
    };
    size_type size() { return {};}  
};
```

它确实有一个`size_type`并且它确实有一个`size()`函数。但是，如果没有转换为`void`，模板不会推断出正确的返回类型，因为`decltype( (t.size()), typename T::size_type() )`是`bool`类型：

```c++
decltype( (t.size()), typename T::size_type());//等价于下面
decltype((t.size()).operator,(size_type)); //这个会返回一个false。
```



最后，我们的整体解决方案：

```c++
template<typename T, unsigned N>
std::size_t len (T(&)[N]){
    cout <<"no size" << endl;
    return N;
}
template<typename T>
auto len (T const& t) -> decltype(t.size(), typename T::size_type()){
    cout <<"has size"<<endl;
    return t.size();
}
std::size_t len (...)
{
    cout <<"other" << endl;
    return 0;
}
```






# std::is_same

- is_same的主要作用是判断两个类型是否相同。

```c++
template< class T, class U >
struct is_same;
```

- 如果T与U是考虑`const-volatile`限定的相同类型，则`is_same<T,U>::value`为true，否则为false。

举例：

```c++
int main(){
    cout << is_same<int, int>::value << endl; //输出1 (true)
    cout << is_same<int, string>::value << endl; //输出0 (false)
    return 0;
}
```

## 可能的实现

```c++
template<typename _Tp,_Tp _v>
struct intergral_constant{
    static constexpr _Tp value = _v; //表示值
    typedef _Tp value_type; //值类型
    typedef intergral_constant<_Tp,_v> type; //表示自己的类型

    constexpr operator value_type () const noexcept {return value;} 
    constexpr value_type operator()() const noexcept {return value;} //since c++14
};
//定义true_type 和 false_type
typedef intergral_constant<bool, true> true_type;
typedef intergral_constant<bool, false> false_type;

//is_same的实现
template <typename T1,typename T2>
struct is_same: public false_type {};
//类型相同就相当于一个模板参数
template <typename _Tp>
struct is_same<_Tp,_Tp>: public true_type {};
```

- 首先定义了一个类模板`is_same`，这个类模板有两个模板参数`T`和`U`。接着针对这个类模板`T`和`U`类型相同的情况进行偏特化。所以，当`T`和`U`为同一种类型时，将匹配到`1`,不同则匹配到`0`。两个版本唯一的不同是父类。
- 然后是判断两个类型，如果两个类的类型不同，那么应该是继承自`false_type`，如果类型相同的话应该继承自`true_type`。

## 自己模拟一下简单实现

```c++
template<typename T1, typename T2>
class MyClass {
    public:
    //主模板 如果两个类型不一则会匹配到这里
    MyClass(T1 a, T2 b):val1(a), val2(b){
        cout <<"diff type" << endl;
    }
    T1 val1;
    T2 val2;
};

template<typename T>
class MyClass<T,T> {
    public:
    //同一类型的偏特化模板。如果两个类型一致则会匹配到这里
    MyClass(T a, T b):val1(a), val2(b){
        cout << "same type" << endl;
    }
    T val1;
    T val2;
};
int main(){
    MyClass<int, int> myobj1(19,22); //输出 same type
    MyClass<int, string> myobj2(11, "abcde"); //输出 diff type
    return 0;
}
```

# std::is_convertable

`is_convertible`用于判断两个类型之间是否可以隐式转换：第一个模板参数的类型是否可以**隐式转换**为第二个模板参数的类型。

```c++
template< class From, class To >
struct is_convertible;
```

首先，如果满足下列条件，则 `std::is_convertible<From, To>::value` 为 `true`，否则为 `false`

-  `From` 和 `To` 均为 `void` 类型（可含有 `cv` 限定）
-  `std::declval<From>()` 可隐式转换为 `To` 类型
  - 例子1：如果`From`，`to`都是基本类型，那么可以隐式转换。
  - 例子2：如果`From`是子类，`To`是基类，那么`From`可以转换为`To`。

- 使用例子：


```c++
struct A { };
struct B : A { };

int main() {
    cout << std::boolalpha; /* 输出流将bool输出true/false, 而不是1/0 */
    cout << "is_convertible:" << endl;
    cout << "int => float: " << is_convertible<int,float>::value << endl;
    cout << "int = >const int: " << is_convertible<int,const int>::value << endl;
    cout << "A => B: " << is_convertible<A,B>::value << endl; /* A不能转换为B */
    cout << "B => A: " << is_convertible<B,A>::value << endl; /* B能转换为A */
    return 0;
}
/*
is_convertible:
int => float: true
int = >const int: true
A => B: false
B => A: true
*/
```

- 进阶例子：

```c++
class myobj2{
    public:
        int val;
        myobj2() = default;
        myobj2(int a):val(a){}; //注意这里是没有explicit
        operator int(){ //注意这里加了用户定义转换函数
            return val;
        }

};

int main(){
    cout << "myobj2 => int: " << is_convertible<myobj2, int>::value << endl; //true myobj2可以隐式转换为int
    cout << "int => myobj2: " << is_convertible<int, myobj2>::value << endl; //true int可以隐式转换为myobj2。
    return 0;
}
```

由于我们加了用户定义转换函数，所以可以从`myobj2`隐式转为`int`。我们也有转换构造函数，所以也可以从`int`隐式转换为`myobj2`

- 如果去掉类型转换函数：

```c++
class myobj2{
    public:
        int val;
        myobj2() = default;
        myobj2(int a):val(a){}; //注意这里是没有explicit
};

int main(){
    cout << "myobj2 => int: " << is_convertible<myobj2, int>::value << endl; //false myobj2不可以隐式转换为int
    cout << "int => myobj2: " << is_convertible<int, myobj2>::value << endl; //true int可以隐式转换为myobj2。
    return 0;
}
```

- 如果给构造函数添加explicit，禁止隐式类型转换：

```c++
class myobj2{
    public:
        int val;
        myobj2() = default;
        explicit myobj2(int a):val(a){}; //有explicit
};

int main(){
    cout << "myobj2 => int: " << is_convertible<myobj2, int>::value << endl; //false myobj2不可以隐式转换为int
    cout << "int => myobj2: " << is_convertible<int, myobj2>::value << endl; //false int不可以隐式转换为myobj2。
    return 0;
}
```

详细：https://www.cnblogs.com/fortunely/p/16216310.html



# std::is_constructible

```c++
template <class T, class... Args>
struct is_constructible;
```

如果通过使用 `Args` 中的参数类型可构造类型 `T`，则类型谓词的实例保持 `true`；否则保持` false`。 如果变量定义 `T t(std::declval<Args>()...);` 的格式正确，则可以构造类型 `T`。 `T `和` Args` 中的所有类型都必须是完整的类型、`void`，或者是未知边界的数组。

- 这一大堆官方文档其实就是意思是看`Args`的这些参数能不能构造`T`类型对象。

- 上面的`is_convertable`是来判断能否隐式转换。而这里可以被用来测试是否可以显式转换。杂记1中我们提到过：**显式地调用构造函数进行直接初始化实际上是显式类型转换的一种。**

例子：

```c++
class myobj{
    public:
    int val;
    char single;
    string name;
    myobj(){}
    myobj(int a):val(a){};
    myobj(int a, char b, string& c): val(a), single(b), name(move(c)){};

};
int main(){
    cout << is_constructible<myobj, int>::value << endl; //trus
    cout << is_constructible<myobj, int, char, string>::value << endl; //false
    cout << is_constructible<myobj, int, char, string&>::value << endl; //true
    return 0;
}
```

为啥第二个传值是`false`？我们不是可以如这样：

```c++
string name = "abc";
myobj a(12,'a',name);
```

- 注意了，这里的`name`虽然是值，但是由于函数签名是`string&`，所以`name`这个参数在我们传递到函数内的时候，函数内会创建一个`name`的引用，叫做`c`。
- 这里可以理解为函数签名。你想把一个函数`void function(int& x)`塞进这样的函数指针` void(*ptr)(int)`是错的。引用和值在签名处不可混为一谈。
- 同时，针对这个构造函数，如果我们尝试这样做：

```c++
myobj(1, 'c', std::string{"lalala"});
```

这时候就会失败。因为左值引用不能接右值。

- 所以在这里，函数的形参类型是`string`还是`string&`有很大差别。当然了，这里如果给构造函数换成`const string& `就都是`true`了。或者是换成`string`值传递也都是`true`。因为常量左值引用可以接一切。**值传递的函数塞引用也没问题。因为引用会被脱去。**



- 进阶例子：

上面我们提到了，我们给转换构造函数加了`explicit`,所以不能隐式转换。所以`is_convertible<int, myobj2>::value`是`false`。我们可以尝试用这里的`is_constructible`来看是否可以显示转换。

```c++
class myobj2{
    public:
        int val;
        myobj2() = default;
        explicit myobj2(int a):val(a){}; //依旧explicit

};
int main(){
    cout << "is_constructable:" << endl;
    cout << "int => myobj2: " << is_convertible<int, myobj2>::value << endl;
    cout << "is_convertible:" << std::endl;
    cout << "int => myobj2: " << is_constructible<myobj2,int>::value << endl;
    return 0;
}
/*
is_constructable:
int => myobj2: false
is_convertible:
int => myobj2: true
*/
```

我们看到依旧不能隐式转换所以第一个是`false`。但是我们可以使用int来构造`myobj2 `所以第二个是`true`。

注意一下参数顺序。能不能转换是第一个转到第二个。能不能构造是第二个构造第一个。



# std::is_const

```c++
is_const<T>::value
```

用于判断`T`类型是否是被`const`修饰的类型。

- 若 T 为引用类型则 `is_const<T>::value` 始终为 `false` 。检查可能为引用的类型的常性的正确方式是移除引用： `is_const<typename remove_reference<T>::type> `。
  - 原因是引用的`const` 限定符仅仅意味着不能通过引用参数修改值。 它仍然可以被其他方法修改。比如直接修改变量

```c++
int main()
{
	std::cout << std::boolalpha;

	std::cout << "is_const:" << std::endl;
	std::cout << "int: " << std::is_const<int>::value << std::endl;
	std::cout << "const int: " << std::is_const<const int>::value << std::endl;
	std::cout << "const int&: " << std::is_const<const int&>::value << std::endl;
	std::cout << "const int* " << std::is_const<const int*>::value << std::endl;
	std::cout << "int* const:" << std::is_const<int* const>::value << std::endl;
	return 0;
}
/*
is_const: 
int: false
const int: true
const int&: false

const int*: false 这里的false是因为指针本身非const。也就是顶层非const。
int* const:true 这里的true是因为指针本身是const。也就是顶层为const
*/
```

## 模拟简单实现

也是简单的匹配。

```c++
template<typename>
struct my_is_const{
    void func(){
        cout <<"not const" << endl;
    }
};

template<typename _Tp>
struct my_is_const<_Tp const>{
    void func(){
        cout <<"const" << endl;
    }
};
my_is_const<int> a;
my_is_const<const int>b;
a.func(); //not const
b.func(); // const
```



# std::ref, std::cref, std::reference_warpper

之前一直想整理一下这几个。这次一起探讨一下

在很多时候比如使用`bind`和`thread`这种一定会拷贝参数的标准库组件时，我们如果想要按照引用传递，就必须使用`ref`或`cref`包装一下。

- 一句话总结。`ref`和`cref`都是`reference_warpper`的包装器。
- `cref`只是变成了带`const`的`ref`。所以下面不分析`cref`了。
- `reference_warpper`内部包含一个指向了原始对象类型的指针。其实他就是一个包含了一个指针的包装器对象。
  - 它有用户定义转换函数。
  - 他还有一个`get()`函数用于返回其原始对象的引用，通过这个方式可以像引用一样，内部修改的值可以传递到外面。

- 其实应该说`ref`和`cref`是`reference_warpper`的辅助函数。

## ref 源代码

```c++
template<typename _Tp>
inline reference_wrapper<_Tp> ref(_Tp& __t) noexcept
{ return reference_wrapper<_Tp>(__t); }

template<typename _Tp>
void ref(const _Tp&&) = delete; //禁止接受右值

template<typename _Tp>
inline reference_wrapper<_Tp> ref(reference_wrapper<_Tp> __t) noexcept
{ return ref(__t.get()); }

```

- 我们可以一眼看出，`ref`就是一个返回`reference_wrapper`的函数
- 因为禁止接受了形参为右值的参数。所以`ref`不能包装右值。

```c++
std::ref(5);//不可以
```

- `ref`的传入参数可以是一个普通的引用，也可以是另外一个`reference_wrapper`对象

## reference_wrapper 源代码

```c++
template<typename _Tp>
class reference_wrapper : public _Reference_wrapper_base<typename remove_cv<_Tp>::type> //这里去掉了CV。
{
    _Tp* _M_data; //内部就是包含一个指向原始对象的指针。

public:
    typedef _Tp type;

    reference_wrapper(_Tp& __indata) noexcept
        :_M_data(std::__addressof(__indata))
    {
    }

    reference_wrapper(_Tp&&) = delete;

    reference_wrapper(const reference_wrapper<_Tp>& __inref) noexcept
        :_M_data(__inref._M_data)
    {
    }

    reference_wrapper& operator=(const reference_wrapper<_Tp>& __inref) noexcept
    {
        _M_data = __inref._M_data;
        return *this;
    }

    operator _Tp&() const noexcept //用户定义转换函数。使用了get
    { return this->get(); }

    _Tp& get() const noexcept //get用于返回原始对象的引用。起到引用的效果。
    { return *_M_data; }

    template<typename... _Args>
    typename result_of<_Tp&(_Args&&...)>::type
    operator()(_Args&&... __args) const
    {
        return __invoke(get(), std::forward<_Args>(__args)...);
    }
};
```

- 该类继承于`_Reference_wrapper_base`_
- 有一个类成员`_M_data`，类型为所引用类型的指针。这个指针指向了原始对象。
- 第一个构造函数通过调用`std::__addressof`函数，获得了指向引用参数的指针，并赋值给了`_M_data`（这也是为什么不支持右值引用的原因，因为取不到对应的地址）
  - 至于这里为什么要使用`std::__addressof`，是因为如果有些类重载了`operator &` 的话可能我们不能取到真实地址。使用这个函数不管是否重载了取地址操作符，都可以取到原始地址。具体细节不分析了。
- 拷贝构造函数和赋值函数就只是简单地将`_M_data`的值进行传递而已，没有什么特殊操作。都是常规
- 其余方法就是为了让`reference_wrapper`展现出和普通的引用一样的效果而进行的运算符重载。

  - 比如重载了`operator ()`可以让我们在`reference_wrapper`对象储存了一个可调用对象的时候，直接使用`()`调用其储存的可调用对象

  ```c++
  void this_func(){
      cout <<"called" << endl;
  }
  
  int main() {
      auto func_ptr = this_func;
      auto ref3 = ref(func_ptr); //ref3是一个reference_wrapper储存了一个函数指针
      ref3();//调用。
  }
  ```

  - 比如有`get()`可以获取一个原始对象的引用。
  - 用户定义转换函数使得它支持了向原始类型的隐式类型转换。



举一个非常不太对劲的例子

```c++
template <typename T>
void another_func(T a){
    a.get() = 2000;
}
int main() {
    int a = 1;
    another_func(ref(a));
    cout << a << endl; //修改为2000。
}

//或者是
void changeval(int& a){
    a = 20000;
}

template <typename T>
void func(T a){
    changeval(a); //因为有用户定义转换函数。这里的T本来是reference_wrapper类型的，但是可以隐式转换为原始类型。比如这里就是int&
}
int main() {
    int a = 1;
    func(ref(a));
    cout << a << endl; //修改为20000

}
```



**注意了。在这些情况下，`reference_wrapper`对象本身依旧是按值传递的。**





https://blog.csdn.net/weixin_43798887/article/details/116562336



# std::remove_reference

- 若类型 `T` 为引用类型，则提供成员 typedef `type` ，其为 `T` 所引用的类型。否则 `type` 为 `T` 。

这个的实现比较简单。

```c++
template<class T> 
struct remove_reference{
    typedef T type;
};
template<class T> 
struct remove_reference<T&>{
    typedef T type;
};
template<class T> 
struct remove_reference<T&&>{
    typedef T type;
};
```

当T是`&`或者`&&`的时候，自然都会有每一个匹配的版本。都会让其`T`本身的类型成为其类型。也就是脱去引用。







# CRTP

先简单介绍，之后慢慢看。

- **CRTP的一个最明显的特点就是把派生类作为基类的模板参数**



# 杂项

## 类成员函数不可以既是虚函数又是模板函数

- 首先简单来说，虚函数是动态多态。模板属于静态多态。这里不能动静结合。
- 其次，我们知道了函数模板在编译的时候会看哪些地方调用了。根据T的不同，每一份T都会导致实例化出一份T类型的函数。这就导致了会有多个入参类型不同的成员函数。但是我们又知道虚函数的虚函数表必须预先确定。而此时父类看不到子类的模板虚函数到底有几个版本，难不成都写一遍？
- 另一个原因是如果我们有模板虚函数，那么编译器为了确定类的虚函数表的大小，就必须要知道我们一共为该成员模板函数实例化了多少个不同版本的虚函数。显然编译器需要查找所有的代码文件，才能够知道到底有几个虚函数，这对于多文件的项目来说，代价是非常高的。
- 也就是说，如果这样做的话，虚函数表的确定时间就需要从编译器推迟到链接期。因为编译期指的是我不需要看具体实现。我只要发现你是`virtual`我就可以把你放到表内。如果支持模板虚函数，那么就需要链接的时候把每一个实现都扫一遍然后再整理后放入虚函数表。

## 为什么类模板有偏特化没有重载，但是函数模板没有偏特化有重载？

问题也是答案。因为类模板没有重载所以有偏特化。因为函数模板幼虫在所以没有偏特化。



## 关于偏序 （partial order)

我们提到过，当可行函数集中所有的函数都是函数模板的时候，这时候要选择最特殊的那一个。

比如

```c++
template <typename T>
void func(T a){ //主模板
    cout <<"main" << endl;
}
template <typename T>
void func(T* a){ //重载模板
    cout << "overload" << endl;
}
int main(){
    int* p;
    func(p); //输出overload
}
//注意，调用的时候，如果调用第一个，因为传入的是int*，所以第一个里面的T会被推导为int*
//如果调用第二个，因为传入的是int*, 而里面又已经有了个*所以T就只被推导为int。
```

为什么我们认为下面的比上面的更特殊？我们用到了偏序的具体步骤

1. 先选择两个函数模板，`T1`和`T2`
2. 用假设的唯一类型`X`取代模板`T1`的参数
3. 用被`X`取代后的`T1`的参数列表，带入`T2`，看`T2`是否是一个有效的模板。忽略所有的隐式转换。
4. 反过来，先用`X`取代`T2`的参数，再把`T2`的参数列表带入`T1`，看看`T1`是否有效。
5. 如果一个模板的参数比如`T1`对于另外一个模板`T2`是有效的，但是反之不成立，那么就说这个模板`T1`不比`T2`更特例化。也就是可能T2比T1更特例化。如果这两个模板的参数都可以相互代替，就说它们具有相同的特例性，这样会引起编译器混淆。



所以我们有总结：

1. 对于一个模板，特定类型的参数比一般类型的参数，更具有特例性
2. 带有`T*`的模板比`T`的模板具有特例性。因为一个假设的类型`X*`也可以被认为是`T`类型的， 相反一个有效的`T`类型参数，可能不是`X*`类型的。
3. `const T`比`T`更特例化，道理同上。
4. `const T*`比`const T`更特例化，理由也是一样的。








https://stackoverflow.com/questions/18283851/template-specialization-in-case-of-multiple-base-templates-in-c/18283933?noredirect=1#comment26823443_18283933

https://www.youtube.com/watch?v=NIDEjY5ywqU

https://blog.csdn.net/weixin_30294295/article/details/94781059

https://zhuanlan.zhihu.com/p/390783543

## 关于不要显式全特化函数和函数全特化的问题

假如我们有下面的代码：

```c++

template<typename T>            // (1) - 主模板
string getTypeName(T){
    return "unknown";
}

template<typename T>            // (2) - 重载自 (1) 的主模板。 针对指针类型的模板重载
string getTypeName(T*){
    return "pointer";
}

template<>                      // (3) - (2) 的显式全特化。针对int指针类型的显式全特化
string getTypeName(int*){
    return "int pointer";
}

// getTypeName2

template<typename T>            // (4) - 主模板
string getTypeName2(T){
    return "unknown";
}

template<>                      // (5) - (4) 的显式全特化。 针对int指针类型的显式全特化
string getTypeName2(int*){
    return "int pointer";
}
template<typename T>            // (6) - 重载自 (4) 的主模板。 针对指针类型的模板重载
string getTypeName2(T*){
    return "pointer";
}

int main(){
    
    cout << '\n';
    int* p;
    cout << "getTypeName(p): " << getTypeName(p) <<  '\n';  
    //输出getTypeName(p): int pointer
    cout << "getTypeName2(p): " << getTypeName2(p) <<  '\n';
    //输出getTypeName2(p): pointer  
    cout <<  '\n';

}
```

**这段代码中，我们有意的把针对指针的模板重载和全特化调换了顺序写成了两个不同的函数。**

我们看到了。分别输出`getTypeName(p): int pointer` 和 `输出getTypeName2(p): pointer `。

但是这不对啊？看`getTypeName`，为什么使用了全特化版本而不是模板重载？我们不是说了全特化版本不参与重载决议吗？

我们要理解到底决议的是谁。要看匹配顺序。

- 针对第一个`getTypeName`函数调用，过程是这样的：

  - 在一开始，重载解析会考虑 (1) 和 (2)。第三个全特化版本此时不参与重载决议。

    - `template<typename T> std::string getTypeName(T);` 

      - (1) - 主模板

    - `template<typename T> std::string getTypeName(T*);`
      - (2) - 重载自 (1) 的主模板
      
    - `template<> std::string getTypeName(int*);` 
      - (3) - (2) 的显式全特化
  - 显式全特化版本此时不参与，所以(2) 更合适，因此第一阶段选择 (2)。
  - 但是随后看到了（3），我们发现针对我们合成出来的`T`为`int`类型的函数也就是（2），还有一个似乎可以比较一下。**而且此时两个函数都是模板函数。并且其中一个是主模板合成出的。所以这时候（3）被加入到了重载决议中，开启偏序部分。**
  - 此时通过偏序，**（3)此时被认为是(2)的显式全特化**。和（2）相比，（3）的类型更为特化，所以此时选择了（3）。所以编译器不会从(2)合成一个，而是选取一个已经存在的(3)。*这里看一下上面偏序推导和下面的“关于为什么说函数模板不是..."*
- 但是针对第二个`getTypeName2`函数调用，过程是这样的：
  - 在一开始，重载解析会考虑 (4) 和 (6)。
    - `template<typename T> std::string getTypeName2(T); `
      - (4) - 主模板
    - `template<> std::string getTypeName2(int*); `
      - (5) - (4) 的显式全特化
    - `template<typename T> std::string getTypeName2(T*); `
      - (6) - 重载自 (4) 的主模板
  - 显式全特化版本此时不参与，所以(6) 更合适，因此选择 (6)。
  - 然而此时**(5) 被认为是 (4) 的显式全特化而不是(6)的显式全特化**。而且因为 (4) 没有被选中，所以重载解析也不会考虑（5）。最后选择（6）。
    - 为什么？此时**(5) 被认为是 (4) 的全特化而不是(6)的显式全特化**。因为在进行到(5)的时候，编译器唯一能看到的只有(4)而没有(6)。[也就是在（5）眼里，只有（4）在作用域内。（6）此时还没有被看见。因为显式全特化的（5）没有名字，这时候必须依附于一个主模板。所以说（5）只能看见（4）所以认为（5）是（4）的显式全特化]





所以我们在这里可以看出来模板特化的混乱程度。所以尽可能不要特化模板函数，而是采用普通函数。也就是不要对函数模板进行特化，而要使用**非**泛型函数。

所以我们在这里把`(3)`和`(5)`函数头的全特化指示`template<>`删掉，则一切工作正常。都会输出`int pointer`。因为普通函数总是优先于模板函数。

https://zhuanlan.zhihu.com/p/561977606

- 也就是说，如果在很多个函数模板中挑选，编译器会首先选中一个基础模板。然后针对这个模板再一轮搜索来查看是否有更加匹配的。



为了好玩，再看个像狗一样的例子

```c++
template<typename T>            // (7) - 主模板
string getTypeName3(T){
    return "unknown";
}

template<>                      // (8) - (7) 的显式全特化。 针对int指针类型的显式全特化
string getTypeName3(int*){
    return "int pointer";
}
template<typename T>            // (9) - 重载自 (7) 的主模板。 针对指针类型的模板重载
string getTypeName3(T*){
    return "pointer";
}
template<>                      // (10) - (9) 的显式全特化。 针对int指针类型的显式全特化
string getTypeName3(int*){
    return "another int pointer";
}
int main(){
    
    cout << '\n';
    int* p;
    int a = 0;
    cout << "getTypeName3(p): " << getTypeName3(p) <<  endl;   //输出another int pointer
    cout << "getTypeName3(a): " << getTypeName3(a) << endl; //输出 unknown
    // cout <<  '\n';

}
```

- 就是由于上面的原因。（8）被认为是（7）的显式全特化。因为当时它只能看到，依附于（7）。而（10）被认为是（9）的显式全特化。因为（10）可以看到（9）。而且因为（8）是（7）的显式全特化，我们不考虑（7）所以也不考虑（8）。考虑（9）然后通过偏序发现（10）比9更特殊。最后选择了（10）



## 什么时候要显式全特化而不是重载？

一个是`std::swap`。

另外一个是阻止某些隐式转换。比如：

```c++
template <class T> 
void testf(T); //注意，这里没有定义！！
template <> 
void testf(int) {
    //一些内容
}
int main(){
    testf(3);//可以
    testf(3.3); //不行
    return 0;
}
```

当只有`void foo(int)`时，以浮点类型调用会发生隐式转换，这可以通过特化来阻止。正常调用`int`没问题，但是如果入参是`float`，会匹配到主模板。但是主模板没有定义，自然出现问题。

https://segmentfault.com/q/1010000013299483   





## 关于重载决议 (overload resolution)

https://mp.weixin.qq.com/s/lbPdLfusUqiO-I59PcXrCQ

**重载决议只看声明，不看定义。**

- 在一个函数调用的备选方案中包含函数模板时，编译器首先要决定应该将什么样的模板参数用于各种模板方案，然后用这些参数替换函数模板的参数列表以及返回类型，最后评估替换后的函数模板和这个调用的匹配情况（就像常规函数一样）

### 第一步 确定候选函数集

- 确定候选集: 在重载函数集中,根据作用域和函数名,来选择同名同域的重载函数

- 候选函数集特点:
  - 该集合中的函数的声明,在该调用点可见 
    - 也就是,和背调函数在同一作用域下

  - 该集合中的函数,与被调函数同名
    - 也就是,重载函数的函数名都一致
  


### 第二步 选出可行函数集
- 在确定了候选函数集之后,根据背调函数的参数列表,选择出对应的可行函数集

  - 参数列表信息 = 参数个数 + 参数类型

- 可行函数集特点:
  - 每个实参的类型要与对应的形参类型相同,或者是能够转换成形参的类型
    - c++支持隐式类型转换!
  - 参数个数与背调函数个数匹配
    - 参数类型可以隐式转换,但是参数个数相同是最低标准


**如果没有找到可行函数集,则编译器将报告无法匹配函数的错误**



### 第三步 寻找最佳匹配
- 从可行函数集合中选出与本次调用最匹配的函数(注意,并不一定是完全一致的函数)
- 编译器将依次检查可行函数集中的每一个函数
- 依次检查每一个函数的形参,与被调函数的实参
- 寻找到最匹配的那个可行函数
- 匹配成功条件
  - 该可行函数每个实参的匹配都不劣于其他可行函数需要的匹配
  - 该可行函数至少有一个实参的匹配 优于其他可行函数提供的匹配
  - 有且只有一个可行函数满足上述两个原则
  - 注意: 有且只有一个可行函数满足,如果有多个可行函数同时满足,就会造成函数调用的二义性



https://blog.csdn.net/jiewaikexue/article/details/120089550

https://blog.csdn.net/qq_53558968/article/details/122757998





![640](/assets/blog_res/2022-12-14-%E6%A8%A1%E6%9D%BF.assets/640.png)

- 上图是重载中的决胜局的匹配表。它们的匹配优先级也是自上往下的，即Exact Match比Promotion更好，Promotion比Conversion更好，可以理解为完全匹配、次级匹配和低级匹配。

## 关于为什么说函数模板不是函数。函数模板在其被实例化的时候会合成一个特化的函数

假设我们有如下函数模板：

```c++
template<typename T>
void func(T const&);

func(42); 	//	void func<> (int const&);
func('a'); 	// 	void func<> (char const&);
```

我们在两次函数调用的时候，编译器会使用函数模板帮助我们合成注释里面的函数实例。

- 在实例化过程中，可能会发生当前要实例化的东西已经存在或发生过等效调用。所以如果存在适当的预先的全特化版本，那么那个全特化版本会被编译。（这里就是上面的“关于不要全特化..."部分的例子的原因）
  - 也就是有全特化版本了，调用的时候就不再合成，而是直接使用全特化版本。
- 如果没有已经存在的全特化版本，那么编译器此时必须实例化这个全特化版本。编译器会从主模板当中复制它的定义（definition），然后进行适当替换。这就是我们说为什么显式全特化只是一个替换的定义，而不是一个替换的声明。
- 我们想象一下，由于显式全特化的函数模板不参与重载解析。除非重载决议选择最佳匹配的主函数模板后，才检验它的特化以查看最佳匹配者。所以就是假设现在编译器合成出了一个`T`是`int`的函数声明。我们此时有一个显式全特化了`int`的函数。这时候会考虑显式全特化的那个。所以他会把全特化版本的函数实例化。然后把合成的函数声明给全特化的这个函数拼接到一起。这就是为什么全特化函数没有独立名字。因为它的声明是编译器合成的，定义是我们自己写的。这两个不能分开，自然全特化版本也没有需要独立名字的意义。

## 限定名、非限定名

限定名(qualified name)，故名思义，是限定了命名空间的名称。看下面这段代码，`cout`和`endl`就是限定名：

```c++
#include <iostream>

int main()  {
    std::cout << "Hello world!" << std::endl;
}
```

`cout`和`endl`前面都有`std::`，它限定了`std`这个命名空间，因此称其为限定名。

如果在上面这段代码中，前面用`using std::cout;`或者`using namespace std;`，然后使用时只用`cout`和`endl`，它们的前面不再有空间限定`std::`，所以此时的`cout`和`endl`就叫做非限定名(unqualified name)。



## 依赖名、非依赖名

依赖名(dependent name)是指依赖于模板参数的名称，而非依赖名(non-dependent name)则相反，指不依赖于模板参数的名称。看下面这段代码：

```c++
template <class T>
class MyClass {
    int i;
    vector<int> vi;
    vector<int>::iterator vitr;

    T t;
    vector<T> vt;
    vector<T>::iterator viter;
};
```

因为是内置类型，所以类中前三个定义的类型在声明这个模板类时就已知。然而对于接下来的三行定义，只有在模板实例化时才能知道它们的类型，因为它们都依赖于模板参数`T`。因此，`T`, `vector<T>`和`vector<T>::iterator`称为依赖名。前三个定义叫做非依赖名。

更为复杂一点，如果用了`typedef T U; U u;`，虽然`T`没再出现，但是`U`仍然是依赖名。由此可见，不管是直接还是间接，只要依赖于模板参数，该名称就是依赖名。

## `typedef` 和作用域解析运算符`::` 和 嵌套类

我们很难把class和namespace联系起来，但是这两个在抽象层次上其实是一个概念。

作用域解析运算符::的作用就是制定某一个范围。但是一旦用在了嵌套类或者类内的typedef，我们就很难理解这层含义。

我们都知道**直接访问类静态成员必须使用作用域解析运算符`::`**

但是我们如果要通过作用域解析运算符访问非静态成员，可以吗？当然可以。只不过需要通过对象访问。

举个例子：

```c++
class test{
    public:
    class testinner{ //嵌套类
        public:
        int _val;
        testinner(){}
        testinner(int x):_val(x){}
    };
    test(){}
    typedef int testdef;


    int s;
};

int main()
{
    test::testinner tt1 = test::testinner(5); //OK
    test::testinner tt2; //OK 访问嵌套类
    test::testdef tt3 = 5; //OK 访问typedef。
    test::s = 5; //不行。直接访问的成员必须是静态成员。
    test t;
    t.test::s = 5; //OK 通过对象访问，但是还是脱裤子放屁加了作用域解析运算符。

    return 0;
}
```

这里我们可以理解为我们需要访问的`typede`f和嵌套类在`test`类的命名空间下。我们必须要告知编译器这东西在哪，所以需要通过作用域解析运算符去访问。

至于`typedef`和嵌套类是否是一个类的成员，我没有查到确切的说法。如果说他们不是成员吧，但是有成员的属性。要是说是成员吧，我们也可以直接访问。但是也有人说嵌套类的`static`是隐式的。也有人把嵌套类当做一个`namespace` 来看待。所以我的理解是**不要把嵌套类和`typedef`看做类成员。假设他们可以直接调用即可。**

**如果嵌套类没有在外部类中实例化，则实例化外部类的时候不会实例化嵌套类内容。**



## 最后说一下必须显式使用`typename`的情况。

![QQ截图20220613134505](/assets/blog_res/2022-12-14-%E6%A8%A1%E6%9D%BF.assets/QQ%E6%88%AA%E5%9B%BE20220613134505-16551788472405.png)

来几个例子：

```c++
class test{
    public:
        struct obj{
            int _sb;
        };
        obj s;
        int _val;
        test(){}
        test(int x):_val(x){}
        test(int x, int y){
            _val = x;
            s._sb = y;
        }
};
template<typename T>
void func(){
    test t(5,8);
    typename T::obj* ptr = &t.s;
    //这里我们的意思是有一个指针ptr指向了T类里面的obj类型的对象。翻译成人话也就是ptr是一个T::obj类型的指针。但是如果有一个T类里面的obj是一个变量，如static int obj = 8
    //那么这就变成了变量乘法。会有歧义。所以使用typedef显式告知编译器 T::obj不是一个变量，而是一个类型。
    cout << ptr->_sb << endl;
} 
```



可能还不够？再来：

```c++
typedef iterator_traits<T>::value_type value_type_anothername; 
//这句话的意思是value_type_anothername是在模板类iterator_traits中的 变量 value_type的别名。

//所以如果有
value_type_anothername name = "foward_iterator";
//这样是不行的。因为value_type_anothername是一个变量不是类型。
//所以我们需要加typedef告知编译器这个是类型

typedef typename iterator_traits<T>::value_type value_type_anothername; 
//这句话的意思是value_type_anothername是iterator_traits<T>::value_type这个 类型 的别名。

//所以这样可以有
value_type_anothername name = "foward_iterator";
//因为value_type_anothername 是个类型。就好比int string这种。

```



还不够？再来：

这是我们前文的例子。但是为什么这里不需要加typedef呢？

```c++
class test{
    public:
    typedef int inputtype;
};

int main(){
    test::inputtype x = 4; //这句话等于告诉你 test类下面的inputtype这个东西是int 
}

```



先送上大佬文章一篇：https://feihu.me/blog/2014/the-origin-and-usage-of-typename/

由于`test`已经是一个完整的定义，因此编译期它的类型就可以确定下来，也就是说`test::inputtype`这些名称对于编译器来说也是已知的。

可是，如果是像`T::inputtype`这样呢？`T`是模板中的类型参数，它只有等到模板实例化时才会知道是哪种类型，更不用说内部的`inputtype`。通过前面类作用域一节的介绍，我们可以知道，`T::inputtype`实际上可以是以下三种中的任何一种类型：

- 静态数据成员
- 静态成员函数
- 嵌套类型





- `typename`的作用，简单理解就是强制告诉编译器 `namespace::objname`这个东西是一个类型名而不是变量名。

**所以在模板类中，如果想要告知编译器一个使用了`::`作用域解析运算符的东西是类型，而不是变量，就需要加`typename`**

- 如果直接把这个东西当做一个类型来进行变量的声明，那就不需要搭配`typedef`

- 如果需要把这个东西当做一个类型来赋予一个别名，那就需要加`typedef`

所以，像这样就必须要加：

```c++
class test{
    public:
    test(){}
    typedef int inputtype;
};


template<typename T>
class test1{
    public:
    test1(){};
    typedef typename T::inputtype inputtype; //注意这里，T::inputtype是个类型。比如test::inputtype 就是 int类型
};

```

## 特殊成员函数能否是函数模板

- 拷贝构造，拷贝赋值，移动构造，移动赋值。这四个成员函数模板不会被当成真正的特殊成员函数。如果只声明模板，编译器依旧会合成默认的。然后调用默认的。
- **构造函数是个例外。**

假设我们有这个类：

```c++
class C{
    public:
        template<typename T>
        C(const T&){
            cout <<"called" << endl;
        }
};
int main(){
    C obj1(10); //called
    C obj2(obj1); //啥也没有
}
```

我们第一反应是啥：这个函数看起来非常像拷贝构造对吧。但是它不是。它是个构造函数模板。

拷贝构造有严格定义：

> 类 `T` 的拷贝构造函数是首个形参是 T&、const T&、volatile T& 或 const volatile T&，而且要么没有其他形参，要么剩余形参均有默认值的非模板[构造函数](https://zh.cppreference.com/w/cpp/language/initializer_list)。
>
> 这里形参必须是引用，如果按照值传递就会有悖论。比如为了调用复制构造函数，必须复制一下。为了复制，必须调用复制构造函数......

我们这个函数他明显形参类型不是`C`。所以他不会被当做拷贝构造函数。

所以自然而然，符合我们上面说的。我们第一个符合构造函数特征。然后类型会被推导。然后`C obj1(10);`会被正常调用。

然而第二个需要调用拷贝构造的时候，我们等于没有提供，我们此时使用的是编译器合成的。自然啥也没打印。

- 然而构造函数模板不可显式指定模板参数类型。因为显式模板实参列表跟在函数模板名之后，并且因为转换成员函数模板和**构造函数成员函数模板是在不使用函数名的情况下调用的**，所以没有办法为这些函数模板提供显式模板实参列表。

注意，`C obj1(10);`这个东西不是调用构造函数。而是直接初始化。我们称之为调用构造函数是因为直接初始化就是在找构造函数。

https://www.cnblogs.com/silentNight/p/5545643.html

https://stackoverflow.com/questions/3960849/c-template-constructor



# 函数模板参数推导表格和测试函数

测试函数：

```c++
template <typename T>
void f(const T& param) {
    std::puts(__PRETTY_FUNCTION__);
}

int main() {
    int p = 2;
    f(p);
}
```

已知A（入参类型）和P（函数头类型）推T（T的类型）
P的类型可能是`T`，`const T`, `T&`, `const T&`, `T&&`, `const T&&`

```c++
template<typename T>
void f(P param){
    //...
}
int main(){
    f(A);
    return 0;
}
```

|    P     |         A         |          T          |
| :------: | :---------------: | :-----------------: |
|    T     |        int        |         int         |
|    T     |       int*        |        int*         |
|    T     |       int&        |         int         |
|    T     |     const int     |         int         |
|    T     |    const int *    |     const int *     |
|    T     |    int * const    |        int *        |
|    T     |    const int &    |         int         |
|    T     | const int * const |     const int *     |
|    T     |     char [2]      |       char *        |
|    T     |  const char [12]  |    const char *     |
|    T     |    void (int)     |    void (*)(int)    |
| const T  |        int        |         int         |
| const T  |       int *       |        int *        |
| const T  |       int &       |         int         |
| const T  |     const int     |         int         |
| const T  |    const int *    |     const int *     |
| const T  |    const int &    |         int         |
| const T  | const int * const |     const int *     |
| const T  |     char [2]      |       char *        |
| const T  |  const char [12]  |    const char *     |
| const T  |    void (int)     |    void (*)(int)    |
|    T&    |        int        |         int         |
|    T&    |       int *       |        int *        |
|    T&    |       int &       |         int         |
|    T&    |     const int     |      const int      |
|    T&    |    const int *    |     const int *     |
|    T&    |    const int &    |      const int      |
|    T&    | const int * const |  const int * const  |
|    T&    |     char [2]      |      char [2]       |
|    T&    |  const char [12]  |   const char [12]   |
|    T&    |    void (int)     |     void (int)      |
|   T&&    |        int        |        int &        |
|   T&&    |       int *       |       int *&        |
|   T&&    |       int &       |        int &        |
|   T&&    |     const int     |     const int &     |
|   T&&    |    const int *    |    const int *&     |
|   T&&    |    const int &    |     const int &     |
|   T&&    | const int * const | const int * const & |
|   T&&    |     char [2]      |     char (&)[2]     |
|   T&&    |  const char [12]  | const char (&)[12]  |
|   T&&    |    void (int)     |    void (&)(int)    |
|   T&&    |      int &&       |         int         |
| const T& |      int &&       |         int         |

https://www.cnblogs.com/5iedu/p/11183878.html



# 正确区分函数类型和函数指针类型在模板中的使用



```c++
template<typename T1>
class func{
    public:
    T1* callable; //这里必须是T1*
    func(T1 outter):callable(outter){};
    template<typename ...Args>
    void call(Args&& ...args){
        callable(forward<Args>(args)...);
    }
    void test(){
        std::puts(__PRETTY_FUNCTION__);
    }
};
template<typename T1>
class test;
template<typename T1, typename... T2> 
class test<T1(T2...)>{//实参匹配
    public:
    template<typename Func, typename ...Args>
    void construct(Func ptr, Args&& ...args){        
        func<T1(T2...)> obj(ptr);
        obj.call(forward<Args>(args)...);
        obj.test();
    }

};
int testsor(float b, int c){
    cout << b << endl;
    cout << c << endl;
    cout <<"success" << endl;
    return 1;
}
int main(){
    test<int(float, int)> obj;
    obj.construct(testsor, 2.5f, 234);
    return 0;
}
```

为啥上面的部分必须是`T1*`呢？

因为`T1(T2...)`会被推导为函数类型而非函数指针类型。也就是传入`func`的模板参数时，`func`的`T1`会被推导为`int(float, int)`。

在杂记3中，我们区分了函数类型和函数指针类型。函数类型不可以声明变量。所以此时必须额外增加一个`*`让其转换为指针类型。

https://stackoverflow.com/questions/17446220/c-function-types