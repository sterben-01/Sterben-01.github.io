---
title: 模板
date: 2022-12-14 09:50:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true


---



# C++ template

此笔记应和杂记3的模板相关部分搭配查看。

## 第1章 函数模板

- 在声明模板变量类型的时候，尽量使用typename而非class。尽管没有区别。

- ~~所有的模板类型参数都应该被使用。不应该有未使用的模板参数，会导致错误。（个人推理）~~

- 函数模板有两种类型的参数：

  - 模板参数：位于函数模板名称的前面，在一对尖括号内部进行声明：

  ```c++
  template <typename T>　　　　　　 //T是模板参数
  ```

- 调用参数：位于函数模板名称之后，在一对圆括号内部进行声明：

```c++
T max (T const& a, T const& b)　　 //a和b都是调用参数
```


- **一定要让函数模板的所有重载版本的声明都位于它们被调用的位置之前（一般都放在同一个头文件中）**



### 1.1.3 二阶段检查。搭配深度探索对象模型里面的模板一起看。

- **模板的工作原理，并不是把模板编译成一个可以处理任何类型的单一实体；而是对于实例化模板参数的每种类型，都从模板产生出一个不同的实体。**

在实例化模板的时候，如果模板参数类型不支持所有模板中用到的操作符，将会遇到编译期错误。

**但是在定义的地方并没有遇到错误提示。这是因为模板是被分两步编译的。所以我们可以说：在实例化时，模板被编译了两次，分别发生在模板定义阶段（实例化之前），和模板实例化阶段（实例化期间）**

- 在**模板定义阶段**，模板的检查并**不包含类型参数的检查**。只包含下面几个方面：
  -  语法检查。比如少了分号。
  -  使用了未定义的不依赖于模板参数的名称（类型名，函数名，......）。
  -  未使用模板参数的 `static assertions`。
  -  简而言之，就是先检查模板代码本身，查看语法是否正确；在这里会发现错误语法，如遗漏分号等。 

- 在**模板实例化阶段**，为确保所有代码都是有效的，**模板会再次被检查，尤其是那些依赖于类型参数的部分**。
  - 检查模板代码，查看是否所有的调用都有效。在这里会发现无效的调用，如该实例化类型不支持某些函数调用等。

举例：

```c++
template<typename T>
void foo(T t)
{
	undeclared(); // 如果 undeclared()未定义，第一阶段就会报错，因为与模板参数无关
	undeclared(t); //如果 undeclared(t)未定义，第二阶段会报错，因为与模板参数有关
	static_assert(sizeof(int) > 10,"int too small"); // 与模板参数无关，总是报错
	static_assert(sizeof(T) > 10, "T too small"); //与模板参数有关，只会在第二阶段报错
}
```

**需要注意的是，有些编译器并不会执行第一阶段中的所有检查。因此如果模板没有被至少实例化一次的话，你可能一直都不会发现代码中的常规错误。**



### 1.1.4 编译和链接

- 由于 **C++中使用的是静态模板的机制**，所以当使用函数模板，并且引发模板实例化的时候，编译器（在某时刻）需要查看模板的定义。这就不同于普通函数中编译和之间的区别，因为对于普通函数而，只要有该函数的声明（不需要定义），就可以顺利通过编译因为在这里需要的是定义，所以可以考虑在头文件内部实现每个模板以使用编译器能够顺利的找到模板的定义。



## 1.2 函数模板参数推导

### 1.2.1 函数模板参数类型推导中的类型转换

- 在类型推断的时候自动的类型转换是受限制的：
  - **如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数 T 定义的两个参数，它们实参的类型必须完全一样。每个 T 都必须正确匹配。**。
  - **如果调用参数是按值传递的（P是非引用的时候），那么只有退化（decay）这一类简单转换是被允许的**：（和杂记里面的函数模板参数推导一样）
    - `const` 和 `volatile `限制符会被忽略 （A 的 cv 限定符被忽略.）
    - 引用被忽略（A 的引用属性被忽略.）
    - raw array（原始数组） 和函数被转换为相应的指针类型。（如果 A 是数组或函数, P 是值时, 数组和函数退化为指针. ）
    - （隐藏，此处不相干，但还是谢在这里。和杂记中的函数模板参数推导一样）如果 P 是无 cv 限定符的转发引用 (即 T&&), 且 A 是左值时, T 被推导为左值引用.
    - **通过模板类型参数 T 定义的两个参数，它们实参的类型在退化（decay） 后也必须一样**

通常而言，你必须指定**最后一个不能被隐式推导的模板实参之前的**所有实参类型。也就是我们必须显式指定所有模板参数的类型，直到某一个模板参数的类型可以被推断出来为止。

**然而，模板的实参推导并不适合返回类型（可以把推导看成是重载解析的一部分--重载解析是一个不依赖于返回类型选择的过程，唯一的例外就是转型操作符成员的返回类型）。**

### 1.2.2 对默认调用参数的类型推断

需要注意的是，类型推断并不适用于默认调用参数。例如：

```c++
template<typename T>
void func(T a = 12){
    cout << "called" << endl;
}
int main(){
    func(1); //OK 没问题 推导为int
    func(); //编译器发出抱怨，甚至想骂人。
    return 0;
}
```

为应对这一情况，你需要给模板类型参数也声明一个默认参数

```c++
template<typename T = int> //注意这里
void func(T a = 12){ //这里
    cout << "called" << endl;
}
int main(){
    func(); //OK
    return 0;
}
```

**注意，给定的模板默认参数应该和函数默认参数的类型一致。**



## 1.3 多个模板参数

好像是废话，但是水还是蛮深的。我们一起看一下。

```c++
template<typename T1, typename T2>
T1 func(T1 a, T2 b){
    return b < a ? a : b;
}
int main(){
    auto ret = func(1,2.345);
    return 0;
}
```

- 看上去就和我们想的一样，它可以接受两个不同类型的调用参数。但是如示例代码所示，这也导致了一个问题:
  - **如果你使用其中一个类型参数的类型作为返回类型，不管是不是和调用者预期地一样，当应该返回另一个类型的值的时候，返回值会被做类型转换。这将导致返回值的具体类型和参数的传递顺序有关。**
  - 例子：如果传递 2.345 和 1 给这个函数模板，返回值是 double 类型 的 2.345，但是如果传递 1 和 2.345，返回值却是 int 类型的 2。因为我们固定返回较大的数字。但是返回值类型会被进行隐式转换。

所以我们有三个方法解决这个问题：

1. 引入第三个模板参数作为返回类型。
2. 让编译器找出返回类型。
3. 将返回类型定义为两个参数类型的“公共类型。

### 1.3.1 做为返回类型的模板参数

我们还记得模板有两种参数：模板参数和调用参数。

- 当模板参数和调用参数之间没有必然的联系，且模板参数不能确定的时候，就要显式的指明模板参数。比如你可以引入第三个模板来指定函数模板的返回类型

```c++
template<typename RT, typename T1, typename T2>
RT func(T1 a, T2 b){
    cout << "called" << endl;
}
```

- **但是模板类型推断不会考虑返回类型，而 `RT` 又没有被用作调用参数的类型。因此 `RT` 不会被推导。**这样就必须显式的指明模板参数的类型。比如：

```c++
template<typename RT, typename T1, typename T2>
RT func(T1 a, T2 b){
    cout << "called" << endl;
}
int main(){ 
    func<int>(1,2.345); //注意。后面两个可以省略。因为可以被推导。
    return 0;
}
```

**通常而言，我们必须显式指定所有模板参数的类型，直到某一个模板参数的类型可以被推断出来为止。**



### 1.3.2 利用auto，decltype 和（可选的）尾置返回类型进行返回类型推导

C++14开始可以使用`auto`和`decltype `搭配（可选的）尾置返回类型对返回值类型进行推导。

```c++
template<typename T1, typename T2> //不使用尾置返回类型
auto func(T1& a, T2& b){
    return b < a? a: b;
}


template<typename T1, typename T2> //使用尾置返回类型
auto func(T1& a, T2& b) -> decltype(b<a? a:b){
    return b < a? a: b;
}
```

- **在不使用尾置返回类型（trailing return type）的情况下将` auto` 用于返回类型，要求返回类型必须能够通过函数体中的返回语句推断出来。**当然，这**首先要求返回类型能够从函数体中推断出来**。因此，必须要有这样可以用来推断返回类型的返回语句，而且**多个返回语句之间的推断结果必须一致。**
- 注意`decltype`推导过程是在编译期完成的，**并且不会真正计算表达式的值**。
- 此处要注意可能返回值类型可能会被推导为引用类型。请查看下面的文章。

`decltype`过于复杂，可以看这里[decltype详解](https://www.cnblogs.com/5iedu/p/11222078.html)

### 1.3.3 利用std::common_type将返回类型声明为公共类型（common type)

不是很能理解。参见书籍吧。

## 1.4 模板默认参数

- 可以在模板默认参数中使用`common_type`或者是`decay`
- 和函数默认值不同，在函数模板参数中，即使后面的模板参数没有默认值，我们依然可以让第一个模板参数有默认值。并且此时调用时可以不显式指定`<>`

```c++
template<typename RT = int, typename T1, typename T2>
RT func(T1 a, T2 b){
    return a;
}
int main(){
    auto c = func(1,2.234); //并且此时调用时可以不显式指定<>
    return 0;
}
```

## 1.5 函数模板重载

像普通函数一样，模板也是可以重载的。也就是说，你可以定义多个有相同函数名的函数，当实际调用的时候，由 C++编译器负责决定具体该调用哪一个函数。即使在不考虑模板的时候，这一决策过程也可能异常复杂。

- 和普通函数一样，函数模板可以被重载。不止可以被重载，还可以进行特化。但是函数模板只能全特化。

  -  如果函数模板和普通函数都可以实现（同名的函数模板可以被实例化为与非模板函数具有相同类型的调用参数），**在所有其它因素都相同的情况下，优先调用普通函数而不是从模板实例化出来的函数。**
  -  **如果模板可以实例化出一个更匹配的函数，那么就会优先调用函数模板。**（比如如果普通函数涉及到类型转换的时候，则如果模板更加匹配则会调用模板函数）
  -  **可以使用空模板参数列表来强制调用函数模板**
  -  **在模板参数推断时不允许自动类型转换，而常规函数是允许的**
  -  **当有多个特化的函数模板可以被匹配的时候，会有二义性导致报错。**

  

```c++
void test(int a, int b){
    cout << "普通函数" << endl;
}

template <typename T>
void test(T a, T b){
    cout << "模板函数" << endl;
}

template <typename T>
void test(T a, T b, T c){
    cout << "重载的模板函数" << endl;
}

int main(){
    test(1,2); //输出普通函数
    test<>(1,2); //使用空模板参数列表 输出模板函数
    test(1,2,3); //输出重载的模板函数
}
```

- 通常而言，在重载模板的时候，要尽可能少地做改动。你应该只是改变模板参数的个数或者显式的指定某些模板参数。比如不要一会儿值传递一会儿引用传递。

## 第2章 类模板

- 类模板的声明：

```c++
类模板的声明：
template<typename T>
class Stack{
    Stack(Stack<T> const &);
    ~Stack();
    Stack<T> operator=(Stack<T> const &);
};
```

- 区分两种写法：类的类名 `Stack`、类的类型 `Stack<T>`
  - 当在声明中需要使用类的类型时，你必须使用` Stack<T>`（大部分情况）
  - 然而当使用类名而不是类的类型时，就应该只用 `Stack`（比如指定类的名称、构造和析构函数名）
- 类模板可以偏特化也可以全特化。

```c++
template<未被特化的部分>
class obj<特化的部分, 未被特化的部分>{
  ...  
};
template<typename T1, typename T2>
class test{
    T1 data1;
    T2 data2;
};
//全特化
template<>
class test<int, float>{
    int data1;
};
//偏特化
template<typename T2>
class test<int, T2>{
    int data1;
};
```

- 类模板调用顺序： 对主版本模板类、全特化类、偏特化类的调用优先级从高到低进行排序是：全特化类>偏特化类>主版本模板类。这样的优先级顺序对性能也是最好的。 

- **只有那些被调用的成员函数，才会产生这些函数的实例化代码。对于类模板，成员函数只有在被使用的时候才会实例化。**
  - 因为在编译阶段，编译器无法确认模板的参数类型，所以无法创建模板类成员函数
  - 显然，这样可以节省空间和时间；另一个好处是对于那些 未能提供所有 “ 成员函数中所有操作的类型“，你也可以使用该类型来实例化类模板，只要对那些 未能提供 “  某些操作的” 成员函数，模板内部不使用就可以。而且现在的 C++标准要求编译器要尽可能的延迟实例化的时机。

- **静态成员的无条件实例化：如果类模板中含有静态成员，那么用来实例化的每种类型，都会实例化这些静态成员。**

- **类模板不能被重载**

## 2.6 多模板参数的偏特化

偏特化有多种形式。下面的几种都可以。

```c++
template<typename T1, typename T2>
class MyClass {
    //主模板
};

template<typename T>
class MyClass<T,T> {
    //两个参数同一个类型。
    //注意这里不一定非得写T1 T1。类型具体叫什么没所谓
};

template<typename T>
class MyClass<T,int> {
    //第二个参数是int
};

template<typename T1, typename T2>
class MyClass<T1*,T2*> {
    //两个参数为指针。
};
```



## 2.7 类模板默认参数

类模板自然可以有默认参数。比如很多STL的实现。下面是一个小例子

```c++
template<typename T1, typename T2 = int>
class obj{
     public:
     obj(T1 a, T2 b):val1(a), val2(b){};
     T1 val1;
     T2 val2;
};
```



## 2.8 类型别名 Aliases

一般来说，我们有两种方式可以给类型定义别名。`using` 和 `typedef`

- typedef

  ```c++
  template<typename T>
  class myobj{
      public:
      myobj(T a):val(a){};
      T val;
  };
  
  typedef myobj<int> INTmyobj;
  typedef myobj<double> DOUBLEmyobj;
  
  int main(){
      INTmyobj im(2);
      DOUBLEmyobj dm(2.345);
      cout << im.val << endl;
      cout << dm.val << endl;
      return 0;
  }
  ```

- using

```c++
using usingINTmyobj = myobj<int>;
using usingDOUBLEmyobj = myobj<double>;

usingINTmyobj im(2);
usingDOUBLEmyobj dm(2.345);
```

## 2.9.1 别名模板 Alias Templates

注意。这里是typedef和using在别名方面唯一区别。这里只有using。typedef不可以。

比如我们不可以：

```c++
template<typename T>
typedef myobj<T> intobj;
```

但是可以：

```c++
template<typename T>
using intobj = myobj<T>;]

intobj<int> myobj(2);
```

## 2.9.2 必须显式使用typename的情况

参看笔记STL2

## 2.9.3 类模板的类型推导

直到C++17，我们都必须显式指出所有类模板参数的类型。除非拥有默认值。

剩下的看书。

## 2.9.4 聚合类型的模板化

可以定义聚合类的类模板。关于聚合类，参考聚合初始化。



# 第三章 非类型模板参数

杂记3有写。这里重新整理

## 3.1 类模板的非类型模板参数 - 3.2 函数模板的非类型模板参数

```c++
template<typename T>
void func(T obj){
    //...
}

int main(){
    func<int>(5);
    return 0;
}
```

- **我们都知道模板参数一般都是类型。比如这里，`T`就是`int`。是类型。当我们希望传入一个不是类型的参数的时候，比如如果我们有时候需要一些特殊情况， 例如想要传点奇怪东西的时候就可以使用非类型模板参数。**

```c++
template<typename T, int MAXSIZE> //注意语法。这里非类型模板参数不再是typename了
void func1(T obj){
    vector<T>a;
    a.reserve(MAXSIZE);
    cout << a.capacity() << endl;
    a.push_back(obj);
    cout << a[0] << endl; 			//干啥了不解释了 忽略即可
}

```

- **这里的`int MAXSIZE`就是非类型模板参数。因为他不是类型，而是变量。**

使用非类型模板参数是有限制的。通常它们只能是：

1. 整型常量或字面值（包含枚举，或可隐式转换的比如`bool`）（`string` `double`都不可以。前者是类对象，后者是浮点数）
2. 指向对象/函数/成员变量的指针
3. 对象/函数的左值引用
4. `std::nullptr_t`

当传递对象的指针或者引用作为模板参数时，对象不能是字符串常量，临时变量或者数据成员以及其他子对象。由于C++17之前，C++每次版本更新都会放宽以上限制，因此还有一些针对不同版本的限制：

- C++11中，对象必须要有外部链接
- C++14中，对象必须是外部链接或者内部链接

所以：传入的`s`必须是常量。

```c++
const int s = 8;	//必须是const
func1<int, s>(5);
func2<int, 4>(5); //或者直接传入字面值。
```



### 搭配类模板偏特化的小例子

```c++
template<typename T, bool option>
class myclass; //主模板不实现

template<typename T>
class myclass<T, true>{ //偏特化1，注意语法。T在这里依旧要写上。
    public:
    void func(){
        cout <<"true one" << endl;
    }
};


template<typename T>
class myclass<T, false>{ //偏特化2，注意语法。T在这里依旧要写上。
    public:
    void func(){
        cout <<"false one" << endl;
    }
};

int main(){
    const bool myoption = true;
    myclass<int, false> obj; //直接使用字面值
    obj.func();
    myclass<int, myoption> obj1; //或必须用const常量变量。
    obj1.func();
    return 0;
}
```



- 两者的非类型模板参数都可以指定默认值：

```c++
template<typename T, int TS = 5> //注意语法。这里非类型模板参数不再是typename了
class myobj{
    public:
    myobj(T a):val(a){my_vec.reserve(TS);};
    T val;
    vector<T> my_vec;
};

template <typename T, int TS = 10> //注意语法。这里非类型模板参数不再是typename了
void func(T a){
    vector<T> my_vec(TS);
    cout <<"called" << endl;
    cout << my_vec.capacity() << endl;
}
int main(){
    myobj<int,8> instance(10);
    cout << instance.my_vec.capacity() << endl;
    //输出8
    func<int, 9>(2);
    //输出 called 9
    
    return 0;
}
```

## 3.3 避免无效表达式

非类型模板参数可以是任何编译器表达式。比如：

```c++
//函数模板
template <int size, bool judge> //注意表达式不写在这。
void func(){
    cout << size << endl;
    if(judge == true){
        cout << "true" << endl;
    }
    else{
        cout << "false" << endl;
    }
}

//类模板
template <int size, bool judge>
class myobj{
    public:
    myobj(){
        my_vec.reserve(size);
        testfunc();
    };
    void testfunc(){
        cout << my_vec.capacity() << endl;
        if(judge == true){
            cout << "true" << endl;
        }
        else{
            cout << "false" << endl;
        }    
    }
    vector<int> my_vec;
};
int main(){
    func<10, sizeof(int) == 4>(); //注意表达式写在这。写在实例化位置而非模板参数位置。
    //输出true
    func<10, (sizeof(int) > 4 )>(); //注意这里表达式要额外一组括号。
    //输出false
    myobj<10, sizeof(int) == 4> instance;
    //输出10 true
    myobj<10, (sizeof(int) > 4 )> instance1;
    //输出10 false
    return 0;
}
```

- **不过如果在表达式中使用了` operator >`，就必须将相应表达式放在括号里面，否则`>`会被作为模板参数列表末尾的`>`，从而截断了参数列表**



## 3.4 使用auto做为非模板类型参数 （C++17）

暂略。看书。



# 第四章 变参模板

## 4.1 函数的变参模板

- 基本定义

```c++
template <typename T, typename... Args>  //注意这里的Args叫模板参数包
// 如果函数参数列表中一个参数的类型是一个模板参数包,
// 则此参数也是一个函数参数包
void func(const T& t, const Args&... rest); //这里的rest叫函数参数包
```

- **一定要注意区分开在模板头声明的模板参数包和函数头的函数参数包的区别。**
- C++17之前的写法：因为没有折叠表达式

```c++
void print (){
//必须要有无参重载，否则会无限递归。也就是最后一次无参无法被调用。
//最后一次被解包后，参数包会为空。所以会调用无参函数。
}
template<typename T, typename... Args>
void print (T firstArg, Args... args)
{
    cout << firstArg << endl; //print first argument
    print(args...); // call print() for remaining arguments
}
int main() 
{
    print(1, 1000, "b23", 1.123, "HahaahaH", 42);
    return 0;
}
```

- C++17之后的写法：有了折叠表达式
  - 此处折叠表达式和逗号运算符语法会在下文补充。


```c++
template<typename T> //要有单参打印的重载。不然会无限调用。
void print(T t){
    cout << t << endl;
}


template<typename... Args>
void print(Args... args){
    (print(args), ...); //这里外部一定要加括号。注意语法。这里的,是逗号运算符。
}


int main() 
{
    print(1, 1000, "b23", 1.123, "HahaahaH", 42);
    return 0;
}
```

- **多种变长参数模板可以同时存在 尽管直观看起来会有二义性**

### 搭配列表初始化

- 函数变长参数模板搭配列表初始化。
  - 这个函数会返回一个`T`类型的`vector`，元素是`args`

```c++
template<typename T, typename... Args>
vector<T> func(const Args&... args){
    return {args...};
}
int main(){
    auto vec = func<int>(1,2,3,4,5,6,7);
    for(auto& i:vec){
        cout << i << endl;
    }
}
/*
输出：
1
2
3
4
5
6
7
*/
```



## 4.1.2 变参和非变参模板的重载

我们提到了多种变长参数模板可以同时存在 尽管直观看起来会有二义性。所以上面C++17前的写法可以写成这样子：

```c++
template<typename T>
void print (T arg){
    cout << arg << endl;
}
template<typename T, typename... Args>
void print (T firstArg, Args... args)
{
    print(firstArg); //注意这里。这里调用了无模板参数包的函数。单独打印这次解包出来的这一个变量。
    print(args...); // call print() for remaining arguments
}
int main() 
{
    print(1, 1000, "b23", 1.123, "HahaahaH", 42);
    return 0;
}
```

- **简单来说，当两个函数模板的区别只在于尾部的参数包的时候，会优先选择没有尾部参数包的那一个函数模板。**



## 4.1.3 sizeof运算符在变长模板中的特殊应用。

等看到8.5再来整理这部分。



## 4.2 折叠表达式 (fold expression)

**折叠表达式的展开过程并不是递归。更多的是类似于一种替换，一种编译时展开替换。个人理解。**

折叠表达式分为四种：

- 左折：参数从左侧开始计算  

  - 一元左折叠

  ```
  ( ... 运算符 形参包 )
  会被拓展为
  (((E1 运算符 E2) 运算符 ...) 运算符 EN)
  ```

  - 二元左折叠

  ```
  ( 初值 运算符 ... 运算符 形参包 )	
  会被拓展为
  ((((初值 运算符 E1) 运算符 E2) 运算符 ...) 运算符 EN)
  ```

- 右折：参数从右侧开始计算

  - 一元右折叠

  ```
  ( 形参包 运算符 ... )
  会被拓展为
  (E1 运算符 (... 运算符 (EN-1 运算符 EN)))
  ```

  - 二元右折叠

  ```
  ( 形参包 运算符 ... 运算符 初值 )	
  会被拓展为
  (E1 运算符 (... 运算符 (EN−1 运算符 (EN 运算符 初值))))
  ```

- 左折叠右折叠在有顺序要求的时候尤其重要。比如减法和除法。

  - 注意左右不是指的是单个顺序颠倒。而是每一组顺序颠倒。

  - 比如` ((a+b)+c)` 变成右折并不是`(a+(c+b))`。而是`(a+(b+c))`

- **将一元折叠用于长度为零的包展开时，只能使用下列运算符：**

  - 逻辑与（&&）。空包的值是 true

  - 逻辑或（||）。空包的值是 false

  - 逗号运算符（,）。空包的值是 void()

  - 其他操作符为不合规。

- **在二元折叠中，两个运算符必须相同**

  - 不可以一加一减。

- 语法示范：

```c++
//一元左折叠加法
template<typename... T>
auto foldSumLeft(T... s)
{
    return (... + s); // ((s1+s2)+s3)...
}

//一元右折叠加法
template<typename... T>
auto foldSumRight(T... s)
{
    return (s + ...); // (s1+...+(Sn-1 + sn)))...)
}
//一元左折叠减法
template<typename... T>
auto foldMinLeft(T... s)
{
    return (... - s); // ((s1-s2)-s3)...
}
//一元右折叠减法
template<typename... T>
auto foldMinRight(T... s)
{
    return (s - ...); // (s1-...-(Sn-1 - sn)))...)
}

int main(){
    auto sumLeft = foldSumLeft(1,2,3,4,5,6,7); //((((((1+2)+3)+4)+5)+6)+7)
    auto sumRight = foldSumRight(1,2,3,4,5,6,7);
    cout << sumLeft << endl; //28
    cout << sumRight << endl;//28
    auto sumLeftmin  = foldMinLeft(1,2,3); //((1-2)-3)
    auto sumRightmin  = foldMinRight(1,2,3);//(1-(2-3))
    cout << sumLeft << endl; //-4
    cout << sumRight << endl;//2
}


//二元左折
template <typename... T>
auto foldBinLeft(T... s)
{
    //操作对象有两个，一个是888 初值，一个是ts形参包,
    //初始值位于左边，所以为二元左折
    return (888 + ... + s);
}
//二元右折
template <typename... T>
auto foldBinRight(T... s)
{
    //操作对象有两个，一个是888 初值，一个是ts参包,
    //初始值位于右边，所以为二元右折
    return (s + ... + 888);
}
int main(){
    auto binLeft = foldBinLeft(1,2,3); //894 (((888+1)+2)+3)
    auto binRight = foldBinRight(1,2,3); //894 (1+(2+(3+888)))
    cout << binLeft << endl;
    cout << binRight << endl;
}
```



- 如果用作 初值 或 形参包的表达式在顶层具有优先级低于转型的运算符，那么它必须加括号：
- 此处仅用二元右折做个示范。注意此时两个操作符都是`+`。所以合法。

```c++
template <typename... T>
auto foldBinRight(T... s)
{
    return (s + ... + (888*2)); //可以
    return (s + ... + 888*2); //不可以
}
```

### 序列点和逗号运算符在折叠表达式中的特殊性质

序列点的定义可以查一下文档。简单来说就是我们需要约束一个表达式的计算顺序。

我们上面提到了这个代码：

```c++
template<typename... Args>
void print(Args... args){
    (print(args), ...); //这里外部一定要加括号。注意语法
    (..., print(args));//??
}

```

我们发现第一行是右折叠。按理来说应该是逆序输出。但是为什么这里左折和右折效果一样？

**这就是序列点和逗号运算符的特殊性。**

- **C++有强制规定：内建[逗号运算符](https://zh.cppreference.com/w/cpp/language/operator_other#.E5.86.85.E5.BB.BA.E7.9A.84.E9.80.97.E5.8F.B7.E8.BF.90.E7.AE.97.E7.AC.A6) , 的第一个（左）参数的每个值计算和副作用都按顺序早于第二个（右）参数的每个值计算和副作用。**
- 也就是说，这里的左折叠和右折叠的优先级是低于逗号运算符的。所以说逗号运算符强制从左到右的运算顺序使得这里的左折和右折失效。产生了同等效果  。
- 所以，这里在展开后，依旧会从左至右进行运算。
- 再次重申：折叠表达式的展开过程并不是递归。
- 所以它展开后可以被化简看作：

```c++
print(1), print(1000), print("b23"),.....;
```

此部分参考：

https://stackoverflow.com/questions/46056268/order-of-evaluation-for-fold-expressions

https://stackoverflow.com/questions/59590426/variadic-template-argument-forwarding-uses-comma-operator

https://stackoverflow.com/questions/53330713/fold-expression-with-comma-operator-and-variadic-template-parameter-pack

https://stackoverflow.com/questions/45603533/how-does-folding-over-comma-work

## 4.3 变参模板的使用

之前关于常规模板参数的规则同样适用于变参模板参数。

- 比如，如果参数是按值传递的，那么其参数会按照正常理解被拷贝，类型也会退化（decay）。
- 如果是按引用传递的，那么参数会是实参的引用，并且类型不会退化



## 4.4 变参类模板和变参表达式

### 4.4.1 在变参中使用表达式

此处是针对4.2的一些扩展。也就是折叠表达式的一种应用。

我们可以将函数参数包参与到一些运算当中：

- **这里，我们把传入的每一个参数的数值都增加一倍**
  - 注意字面值是`const char*`类型。

```c++
template<typename T> //要有单参打印的重载。不然会无限调用。
void print(T t){
    cout << t << endl;
}


template<typename... Args>
void print(Args... args){
    (print(args), ...); //这里外部一定要加括号。注意语法。这里的,是逗号运算符。
}


template<typename... T>
void printDoubled (T const&... args)
{
    print (args + args...);
}   

int main(){
    printDoubled(1, 2.3, string("abcde")); //输出 2 4.6 abcdeabcde。注意字面值是`const char*`类型。
    //等于调用 print(1+1), print(2.3 + 2.3), print(string("abcde") + string("abcde"))
    return 0;
}
```

- **如果只是想每一个都加1，那么后面的参数包位置则必须字面值和数字分开。**

```c++
template<typename... T>
void printDoubled (T const&... args)
{
    print(1 + args...); //要么这么写
    print(args + 1 ...); //要么这么写。但是1和...必须分开。
    print((args + 1)...); //要么这么写。多加个括号。
}   
```

- 编译阶段的表达式同样可以像上面那样包含模板参数包。比如下面这个例子可以用来判断所有参数包中参数的类型是否相同
  - 注意这里是函数模板的例子。函数模板可以自动推导类型。

```c++
template<typename T1, typename... TN>
constexpr bool isSameType (T1, TN...)
{
    return (std::is_same<T1,TN>::value && ...); // since C++17
}

int main(){
    cout << isSameType(1,2,3,4) << endl; //输出1 true
    //这一行会被扩展为 std::is_same<int,int>::value && std::is_same<int,int>::value && std::is_same<int,int>::value
    cout << isSameType(1,2,"123",4) << endl; //输出0 false
    //这一行会被扩展为 std::is_same<int,int>::value && std::is_same<int,const char*>::value && std::is_same<const char*,int>::value
    cout << isSameType("abc", "abcde") << endl; //输出1 true 特别注意这里
    return 0;
}
```

- 注意最后一个调用。这里因为是按值传递，所以发生了类型退化，统一被推导为`const char*`。
- 否则类型将依次被推断为：`const char [3]` 和 `const char[5]`;
  - 所以如果`isSameType`写成这个样子就不会退化，导致输出`false`
  - `constexpr bool isSameType (T1&, TN&...)`
    - 这里参见函数模板参数推导规则。这里我们看到传入的是数组，然后模板函数的入参部分(不是模板参数部分)是引用了，所以这时候传入的参数不会退化。也就是里面的`T1`和`TN`维持住了非退化类型。







### 4.4.2 在变参中使用下标 (variadic indices)

这里看起来可能比较晦涩，但是是一个比较实用的功能。

- 假设我们有两个参数。第一个参数是一个容器，第二个参数是一个下标。我们想访问这个容器的这个下标的元素应该怎么做？

```c++
template<typename Container, typename Index>
void getItem(Container& container, Index idx){
    cout << container[idx] << endl;
}

int main(){
    //printDoubled(1, 2.3); //输出 2 4.6
    vector<string> my_vec{"abc", "def", "ghi", "123", "456"};
    getItem(my_vec, 3); //输出 123
    return 0;
}
```

- 好的。那么我们如果想要把这个功能融入到变参里面呢？比如我想要拿出多个元素，怎么做呢？
  - 注意这里我们参数包为下标，而不是容器。
  - 非常方便。

```c++
template<typename T> //要有单参打印的重载。不然会无限调用。
void print(T t){
    cout << t << endl;
}


template<typename... Args>
void print(Args... args){
    (print(args), ...); //这里外部一定要加括号。注意语法。这里的,是逗号运算符。
}
//--------------------------上面是之前我们一直在用的print模板，这里也放一个方便查看---------------------
template<typename Container, typename... Index> //模板参数包
void getMultipleItem(Container& container, Index... idx){//函数参数包
    print(container[idx]...); //参数包
}
int main(){
    vector<string> my_vec{"abc", "def", "ghi", "123", "456"};
    getMultipleItem(my_vec, 1,2,3,4);
    //输出def ghi 123 456
    return 0;
}
```

- `getMultipleItem(my_vec, 1,2,3,4);` 相当于调用了：
  - `print(my_vec[1], my_vec[2], my_vec[3], my_vec[4])`;





#### **同时我们也可以将非类型模板参数声明成参数包：**

```c++
template<int... Idx, typename Container> //细节1
void getMultipleItem(Container& container){ //细节2
    print(container[Idx]...);
}
int main(){
    vector<string> my_vec{"abc", "def", "ghi", "123", "456"};
    getMultipleItem<1,2,3,4>(my_vec); //细节3
    //输出def ghi 123 456
    return 0;
}
```

- 首先，非类型模板参数不是类型，是变量。所以无需传入函数参数。只需在模板参数中传入（细节1，2）
- 细节3，这里既然是模板参数而非函数参数，所以这里要用`<>`传入模板参数



### 4.4.3 在类模板中使用可变参数（变参类模板）

























# std::is_same

- is_same的主要作用是判断两个类型是否相同。

```c++
template< class T, class U >
struct is_same;
```

- 如果T与U是考虑`const-volatile`限定的相同类型，则`is_same<T,U>::value`为true，否则为false。

举例：

```c++
int main(){
    cout << is_same<int, int>::value << endl; //输出1 (true)
    cout << is_same<int, string>::value << endl; //输出0 (false)
    return 0;
}
```

## 可能的实现

```c++
template<typename _Tp,_Tp _v>
struct intergral_constant{
    static constexpr _Tp value = _v; //表示值
    typedef _Tp value_type; //值类型
    typedef intergral_constant<_Tp,_v> type; //表示自己的类型

    constexpr operator value_type () const noexcept {return value;} 
    constexpr value_type operator()() const noexcept {return value;} //since c++14
};
//定义true_type 和 false_type
typedef intergral_constant<bool, true> true_type;
typedef intergral_constant<bool, false> false_type;

//is_same的实现
template <typename T1,typename T2>
struct is_same: public false_type {};
//类型相同就相当于一个模板参数
template <typename _Tp>
struct is_same<_Tp,_Tp>: public true_type {};
```

- 首先定义了一个类模板`is_same`，这个类模板有两个模板参数`T`和`U`。接着针对这个类模板`T`和`U`类型相同的情况进行偏特化。所以，当`T`和`U`为同一种类型时，将匹配到`1`,不同则匹配到`0`。两个版本唯一的不同是父类。
- 然后是判断两个类型，如果两个类的类型不同，那么应该是继承自`false_type`，如果类型相同的话应该继承自`true_type`。

## 自己模拟一下简单实现

```c++
template<typename T1, typename T2>
class MyClass {
    public:
    //主模板 如果两个类型不一则会匹配到这里
    MyClass(T1 a, T2 b):val1(a), val2(b){
        cout <<"diff type" << endl;
    }
    T1 val1;
    T2 val2;
};

template<typename T>
class MyClass<T,T> {
    public:
    //同一类型的偏特化模板。如果两个类型一致则会匹配到这里
    MyClass(T a, T b):val1(a), val2(b){
        cout << "same type" << endl;
    }
    T val1;
    T val2;
};
int main(){
    MyClass<int, int> myobj1(19,22); //输出 same type
    MyClass<int, string> myobj2(11, "abcde"); //输出 diff type
    return 0;
}
```





# 杂项

## 类成员函数不可以既是虚函数又是模板函数

- 首先简单来说，虚函数是动态多态。模板属于静态多态。这里不能动静结合。
- 其次，我们知道了函数模板在编译的时候会看哪些地方调用了。根据T的不同，每一份T都会导致实例化出一份T类型的函数。这就导致了会有多个入参类型不同的成员函数。但是我们又知道虚函数的虚函数表必须预先确定。而此时父类看不到子类的模板虚函数到底有几个版本，难不成都写一遍？
- 另一个原因是如果我们有模板虚函数，那么编译器为了确定类的虚函数表的大小，就必须要知道我们一共为该成员模板函数实例化了多少个不同版本的虚函数。显然编译器需要查找所有的代码文件，才能够知道到底有几个虚函数，这对于多文件的项目来说，代价是非常高的。
- 也就是说，如果这样做的话，虚函数表的确定时间就需要从编译器推迟到链接期。因为编译期指的是我不需要看具体实现。我只要发现你是`virtual`我就可以把你放到表内。如果支持模板虚函数，那么就需要链接的时候把每一个实现都扫一遍然后再整理后放入虚函数表。

## 为什么类模板有偏特化没有重载，但是函数模板没有偏特化有重载？

问题也是答案。因为类模板没有重载所以有偏特化。因为函数模板幼虫在所以没有偏特化。
