---
title: C++内存管理- 7~8 
date: 2022-05-29 19:55:00 -0500
categories: [笔记]
tags: [内存管理]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true

---

# C++内存管理 - 7~8 

# 此笔记需要等待更新和确认。



## array new 和 array delete

用new和delete对数组进行操作时，会调用对应长度的次数的构造/析构函数 并分配/释放对应大小的内存。

```c++
Complex* pca = new Complex[3]; //这里会调用三次构造函数
delete[] pca; //这里会调用三次析构函数。三次会指向不同的对象
```

![QQ截图20220530022057](/assets/blog_res/2022-05-29-memory2.assets/QQ%E6%88%AA%E5%9B%BE20220530022057.png)



**注意 用new创建array的时候，我们无法使用构造函数对array进行赋值。所以这里默认调用的是无参构造函数。也所以我们必须设置默认无参构造函数。**

![微信图片_20220530023335](/assets/blog_res/2022-05-29-memory2.assets/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220530023335.png)



**构造从前到后，析构从后往前**



## operatior new

`operator new` 有三种形式。

```c++
(1) void* operator new (std::size_t size);
(2) void* operator new (std::size_t size, const std::nothrow_t& nothrow_value) noexcept;
(3) void* operator new (std::size_t size, void* ptr) noexcept;
```

1. 第一种形式分配size字节的存储空间，如果成功的话返回一个非空指针，指向分配空间第一个字节。如果失败的话，会抛出bad_alloc异常。
2. 第二种形式和第一种一样，差别在于，如果失败的话，不抛出异常，而是返回一个null指针。
3. 第三种形式只是返回ptr指针，并不分配内存空间。这里的ptr应该指向先前已经分配好的空间，这里的new调用对象的构造函数，在ptr指向的内存空间构造对象或对象数组。ptr指向的内存只要不释放，可以重复使用。所以这种用法一般在对象池或内存池实现中使用。

## placement new

placement new 的作用是在已有的内存区块上创建对象。也就是仅仅创建对象而不分配内存
```c++
Object * p = new (address) ClassConstruct(...)
```
其中 `address`就是我们指定的内存首地址。

### 注意事项

（1）**用定位放置new操作，既可以在栈(stack)上生成对象，也可以在堆（heap）上生成对象。**

（2）使用语句`A* p=new (mem) A;`定位生成对象时，指针`p`和数组名`mem`指向同一片存储区。所以，与其说定位放置new操作是申请空间，还不如说是利用已经请好的空间，真正的申请空间的工作是在此之前完成的。

（3）使用语句`A *p=new (mem) A;`定位生成对象时，会自动调用类`A`的构造函数，但是由于对象的空间不会自动释放（对象实际上是借用别人的空间），所以必须显式的调用类的析构函数，如`p->~A()`。这一条主要的理解是：你`delete`的时候`delete`的一定是`mem`。但是`delete mem`并不会调用你`A`的析构函数。

（4）万不得已才使用placement new，只有当你真的在意对象在内存中的特定位置时才使用它。例如，你的硬件有一个内存映像的I/O记时器设备，并且你想放置一个Clock对象在哪那个位置。



![QQ截图20220530233747](/assets/blog_res/2022-05-29-memory2.assets/QQ%E6%88%AA%E5%9B%BE20220530233747.png)



**在这张图里，侯捷老师使用了`operator new`的第三种形式， 所以这里等同于`placement new`** 

**可以理解为placement new 是operator new的一种特殊形式**

### placement new 在代码层面等同于 `new(p)` 或 `::operator new(size, void*)`





## 为什么new delete 和 new[] delete[]需要配对使用？

我们经常要用到动态分配一个数组，也许是这样的：

```c++
string *psa = new string[10];      //array of 10 empty strings
int *pia = new int[10];           //array of 10 uninitialized ints
```

上面在申请一个数组时都用到了 `new []` 这个表达式来完成，按照我们上面讲到的 new 和 delete 知识，第一个数组是 string 类型，分配了保存对象的内存空间之后，将调用 string 类型的默认构造函数依次**初始化数组中每个元素**；第二个是申请具有内置类型的数组，分配了存储 10 个 int 对象的内存空间，但**并没有初始化**。

我们在上一篇笔记中提到了。对于new关键字对于**数组**加括号和不加括号的区别

​	1.对于自定义类型数组来说没有区别，都是自动调用其默认构造函数来初始化  

​	2.对于原子（内置）类型来说加括号会初始化，而不加括号则不会初始化

所以这里使用demo的时候是调用了默认构造函数并初始化，但是int不仅没有调用构造函数，也没有初始化。

如果我们想释放空间了，可以用下面两条语句：

```C++
delete [] psa;
delete [] pia;
```

都用到 `delete []` 表达式，注意这地方的 [] 一般情况下不能漏掉！我们也可以想象这两个语句分别干了什么：第一个对 10 个 string 对象分别调用析构函数，然后再释放掉为对象分配的所有内存空间；第二个因为是内置类型不存在析构函数，直接释放为 10 个 int 型分配的所有内存空间。

这里对于第一种情况就有一个问题了：**我们如何知道 psa 指向对象的数组的大小？怎么知道调用几次析构函数？**

**注意这里的做法因编译器而异。有多种实现方式。这仅仅是一种实现方式并拿来举例**

这个问题直接导致我们需要在 new [] 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。

还是用图来说明比较清楚，我们定义了一个类 `Demo`，但不具体描述类的内容，这个类中有显示的构造函数、析构函数等。那么 当我们调用

```C++
Demo *p = new Demo[3];
```

时需要做的事情如下：

![QQ截图20220530030154](/assets/blog_res/2022-05-29-memory2.assets/QQ%E6%88%AA%E5%9B%BE20220530030154.png)

从这个图中我们可以看到申请时在数组对象的上面还多分配了 4 个字节用来保存数组的大小，但是最终返回的是对象数组的指针，而不是所有分配空间的起始地址。

这样的话，释放就很简单了：

```c++
delete []p;
```



这里要注意的两点是：

- 调用析构函数的次数是从数组对象指针前面的 4 个字节中取出；
- 传入 `operator delete[]` 函数的参数不是数组对象的指针 p，而是 p的值减 4。



但是我们如果在内置类型数组中不配对使用呢？

```c++
int *pia = new int[10];
delete pia;
```

这肯定是没问题的。

**首先。指针本身在栈上的。但是指向了堆上的区块地址。数组指针本身不清楚数组大小。但是指向的堆有相应的管理能力。在申请释放的时候，堆的区块自己会维护一个大小。所以对于数组指针来说 直接进行`delete`会释放掉整个数组所占的内存。具体堆是如何做的，不同的编译器，操作系统会有不同的实现。**

其次。因为我们使用的是内置类型，数组中储存的对象并没有在堆上分配额外的内存空间。所以不需要使用析构函数来释放对象中分配过的内存。直接调用`delete`不会出现问题。

但是，用第一张图的string为例。我们如果使用了delete而不是delete[]会有什么问题呢？首先，delete会释放掉数组的空间。然后只执行一次析构函数。执行的这次的析构函数会释放掉数组里面储存的**string对象分配的空间**。可以理解为数组中存的元素自己本身又开辟了额外的空间。这样的话我们其实仅仅释放了数组的空间和一个string对象新开辟的空间。那么剩下两个string对象新开辟的空间将会因为没有调用析构函数而无法释放。

上面我提到了在 `new []` 时多分配 4 个字节的缘由，因为析构时需要知道数组的大小，但如果不调用析构函数呢（如内置类型，这里的 int 数组）？我们在 `new []` 时就没必要多分配那 4 个字节， delete [] 时直接到第二步释放为 int 数组分配的空间。如果这里使用 `delete pia;`那么将会调用 `operator delete` 函数，传入的参数是分配给数组的起始地址，所做的事情就是释放掉这块内存空间。不存在问题的。

这里说的使用 `new []` 用 delete 来释放对象的提前是：对象的类型是内置类型或者是无自定义的析构函数的类类型！

我们看看如果是带有自定义析构函数的类类型，用 `new []` 来创建类对象数组，而用 delete 来释放会发生什么？用上面的例子来说明：

```c++
class A *pAa = new class A[3];
delete pAa;
```

那么 `delete pAa;` 做了两件事：

- 调用一次 pAa 指向的对象的析构函数；
- 调用 **`operator delete(pAa);`** 释放内存。

显然，这里只对数组的第一个类对象调用了析构函数，后面的两个对象均没调用析构函数，如果类对象中申请了大量的内存需要在析构函数中释放，而你却在销毁数组对象时少调用了析构函数，这会造成内存泄漏。

上面的问题你如果说没关系的话，那么第二点就是致命的了！直接释放 pAa 指向的内存空间，这个总是会造成严重的段错误，程序必然会奔溃！因为分配的空间的起始地址是 pAa 指向的地方减去 4 个字节的地方。你应该传入参数设为那个地址！（因为多了一个int的大小记录数组大小）

同理，你可以分析如果使用 new 来分配，用 `delete []` 来释放会出现什么问题？是不是总会导致程序错误？

总的来说，记住一点即可：**new/delete、new[]/delete[] 要配套使用总是没错的！**

