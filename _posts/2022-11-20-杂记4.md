---
title: C++杂记 - 4
date: 2022-11-20 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true
  
---

# 存储类说明符

这是一个被我忽视了的细节。在官方文档中提到了：

- `auto`或 (C++11 前)无说明符 - **自动**存储期。
  - 这类对象的存储在外围代码块开始时分配，并在结束时解分配。未声明为 `static`、`extern` 或 `thread_local` 的所有局部对象均拥有此存储期。

- `register` - 自动存储期，另提示编译器将此对象置于处理器的寄存器。(弃用) (C++17 前)
- `static` - 静态或线程存储期和内部链接。 
  - 这类对象的存储在程序开始时分配，并在程序结束时解分配。这类对象只存在一个实例。所有在命名空间（包含全局命名空间）作用域声明的对象，加上声明带有 `static` 或 `extern` 的对象均拥有此存储期。有关拥有此存储期的对象的初始化的细节，见[非局部变量](https://zh.cppreference.com/w/cpp/language/initialization#.E9.9D.9E.E5.B1.80.E9.83.A8.E5.8F.98.E9.87.8F)与[静态局部变量](https://zh.cppreference.com/w/cpp/language/storage_duration#.E9.9D.99.E6.80.81.E5.B1.80.E9.83.A8.E5.8F.98.E9.87.8F)。

- `extern `- 静态或线程存储期和外部链接。
- `thread_local `- 线程存储期。 (C++11 起) 
- `mutable` - 不影响存储期或链接。解释见 const/volatile。

`static`, `extern` 和 `thread_local` 不必多说，这里主要关注第一个自动储存期。

## 什么是自动储存期？

我们知道，变量一般存在下面地方。

- 全局变量和静态变量：储存在静态存储区（比如BSS段和数据段）

- 常量：依赖于实现，一般存储在静态储存区的数据段或代码段。

- 局部变量：栈区。储存在动态存储区

- `new`的变量：堆区。储存在动态存储区

 

但是注意，当有如下代码

  ```c++
  int main(){
      int* ptr = new int(5);
      return 0;
  }
  ```

  - `ptr`本身没有加储存类说明符，说明是**自动存储期**。我们查看上下文发现是在局部的变量。所以指针`ptr`自己在栈区。而`new`出来的东西在堆区。也就是栈上的指针指向了堆区的数据。



**自动储存期指的是变量分配在哪是依靠上下文决定的。它并不一定在栈上。**

举例子：

```c++
int main(){
    Object obj; //什么意思？
    return 0;
}
```

- 要回答这个问题，我们首先要理解这个语句是什么意思。这行语句的含义是，使对象`obj`具有自动储存期的性质。所谓自动储存期，意思是这个对象的存储位置取决于其声明所在的上下文。

此时我们看到，这个语句出现在函数内部并且没有其他修饰符，那么它就在栈上创建对象。



**如果这个语句不是在函数内部，而是作为一个类的成员变量，则取决于这个类的对象是如何分配的。**考虑下面的代码：

```c++
class myClass{
    public:
    	Object obj; //它在哪？
};
int main(){
    myClass* ptr = new myClass;
    return 0;
}
```

- 指针`ptr`所指向的对象在堆上分配空间。但是因为`Object obj;`语句的含义是“变量具有自动存储期”。我们查看其上下文，发现包含`ptr->obj`的变量处于堆上。所以，`ptr->obj`也是在堆上创建的。

我们继续看下面的：

```c++
int main(){
    Object *ptr;
	ptr = new Object;
    return 0;
}
```

- `Object *ptr;`代表，指针`ptr`是自动存储的。查看上下文发现是在函数内部，所以`ptr`是栈上创建的。而下面一行语句则指出，这个指针所指向的对象是在堆上面分配的。如果这两行语句出现在一个函数内部，意味着当函数结束时，`ptr`会被销毁，但是它指向的对象不会。因此，如果不对指向的资源进行释放，会造成内存泄漏。因为那时堆上的这个地址的资源会变为不可达。

继续看下面的：

```c++
int main(){
    Object obj;
    Object* ptr = &obj;
    return 0;
}
```

- 这里我们发现，`obj`是自动储存期并且在栈上。`ptr`也是自动储存期，也在栈上。所以这个指针指向的对象也在栈上。所以不对其处理也不会导致泄漏问题。因为都是栈上的资源。
