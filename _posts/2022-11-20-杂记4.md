---
title: C++杂记 - 4
date: 2022-11-20 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true
  
---

# 存储类说明符

这是一个被我忽视了的细节。在官方文档中提到了：

- `auto`或 (C++11 前)无说明符 - **自动**存储期。
  - 这类对象的存储在外围代码块开始时分配，并在结束时解分配。未声明为 `static`、`extern` 或 `thread_local` 的所有局部对象均拥有此存储期。

- `register` - 自动存储期，另提示编译器将此对象置于处理器的寄存器。(弃用) (C++17 前)
- `static` - 静态或线程存储期和内部链接。 
  - 这类对象的存储在程序开始时分配，并在程序结束时解分配。这类对象只存在一个实例。所有在命名空间（包含全局命名空间）作用域声明的对象，加上声明带有 `static` 或 `extern` 的对象均拥有此存储期。有关拥有此存储期的对象的初始化的细节，见[非局部变量](https://zh.cppreference.com/w/cpp/language/initialization#.E9.9D.9E.E5.B1.80.E9.83.A8.E5.8F.98.E9.87.8F)与[静态局部变量](https://zh.cppreference.com/w/cpp/language/storage_duration#.E9.9D.99.E6.80.81.E5.B1.80.E9.83.A8.E5.8F.98.E9.87.8F)。

- `extern `- 静态或线程存储期和外部链接。
- `thread_local `- 线程存储期。 (C++11 起) 
- `mutable` - 不影响存储期或链接。解释见 const/volatile。

`static`, `extern` 和 `thread_local` 不必多说，这里主要关注第一个自动储存期。

## 什么是自动储存期？

我们知道，变量一般存在下面地方。

- 全局变量和静态变量：储存在静态存储区（比如BSS段和数据段）

- 常量：依赖于实现，一般存储在静态储存区的数据段或代码段。

- 局部变量：栈区。储存在动态存储区

- `new`的变量：堆区。储存在动态存储区

 

但是注意，当有如下代码

  ```c++
  int main(){
      int* ptr = new int(5);
      return 0;
  }
  ```

  - `ptr`本身没有加储存类说明符，说明是**自动存储期**。我们查看上下文发现是在局部的变量。所以指针`ptr`自己在栈区。而`new`出来的东西在堆区。也就是栈上的指针指向了堆区的数据。



**自动储存期指的是变量分配在哪是依靠上下文决定的。它并不一定在栈上。**

举例子：

```c++
int main(){
    Object obj; //什么意思？
    return 0;
}
```

- 要回答这个问题，我们首先要理解这个语句是什么意思。这行语句的含义是，使对象`obj`具有自动储存期的性质。所谓自动储存期，意思是这个对象的存储位置取决于其声明所在的上下文。

此时我们看到，这个语句出现在函数内部并且没有其他修饰符，那么它就在栈上创建对象。



**如果这个语句不是在函数内部，而是作为一个类的成员变量，则取决于这个类的对象是如何分配的。**考虑下面的代码：

```c++
class myClass{
    public:
    	Object obj; //它在哪？
};
int main(){
    myClass* ptr = new myClass;
    return 0;
}
```

- 指针`ptr`所指向的对象在堆上分配空间。但是因为`Object obj;`语句的含义是“变量具有自动存储期”。我们查看其上下文，发现包含`ptr->obj`的变量处于堆上。所以，`ptr->obj`也是在堆上创建的。

我们继续看下面的：

```c++
int main(){
    Object *ptr;
	ptr = new Object;
    return 0;
}
```

- `Object *ptr;`代表，指针`ptr`是自动存储的。查看上下文发现是在函数内部，所以`ptr`是栈上创建的。而下面一行语句则指出，这个指针所指向的对象是在堆上面分配的。如果这两行语句出现在一个函数内部，意味着当函数结束时，`ptr`会被销毁，但是它指向的对象不会。因此，如果不对指向的资源进行释放，会造成内存泄漏。因为那时堆上的这个地址的资源会变为不可达。

继续看下面的：

```c++
int main(){
    Object obj;
    Object* ptr = &obj;
    return 0;
}
```

- 这里我们发现，`obj`是自动储存期并且在栈上。`ptr`也是自动储存期，也在栈上。所以这个指针指向的对象也在栈上。所以不对其处理也不会导致泄漏问题。因为都是栈上的资源。



# 可重入函数 和 不可重入函数

- 在实时系统的设计中，经常会出现多个任务调用同一个函数的情况。**如果有一个函数不幸被设计成为这样：不同任务调用这个函数时可能修改其他任务调用这个函数的数据，从而导致不可预料的后果。这样的函数是不安全的函数，也叫不可重入函数。**

- 相反，肯定有一个安全的函数，这个安全的函数又叫可重入函数。那么什么是可重入函数呢？所谓可重入是指一个可以被多个任务调用的过程，任务在调用时不必担心数据是否会出错。

- **一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。**
- 也可这样理解，重入即表示重复进入，首先它意味着这个函数可以被中断，其次意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括 static），这样的函数就是purecode（纯代码）可重入，可以允许有该函数的多个副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。如果确实需要访问全局变量（包括 static），一定要注意实施互斥手段。可重入函数在并行运行环境中非常重要，但是一般要为访问全局变量付出一些性能代价。

- 编写可重入函数时，若使用全局变量，则应通过关中断、信号量（即P、V操作）等手段对其加以保护。



例子：

假设` Exam` 是 `int` 型**全局变量**，函数 `Squre_Exam `返回 `Exam` 平方值。那么如下函数**不具有可重入性**。

```c++
int Exam = 0;
unsigned int example( int para ) 
{ 
    unsigned int temp;
    Exam = para; // （**）
    temp = Square_Exam( );
    return temp;
}
```

此函数若被多个进程调用的话，其结果可能是未知的，因为当（**）语句刚执行完后，另外一个使用本函数的进程可能正好被激活，那么当新激活的进程执行到此函数时，将使 `Exam` 赋与另一个不同的 `para` 值，所以当控制重新回到 `temp = Square_Exam( )` 后，计算出的`temp`很可能不是预想中的结果。此函数应加锁。

```c++
int Exam = 0;
unsigned int example( int para ) 
{
    unsigned int temp;
    [申请信号量操作] //(1)  加锁
    Exam = para;
    temp = Square_Exam( );
    [释放信号量操作] //     解锁 
    return temp;
}
```







## 可重入函数特点：

- 没有静态数据结构
- 不返回指向静态数据的指针
- 所有函数数据由函数的调用者提供
- 使用`auto`变量，或通过全局变量的拷贝来保护全局变量
- **若必须访问全局变量，则利用互斥信号保护**
- **不调用不可重入函数**
- 在unix里面通常都有加上_r后缀的同名可重入函数版本。如果实在没有，不妨在可预见的发生错误的地方尝试加上保护锁同步机制等等

## 不可重入函数特点：

- 函数中使用了静态变量，无论是全局静态变量还是局部静态变量

- 函数返回静态变量
- 函数中调用了不可重入函数
  - 如函数体内调用了`malloc()`或者`free()`函数 或者 `printf()`函数
    - `printf` --------引用全局变量`stdout`
    - `malloc `--------全局内存分配表
    - `free` --------全局内存分配表
- 函数体内调用了其他标准I/O函数
- 函数是singleton中的成员函数，而且使用了不属于线程独立存储的成员变量

## 满足下列条件的函数多数是不可重入（不安全）的：

1. 函数体内使用了静态的数据结构；

2. 函数体内调用了`malloc()` 或者` free() `函数；

3. 函数体内调用了标准 I/O 函数。



## 保证函数的可重入性的方法：

- 在写函数时候尽量使用局部变量（例如寄存器、堆栈中的变量）；
- 对于要使用的全局变量要加以保护（如采取关中断、信号量等互斥方法），这样构成的函数就一定是一个可重入的函数。



## 可重入规则改写不可重入函数：

**把一个不可重入函数变成可重入的唯一方法是用可重入规则来重写它。**

可重入规则：

- **不要使用全局变量。如果必须使用记得用互斥信号量保护**，因为别的代码很可能修改这些变量值
- 在和硬件发生交互的时候，切记执行类似`disinterrupt()`之类的操作，就是关闭硬件中断。

- 完成交互记得打开中断，在有些系列上，这叫做“进入/退出核心”或者用`OS_ENTER_KERNAL/ OS_EXIT_KERNAL`来描述。

- **不能调用任何不可重入的函数。**
- 谨慎使用堆栈。最好先在使用前先`OS_ENTER_KERNAL`。

总之，必须保证中断是安全的



# 委托构造函数

委托构造函数允许在同一个类中一个构造函数调用另外一个构造函数，可以在变量初始化时简化操作。

```c++
class A {
    public:
        A(){}
        A(int a):a_(a){}

        A(int a, int b):a_(a), b_(b) {}  // 好麻烦

        A(int a, int b, int c): a_(a), b_(b), c_(c) {}  // 好麻烦

        int a_;
        int b_;
        int c_;
};

//下面是使用委托构造函数
class mod_A {
    public:
        mod_A(){}
        mod_A(int a): a_(a) {}

        mod_A(int a, int b) : mod_A(a) {  //使用委托构造函数，注意使用后对其他成员不可再使用构造函数初始化列表初始化其他成员。
            b_ = b; 
        }
        mod_A(int a, int b, int c) : mod_A(a, b) { 
            c_ = c; 
        }

        int a_;
        int b_;
        int c_;
};
```



## 注意事项：

- **注意委托构造函数不能具有其他成员初始化表达式，成员初始化列表只能包含一个其它构造函数，不能再包含其它成员变量的初始化，且参数列表必须与构造函数匹配。也就是对其他成员不可使用构造函数初始化列表**。我们不能在初始化列表中既初始化成员，又委托其他构造函数完成构造。
  - 所以如果委托构造函数要给变量赋初值，初始化代码必须放在函数体中。如上面代码所示。

```c++
mod_A(){}
mod_A(int a): a_(a) {}
mod_A(int a, int b) : mod_A(a), b_(b) {} //错误。委托构造函数对其他成员不可使用构造函数初始化列表。
```

- 在构造函数较多的时候，我们可能拥有多个委托构造函数，而一些目标构造函数很可能也是委托构造函数，这样依赖，我们就可能在委托构造函数中形成链状的委托构造关系，形成委托坏（Delegation Cycle）。

- 如果在委托构造函数中使用try，可以捕获目标构造函数中抛出的异常。



# 继承构造函数

继承构造函数可以让派生类直接使用基类的构造函数，如果有一个派生类，我们希望派生类采用和基类一样的构造方式，可以直接使用基类的构造函数，而不是再重新写一遍构造函数

```c++
class A {
    public:
        A(){}
        A(int a): a_(a) {}

        A(int a, int b) : A(a) {  //委托构造
            b_ = b; 
        }
        A(int a, int b, int c) : A(a, b) {  //委托构造
            c_ = c; 
        }

        int a_;
        int b_;
        int c_;
};

class B:public A{
    public:
        B() {}
        B(int a) : A(a) {} // 好麻烦
        B(int a, int b) : A(a, b) {} // 好麻烦
        B(int a, int b, int c) : A(a, b, c) {} // 好麻烦
    	B(int a, int b, int c, int d) : A(a, b, c), d_(d) {} // 注意这不是委托构造，所以自己的成员可以放入初始化列表。
        int d_;
};


//下面使用继承构造
class mod_B:public A{
    public:
        using A::A;
};
```



## 注意事项：

- **继承构造函数无法初始化派生类数据成员，继承构造函数的功能是初始化基类，对于派生类数据成员的初始化则无能为力。解决的办法主要有两个：**
  - 可以通过 =、{} 对非静态成员快速地就地初始化，以减少多个构造函数重复初始化变量的工作，注意初始化列表会覆盖就地初始化操作。
  
  ```c++
  class mod_B:public A{
      public:
          using A::A;
          int _d = 10;
  };
  ```
  
  - 新增派生类构造函数，使用构造函数初始化列表初始化
  
  ```c++
  class mod_B:public A{
      public:
          using A::A;
          mod_B(int a, int b, int c, int d): A(a, b, c), d_(d){} // 注意这不是委托构造，所以自己的成员可以放入初始化列表。
          int d_;
  };
  ```
  
- 构造函数拥有默认值会产生多个构造函数版本，**且继承构造函数无法继承基类构造函数的默认参数**，所以我们在使用有默认参数构造函数的基类时就必须要小心。

```c++
class A
{
public:
    A(int a = 3, double b = 4):m_a(a), m_b(b){}
    void display()
    {
        cout<<m_a<<" "<<m_b<<endl;
    }

private:
    int m_a;
    double m_b;
};

class B:public A
{
    public:
    using A::A;
};
```

那么A中的构造函数会有下面几个版本：

```c++
A() //默认无参构造
A(int) //只输入一个值，第二个值采用默认值
A(int,double) //输入两个值，也就是忽视默认值
A(const A&) //拷贝构造。
```

那么B中对应的继承构造函数将会包含如下几个版本：

```c++
//同上
B()
B(int)
B(int,double)
B(const B&)
```

注意没有`A(double)` 或 `B(double)` 因为不可以第一个有默认值而第二个没有默认值。也就是从第一个有默认值后面的参数都必须有默认值。





- 多继承的情况下，继承构造函数会出现“冲突”的情况，因为多个基类中的部分构造函数可能导致派生类中的继承构造函数的函数名与参数相同，即函数签名。

