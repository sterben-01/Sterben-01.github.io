---
title: C++ 拷贝构造
date: 2022-07-18 15:50:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true

---

# C++ 拷贝构造

### 调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生。
 如果产生了新的对象实例，那调用的就是拷贝构造函数；如果是对已有的对象赋值，调用的是拷贝赋值。

比如

```c++
 P a = P(10); //这是拷贝构造。因为a还不存在。
//------------------------------------------------------
 P a;
 a =  P(10); //这是拷贝赋值。因为a已经存在了
```





### **拷贝构造函数必须以引用的方式传递参数**。这是因为，在值传递的方式传递给一个函数的时候，会调用拷贝构造函数生成函数的实参。如果拷贝构造函数的参数仍然是以值的方式，就会无限循环的调用下去，直到函数的栈溢出。



## 很多种情况都会调用拷贝构造。一般来说有如下几种形式

- 对象作为函数的参数，以值传递的方式传给函数。　
- 对象作为函数的返回值，以值的方式从函数返回
- 使用一个对象给另一个对象**初始化**

```c++
P p1(p2); //使用一个对象给另一个对象初始化
```
```c++
P p1 = p2; //使用一个对象给另一个对象初始化
P p1 = P(10);//使用一个临时对象给另一个对象初始化
P* p1 = new P(10); //指针也不例外 这种声明使用10初始化一个匿名对象，并将新对象的地址赋给p1指针。
```

**这里虽然使用了`=`，但是实际上使用对象p来创建一个新的对象p1。也就是产生了新的对象，所以调用的也是拷贝构造函数。**

这里的第一行和第二行可能会使用复制构造函数直接创建p1，也可能使用复制构造函数生成一个临时对象，然后将临时对象的内容赋给p1，**这取决于具体的实现**





## 举例：

示例代码：

```c++
class Person
{
public:
	Person(){}
	Person(const Person& p)
	{
		cout << "Copy Constructor" << endl;
	}

	Person& operator=(const Person& p)
	{
		cout << "Assign" << endl;
		return *this;
	}

private:
	int age;
	string name;
};

void f(Person p)
{
	return;
}

Person f1()
{
	Person p;
	return p;
}

int main()
{
	Person p;
	Person p1 = p;    // 1
	Person p2;
	p2 = p;           // 2
	f(p2);            // 3

	p2 = f1();        // 4

	Person p3 = f1(); // 5

	getchar();
	return 0;
}
```

下面是输出

```c++
"Copy Constructor" 	//1
    
"Assign"			//2
    
"Copy Constructor"	//3
    
"Copy Constructor" 	//4
"Assign"
    
"Copy Constructor" 	//5
```

分析如下：

1. 这是虽然使用了"="，但是实际上使用对象p来创建一个新的对象p1。也就是产生了新的对象，所以调用的是拷贝构造函数。
2. 首先声明一个对象p2，然后使用赋值运算符"="，将p的值复制给p2，显然是调用赋值运算符，为一个已经存在的对象赋值 。
3. 以值传递的方式将对象p2传入函数f内，调用拷贝构造函数构建一个函数f可用的实参。
4. 这条语句拷贝构造函数和赋值运算符都调用了。函数f1以值的方式返回一个Person对象，在返回时会调用拷贝构造函数创建一个临时对象`tmp`作为返回值；返回后调用赋值运算符将临时对象`tmp`赋值给p2.
5. 按照4的解释，应该是首先调用拷贝构造函数创建临时对象；然后再调用拷贝构造函数使用刚才创建的临时对象创建新的对象p3，也就是会调用两次拷贝构造函数。不过，编译器也没有那么傻，应该是直接调用拷贝构造函数使用返回值创建了对象p3。

## 关于拷贝赋值和拷贝构造在继承中的注意事项

继承中，子类的拷贝赋值和拷贝构造不会将父类的成员变量复制。为了防止遗漏，我们一般在子类直接调用父类的拷贝赋值或者拷贝构造。但是要注意语法和一些小细节

```c++
class A {
    public:
        A(){}
        A(int a) :m_a(a) {}
        virtual~A(){}
        A& operator=(const A& rhs) {
            m_a = rhs.m_a;
            return *this;
        }
	int m_a;
};

class B : public A{
    public:
        B(){}
        B(int x):m_b(x){}
        B(int no, int x):A(no),m_b(x){} //这里用到了子类调用父类构造
        ~B(){} 
        
        B& operator=(const B& rhs) {
            A::operator=(rhs); //这里是函数调用。
            /*
            我们函数调用可以不接受返回值。operator=的返回值的目的是返回一个自己用来进行下一步操作。是为了满足链式调用。当然也可以啥也不返回。
            所以隔壁的拷贝构造就没返回值。
            但是我们子类调用父类的拷贝赋值仅仅是把子类的父类部分调用父类的拷贝赋值来进行一个赋值。
            这里的例子就是子类的父类部分m_a使用父类的拷贝赋值给copy一遍。
            然后我们直接调用完了父类的拷贝赋值后，再自己赋值子类部分。
            时刻谨记 b1 = b2 就是b1.operator=(b2);
            */
            m_b = rhs.m_b;
            return *this;

        }
        int m_b;
};

int main(){
    B b(5,8);
    cout << b.m_a << endl;
    
    return 0;
}
```

我们这里没有使用带指针对象的拷贝构造和拷贝赋值做为例子。

但是我们想要深拷贝的时候，拷贝赋值要注意先检测自我赋值。

其次要先删除掉调用方自己的对应内容，然后新开辟内存，然后复制数据。



## 移动赋值和移动构造记得移动后需要把原来数据置空。尤其是带有指针类型的

但是不能删除。因为是转移所有权。也就是浅拷贝。删除了东西就没了。如果不置空的话会有两个问题。第一是可能会被误用。其次是如果是把一个临时对象移动构造或者是移动赋值给一个对象，临时对象的那一行过后临时对象会被析构。也就是指针指向的数据会被释放。所以你对象拿到的临时对象的对应指针数据也会被清除。

所以在有指针的时候需要格外注意。而且对应的析构函数也要进行判空，不然会多次删除。

移动构造在使用vector的情况下，一般是vector扩容的时候重新分配内存的时候使用，如果自定义类型有移动构造就会用移动构造。没有就是拷贝构造。
