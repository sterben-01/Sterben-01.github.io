---
title: C++ 拷贝构造
date: 2022-07-18 15:50:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true

---

# C++ 拷贝构造

### 调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生。
 如果产生了新的对象实例，那调用的就是拷贝构造函数；如果是对已有的对象赋值，调用的是拷贝赋值。

比如

```c++
 P a = P(10); //这是拷贝构造。因为a还不存在。
//------------------------------------------------------
 P a;
 a =  P(10); //这是拷贝赋值。因为a已经存在了
```





### **拷贝构造函数必须以引用的方式传递参数**。这是因为，在值传递的方式传递给一个函数的时候，会调用拷贝构造函数生成函数的实参。如果拷贝构造函数的参数仍然是以值的方式，就会无限循环的调用下去，直到函数的栈溢出。



拷贝构造有严格的函数签名限制：

> 类 `T` 的复制构造函数是首个形参是 T&、const T&、volatile T& 或 const volatile T&，而且要么没有其他形参，要么剩余形参均有默认值的非模板构造函数



## 很多种情况都会调用拷贝构造。一般来说有如下几种形式

- 对象作为函数的参数，以值传递的方式传给函数。　
- 对象作为函数的返回值，以值的方式从函数返回
- 使用一个对象给另一个对象**初始化**

```c++
P p1(p2); //使用一个对象给另一个对象初始化
```
```c++
P p1 = p2; //使用一个对象给另一个对象初始化
P p1 = P(10);//使用一个临时对象给另一个对象初始化
P* p1 = new P(10); //指针也不例外 这种声明使用10初始化一个匿名对象，并将新对象的地址赋给p1指针。
```

**这里虽然使用了`=`，但是实际上使用对象p来创建一个新的对象p1。也就是产生了新的对象，所以调用的也是拷贝构造函数。**

这里的第一行和第二行可能会使用复制构造函数直接创建p1，也可能使用复制构造函数生成一个临时对象，然后将临时对象的内容赋给p1，**这取决于具体的实现**





## 举例：

示例代码：

```c++
class Person
{
public:
	Person(){}
	Person(const Person& p)
	{
		cout << "Copy Constructor" << endl;
	}

	Person& operator=(const Person& p)
	{
		cout << "Assign" << endl;
		return *this;
	}

private:
	int age;
	string name;
};

void f(Person p)
{
	return;
}

Person f1()
{
	Person p;
	return p;
}

int main()
{
	Person p;
	Person p1 = p;    // 1
	Person p2;
	p2 = p;           // 2
	f(p2);            // 3

	p2 = f1();        // 4

	Person p3 = f1(); // 5

	getchar();
	return 0;
}
```

下面是输出

```c++
"Copy Constructor" 	//1
    
"Assign"			//2
    
"Copy Constructor"	//3
    
"Copy Constructor" 	//4
"Assign"
    
"Copy Constructor" 	//5
```

分析如下：

1. 这是虽然使用了"="，但是实际上使用对象p来创建一个新的对象p1。也就是产生了新的对象，所以调用的是拷贝构造函数。
2. 首先声明一个对象p2，然后使用赋值运算符"="，将p的值复制给p2，显然是调用赋值运算符，为一个已经存在的对象赋值 。
3. 以值传递的方式将对象p2传入函数f内，调用拷贝构造函数构建一个函数f可用的实参。
4. 这条语句拷贝构造函数和赋值运算符都调用了。函数f1以值的方式返回一个Person对象，在返回时会调用拷贝构造函数创建一个临时对象`tmp`作为返回值；返回后调用赋值运算符将临时对象`tmp`赋值给p2.
5. 按照4的解释，应该是首先调用拷贝构造函数创建临时对象；然后再调用拷贝构造函数使用刚才创建的临时对象创建新的对象p3，也就是会调用两次拷贝构造函数。不过，编译器也没有那么傻，应该是直接调用拷贝构造函数使用返回值创建了对象p3。

## 关于拷贝赋值和拷贝构造在继承中的注意事项

继承中，子类的拷贝赋值和拷贝构造不会将父类的成员变量复制。为了防止遗漏，我们一般在子类直接调用父类的拷贝赋值或者拷贝构造。但是要注意语法和一些小细节

```c++
class A {
    public:
        A(){}
        A(int a) :m_a(a) {}
        virtual~A(){}
        A& operator=(const A& rhs) {
            m_a = rhs.m_a;
            return *this;
        }
	int m_a;
};

class B : public A{
    public:
        B(){}
        B(int x):m_b(x){}
        B(int no, int x):A(no),m_b(x){} //这里用到了子类调用父类构造
        ~B(){} 
        
        B& operator=(const B& rhs) {
            this->A::operator=(rhs); //这里是函数调用。
            /*
            我们函数调用可以不接受返回值。operator=的返回值的目的是返回一个自己用来进行下一步操作。是为了满足链式调用。当然也可以啥也不返回。
            所以隔壁的拷贝构造就没返回值。
            但是我们子类调用父类的拷贝赋值仅仅是把子类的父类部分调用父类的拷贝赋值来进行一个赋值。
            这里的例子就是子类的父类部分m_a使用父类的拷贝赋值给copy一遍。
            然后我们直接调用完了父类的拷贝赋值后，再自己赋值子类部分。
            时刻谨记 b1 = b2 就是b1.operator=(b2);
            */
            m_b = rhs.m_b;
            return *this;

        }
        int m_b;
};

int main(){
    B b(5,8);
    cout << b.m_a << endl;
    
    return 0;
}
```

我们这里没有使用带指针对象的拷贝构造和拷贝赋值做为例子。

但是我们想要深拷贝的时候，拷贝赋值要注意先检测自我赋值。

其次要先删除掉调用方自己的对应内容，然后新开辟内存，然后复制数据。



## 移动赋值和移动构造记得移动后需要把原来数据置空。尤其是带有指针类型的

但是不能删除。因为是转移所有权。也就是浅拷贝。删除了东西就没了。如果不置空的话会有两个问题。第一是可能会被误用。其次是如果是把一个临时对象移动构造或者是移动赋值给一个对象，临时对象的那一行过后临时对象会被析构。也就是指针指向的数据会被释放。所以你对象拿到的临时对象的对应指针数据也会被清除。

所以在有指针的时候需要格外注意。而且对应的析构函数也要进行判空，不然会多次删除。

移动构造在使用vector的情况下，一般是vector扩容的时候重新分配内存的时候使用，如果自定义类型有移动构造就会用移动构造。没有就是拷贝构造。





# 拷贝构造 拷贝赋值 移动构造 移动赋值的例子。此处拷贝为深拷贝。

```c++
class myobj{
    public:
        myobj(int x):val(new int(x)){}
        int& getval(){
            return *val;
        }

        myobj(const myobj& obj){ //拷贝构造 深拷贝
            val = new int(*obj.val); //以传入参数的值新开辟数据空间
        }
        myobj& operator=(const myobj & rhs){ //拷贝赋值 深拷贝
            if(this == &rhs){ //检测自我赋值
                return *this;
            }
            delete this->val; //释放自身此时的资源。
            val = new int(*rhs.val); //以传入参数的值新开辟数据空间
            return *this;
        }

        myobj(myobj&& obj){ //移动构造
            cout <<"mv" << endl;
            val = obj.val;     //浅拷贝指针
            obj.val = nullptr; //因为是所有权转移，传入对象的数据指针必须被置空
        }
        myobj& operator=(myobj&& rhs){ //移动赋值
            cout <<"mv=" << endl;
            if(this == &rhs){ //检测自我赋值
                return *this;
            }
            if(this->val != nullptr){ //先释放自身此时资源
                delete val;
            }
            val = rhs.val; //浅拷贝指针
            rhs.val = nullptr; //因为是所有权转移，传入对象的数据指针必须被置空
            return *this;

        }
        ~myobj(){
            delete val;
            val = nullptr;
        }


        int* val;
        
};

int main(){
    myobj a(5);
    myobj b(10);
    cout << a.getval() << endl;
    myobj c(a);
    cout << c.getval() << endl;
    myobj d = c;
    cout << d.getval() << endl;
    d = b;
    cout << d.getval() << endl;
    myobj e = move(a);
    cout << e.getval() << endl;
    d = move(b);
    cout << d.getval() << endl;
    return 0;
}
```

# 移动构造函数的设计

- 参数：
  - 参数为`&&`类型，因为是移动操作
  - 参数不可设置为`const`，因为需要改变入参
- 在移动构造函数后添加`noexcept`关键字，确保移动构造函数不会抛出异常。尤其是针对可能会有`vector`容器储存该类对象时。
- 内容：
  - 在参数初始化列表中将参数的资源移动给自己（先执行）。
    - 把入参的资源移动给自己。
  - 然后在函数体内处理入参所拥有的资源：
    - 一般来说，对象应该置为0或默认值。
    - **指针必须置空避免不小心释放不应释放的资源。因为被移动过的对象在生命周期结束的时候依旧会调用析构。如果不给原对象指针置空，则新对象接管资源后资源也会被无意置空！**
    - 这样之后就达到了资源移动的目的（后执行）
- 注意要点：
  - **移动构造函数不分配任何内存，只是简单的资源移动而已**
  - **移动构造会构造对象。所以如果使用一个对象通过移动构造来构造一个新对象。我们依旧会有两个对象。只不过只有一个对象拥有有效值而已。最后析构函数还是会被执行两次。因为虽然内容（资源）移动走了，但是壳子（对象本身）还在。所以析构函数依旧会被调用。** （杂记中搜索关键词“壳子”）



# 移动赋值的设计

- 参数：
  - 参数为`&&`类型，因为是移动操作
  - 参数不可设置为`const`，因为需要改变
- 在函数后添加`noexcept`关键字，确保移动赋值运算符函数不会抛出异常。原因同上
- 与拷贝赋值运算符一样，函数返回自身引用
- 内容：
  - **在函数执行前，应该检测自我赋值的情况**
  - 先释放自身资源，再拷贝参数`rhs`的资源，最后再将`rhs`置为空。原因同上

- 赋值运算符的重载调用的时候一定要把`this`先安全的析构掉（释放自身资源），绝不是构造。另外一个十分重要的点在于虚表指针的初始化时机，C++没规定虚表指针的初始化是什么时候，但是绝对不可能发生在赋值时。

https://blog.csdn.net/qq_41453285/article/details/104419356



通常来讲，我们可以给成员函数设计一个移动版本一个拷贝版本。也就是一个入参类型为`const&`，另一个为`&&`。`push_back`就是这样设计的

# 注意编译器并不是在任何场合都会生成默认移动构造函数或默认移动赋值

- 针对移动构造和移动赋值，有更严格的要求需要满足，编译期才会为我们生成默认移动构造或默认移动赋值：
  - 编译器只会针对满足如下情况的类生成移动构造和移动赋值
    - 没有用户定义的移动构造/移动赋值
    - 没有用户声明的拷贝构造/拷贝赋值
    - 没有用户声明的析构函数
- 所以会有0/3/5法则。

# 特殊成员函数默认生成的条件

- 六种特殊的成员函数可以声明为类似 `X() = default` 让编译器自动生成， 或者声明为 `X() = delete` 阻止编译器自动生成相应的函数定义。
- `X::X()` 默认构造函数 如果没有声明为 `=delete`,编译器将会自动生成定义。但是如果用户声明了其他形式的构造函数如`X(int x)` , 编译器将不会自动生成，除非用户手动定义。
- `X(const X&)` 和 `X& operator=(const X&)` 拷贝构造和拷贝赋值如果没有用户指定，在需要的时候编译器会自动生成，内容为对成员的值拷贝，如果是指针成员将是“浅复制”
- **对除默认构造函数之外的特殊成员函数的声明，哪怕是`=default`或`delete`，将会阻止编译器生成默认的移动构造和移动赋值。这将会导致该类无法使用移动语义**
  - 针对移动构造和移动赋值，有更严格的要求需要满足，编译器才会为我们生成默认移动构造或默认移动赋值：
    - 没有用户定义的移动构造/移动赋值
    - 没有用户声明的拷贝构造/拷贝赋值
    - 没有用户声明的析构函数
- **如果只声明了移动构造或移动赋值，则编译器隐式生成的默认拷贝构造和默认拷贝赋值将会声明为`delete`, 也就是该类是仅移动的。**

# 0/3/5 法则

## 3之法则

如果某个类需要用户定义的**析构函数、用户定义的拷贝构造函数或用户定义的拷贝赋值运算符**，那么它几乎肯定需要全部三者。

原因：

- 通常，若一个类需要析构函数，则代表其合成的析构函数不足以释放类所拥有的资源，其中最典型的就是指针成员（析构时需要手动去释放指针指向的内存）。
- 所以，若存在自定义（且正确）的析构函数，但使用合成的拷贝构造函数，那么拷贝过去的也只是指针，此时两个对象的指针变量同时指向同一块内存，指向同一块内存的后果很有可能是在两个对象中的析构函数中先后被释放两次。所以需要额外的拷贝控制函数去控制相应资源的拷贝。
- 所以这类例子的共同点就是：一个对象拥有额外的资源（指针指向的内存），但另一个对象使用合成的拷贝构造函数也同时拥有这块资源。当一方对象被销毁后，析构函数释放了资源，这时另一个对象便失去了这块资源（但程序员还不知道）。

## 5之法则

因为用户定义的析构函数、拷贝构造函数或拷贝赋值运算符的存在会阻止移动构造函数和移动赋值运算符的隐式定义，所以任何想要移动语义的类必须声明全部五个特殊成员函数。

## 0之法则

如果不需要手动定义， 就不要定义，一切让它默认。



# 构造函数中使用move移动参数的陷阱

## 不要对入参为常量左值引用的对象使用move。它会被拷贝而不是移动

```c++
class myobj{
    public:
        myobj(int x):val(new int(x)){ //构造
            cout <<"const" << endl;
        }
        myobj(const myobj& obj){ //拷贝构造
            cout <<"copy const" << endl;
            val = new int(*obj.val);
        }
        myobj& operator=(const myobj & rhs){ //拷贝赋值
            cout <<"copy= const" << endl;
            if(this == &rhs){
                return *this;
            }
            delete this->val;
            val = new int(*rhs.val);
            return *this;
        }

        myobj(myobj&& obj){ //移动构造
            cout <<"mv" << endl;
            val = obj.val;
            obj.val = new int(3939);
        }
        myobj& operator=(myobj&& rhs){ //移动赋值
            cout <<"mv=" << endl;
            if(this == &rhs){
                return *this;
            }
            if(this->val != nullptr){
                delete val;
            }
            val = rhs.val;
            rhs.val = nullptr; 
            return *this;

        }
        ~myobj(){
            cout <<"dest" << endl;
            delete val;
            val = nullptr;
        }

        int* val;
        
};

```

上面是一个写了所有特殊成员函数的类。我们继续看

- 第一个版本。我们值传递。

```c++
class testobj{
    public:
    myobj inner;
    testobj(myobj obj):inner(move(obj)){} //版本1 值传递
};



int main(){
    myobj temp(20);
    testobj out(temp);
    cout << *temp.val << endl; //输出什么？
    return 0;
}
```

```c++
const //构造temp对象
copy const //值传递导致的拷贝至构造函数中。
mv //构造函数中使用move把拷贝的对象转换为右值然后移动构造的inner
dest//拷贝进来的参数析构
20
dest //testobj里的myobj析构
dest//外部myobj析构
```

**这个20会正常输出。外部的temp对象是拷贝传值。被move变成右值的是值传递导致的拷贝的那个对象。**



- 第二个版本。左值引用传递。
  - 这个版本有个毛病。输入右值不行。


```c++
class testobj{
    public:
    myobj inner;
    testobj(myobj& obj):inner(move(obj)){} //左值引用
};



int main(){
    myobj temp(20);
    testobj out(temp);
    //testobj out(myobj(20)); 不行。
    cout << *temp.val << endl;
    return 0;
}
```



```c++
const //temp对象构建
mv //引用传递不发生拷贝，这里的move变成右值的是temp对象本身。所以触发移动构造testobj内的inner
3939 //外部对象已经被移动。输出3939
dest
dest
```

这里我们发现由于是左值引用传递，所以temp对象发生了移动。



- **第三个版本。常量左值引用传递。**

```c++
class testobj{
    public:
    myobj inner;
    testobj(const myobj& obj):inner(move(obj)){} //常量左值引用
};



int main(){
    myobj temp(20);
    testobj out(temp);
    cout << *temp.val << endl;
    return 0;
}
```



```c++
const //temp对象构建
copy const //引用传递不发生拷贝。这里的拷贝是从构造函数入参中拷贝至myobj的inner对象。
20//外部不移动
dest
dest
```

- 为什么会拷贝？
  - 常量左值引用既然是常量就不可能对该参数修改。这是简单的理解。
  - 深层次的理解是这样的。我们`move`会把一个左值变成右值。我们`obj`传进来的时候是`const &`, 如果`move`就会变成`const &&`。
  - 这时候有一个问题。我们没有`const&&`开头的函数。我们也知道`const&`可以接受一切参数包括`const&&`。（杂记）**所以这时候会去匹配`const&`的拷贝构造。所以最后会发生拷贝。**
  - `const&&`函数毫无意义。首先移动语义在有意义的时候一定要保证把被移动对象和资源进行分离。加了`const`无法对参数进行修改。其次，入参为右值的时候我们有`&&`接受。常量右值的时候会被`const&`接受。所以`const&&`没有意义。
  
  https://www.nextptr.com/tutorial/ta1211389378/beware-of-using-stdmove-on-a-const-lvalue





- 第四个版本 右值引用传递。
  - 这个版本也有毛病。左值不行。

```c++
class testobj{
    public:
    myobj inner;
    testobj(myobj&& obj):inner(move(obj)){} //右值引用
};



int main(){
    myobj temp(20);
    testobj out(move(temp)); //move换成右值
    cout << *temp.val << endl;
    return 0;
}
```



```c++
const //构造temp
mv //引用传递不拷贝。这个move是把temp对象转换为右值后触发拷贝构造
3939//temp已被移动。
dest
dest
```

这里我们发现结果和左值引用是一致的。

**那么如果我们直接传入临时对象会发生什么呢？**

```c++
testobj out(myobj(10));


const //构造临时对象。临时对象必须得有啊不然传的是啥？
mv //move把临时对象换成右值，触发移动构造。
dest
dest

```



## 构造函数中 想要触发蕴含的某个其他对象的移动构造，则必须使用move或forward

我们延续上面的例子。

```c++
class testobj{
    public:
    myobj inner;
    //testobj(myobj&& obj):inner(move(obj)){}
    testobj(myobj&& obj):inner((obj)){} //我们这里不使用move
};

```

我们发现，我们这里使用了`move`。如果不用`move`会发生什么呢？

```c++
testobj our(myobj(10));
const //构造临时对象
copy const //哇哦，发生了拷贝。
dest
dest
```

为什么会拷贝？我们不是传入了临时对象吗？

**我们一定知道：具名的右值引用是左值。**

```c++
void func(myobj&& rhs){
    //这里rhs是具名右值引用。是左值。所以如果这时候有函数接受左值或右值引用形式的rhs，则会匹配至左值
}
```

**这也是为什么存在完美转发。这就是另一个要点！在构造函数中，如果想要显式对某一个对象进行移动，仍需要使用`move`**

如果我们这里不使用`move`，则此时右值引用接住的临时对象会变为具名对象，会变成左值。传入后就会匹配拷贝构造。

为了正确的传递其右值特性，或强制转换为右值，就需要使用`forward`或`move`。

所以我们可以这样使用`move`

```c++
class testobj{
    public:
    myobj inner;
    testobj(myobj&& obj):inner(move(obj)){}//使用move
};

```

或使用`forward`

```c++
class testobj{
    public:
    myobj inner;
    testobj(myobj&& obj):inner(forward<myobj>(obj)){} //使用forward
};
```



更深入的可以看看[视频](https://www.youtube.com/watch?v=PNRju6_yn3o&t=182s)
