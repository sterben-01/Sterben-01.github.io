---
title: c++并发编程实战-笔记
date: 2022-09-05 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true
  

---

# 第二章

### `std::thread`的析构函数在线程对象没有调用join或detach的时候会调用`std::terminate()`。

如果一个线程我们没有调用`join`或`detach`，也就是说并没有分离出去或阻塞直至新线程执行完毕并回收资源，（也就是`joinable() == true`)。那么当这个线程被析构的时候，`std::thread`的析构函数会调用`std::terminate()`。这是非常不好的行为。因为是异常！

- 有四种情况在调用`thread`析构函数的时候是正常销毁：

  - 被默认构造
    - 默认构造的线程对象不认为是激活的线程对象

  - 被移动
  - 已调用`join()`
  - 已调用 `detach()`

### 注意在将仿函数（函数对象）作为参数传入`thread`对象的时候，避免语法歧义。

```c++
class obj{
    //其他东西
};

int main(){
    thread mythread(obj()); //错误
    mythread.join();
    
    thread mythread1((obj())); //可以
    mythread1.join();
    
    thread mythread2{obj()}; //可以
    mythread2.join();
    return 0;
}
```

## 传参的时候需要使用引用就需要用`std::ref/cref`。因为默认一律按照拷贝/移动传值。

- 一个实参从主线程传递到子线程的线程函数中，**需要经过两次传递**。**第1次发生在`std::thread`构造时，此次参数按值并以副本形式被保存在`thread`对象内部**。**第2次发生在向线程函数传递时**，此次传递是由子线程发起，并将之前`std::thread`内部保存的副本**以右值的形式(std::move())传入线程函数**中的。
- 当我们使用了`ref`去完成引用传参的时候，其实我们会先创建一个`std::ref`的临时对象，这里保存着我们要传入的那个值的引用。然后这个`std::ref`再以副本的形式保存在`thread`对象中。随后这个副本被`move`到线程函数，由于`std::ref`重载了`operator T&()`,因此会隐式转换为对应的类型。因此看起来就像是真的按照引用个传递进来了一样。
  - 此处参考：https://en.cppreference.com/w/cpp/thread/thread/thread

- **如果线程函数的形参为T、const T&或T&&类型时**，std::thread的构造函数可以接受左值或右值实参。因为不管是左值还是右值，在std::thread中均是以副本形式被保存，并在第2次向线程函数传参时以右值方式传入，而以上三种形参均可接受右值。

- **而如果线程函数的形参为T&时**，**不管是左值还是右值的T类型实参，都是无法直接经std::thread传递给形参为T&的线程函数**，因为该实参数的副本会被std::move成右值并传递线程函数，但T&无法接受右值类型。**因此，需要以std::ref形式传入**。

- 当向线程函数传参时，可能发生隐式类型转换，这种转换是在子线程中进行的。需要注意，由于隐式转换会构造临时对象，并将该对象（是个右值）传入线程函数，因此线程函数的形参应该是可接受右值类型的T、const T&或T&&类型，但不能是T&类型。此外，如果源类型是指针或引用类型时，还要防止可能发生悬空指针和悬空引用的现象。

- 因为thread函数使用了完美转发，所以在某些只支持移动的参数中，必须显示使用move来转移所有权。比如智能指针。（异步操作API也一样）

- 参考资料：https://www.cnblogs.com/5iedu/p/11633683.html




## 传递成员函数做为线程执行函数注意语法

需要传入成员函数指针。语法参见杂记2（显式指定作用域并取地址）。并且要传入类对象地址做为类成员函数的隐藏参数- this指针做为第二个参数。

```c++
class obj{
    public:
    void execute(){
        cout << "start" << endl;
    }
};



int main(){
    obj classobj;
    thread mythread(&obj::execute, &classobj); //需要传入成员函数指针。语法参见杂记2（显式指定作用域并取地址）。并且要传入类对象地址做为类成员函数的隐藏参数- this指针。
   
    thread mythread(&obj::execute, ref(classobj)); //引用
    
    thread mythread(&obj::execute, classobj); //对象
    mythread.join();

    return 0;
}
```

**此处第二个参数传递引用，指针或者是对象本身都可以。具体情况需要具体分析。比如当禁用了X类的拷贝构造的时候，第三种按值传递就不可以。因为是拷贝。 最好是传递指针。因为类成员函数的第一个参数是this指针。所以thread的第二个参数应该最好是这个类对象的指针。 还有，如果按照值传递，会变成副本。可能会导致原对象被销毁。**



## 线程对象不可以被复制。但是可以被移动

```c++
void some_function();
void some_other_function();
std::thread t1(some_function); // 1
std::thread t2=std::move(t1); // 2
t1=std::thread(some_other_function); // 3
std::thread t3; // 4
t3=std::move(t2); // 5
t1=std::move(t3); // 6 赋值操作将使程序崩溃
```

并发编程P32

前面几个都没问题。包括t1。因为在给t1赋值前，其所有权已经转移至t2。此时t1就空了。

- 赋值给一个已经有关联线程的std::thread，系统直接调用 std::terminate() 终止程序继续运行。

- **不能通过赋新值给 std::thread 对象的方式来"丢弃"一个线程。**
- 如果这个容器是移动敏感的(比如，标准中的 `std::vector<>` )，那么移动操作同样适用于这些容器。

## 小心局部变量导致的悬空引用

比如我们有这样一个例子：

```c++
void func2(int& x){
    while(true){
        cout << x << endl;
        Sleep(1000);
    }
}
void func1(){
    int x = 10;
    thread th2(func2, ref(x)); //按照引用传递
    th2.detach();
    Sleep(1000);
    cout <<"thread 1 finished" << endl;
}



int main(){
    thread th1(func1);
    th1.join();
    Sleep(10000); //一定要sleep
}
```

- 在这个例子中，输出了两次`x`后，输出`thread 1 finished`。这时候马上会有`segmentation fault`。因为这时候`x`已经被销毁因为线程1已经结束。所以这时候`func2`引用的`x`就是悬空引用。

## 避免应用被抛出的异常所终止。通常，在无异常的情况下使用join()时，需要在异常处理过程中调用join()，从而避免生命周期的问题。最好使用RAII

### 使用RAII包装线程对象避免在某些可能抛出异常的函数中忘记`join`或`detach`线程对象

一个简单的线程对象包装类

```c++
class thread_guard{
    thread& t; //持有一个线程对象的引用
    public:
        explicit thread_guard (thread& rhs):t(rhs){}; //构造函数要explicit避免隐式类型转换

        ~thread_guard(){
            if(t.joinable()){ //析构函数中如果线程是joinable的
                cout << "析构" << endl;
                t.join();
            }
        }
        thread_guard(const thread&) = delete; //禁用拷贝构造和拷贝赋值
        thread_guard& operator=(const thread&) = delete;

};

int main(){
    thread my_thread(func);

    thread_guard my_guard(my_thread); //使用RAII对象管理线程对象
    Sleep(5000);

    cout<<"abc"<<endl;
    //安全join。
    return 0;
}
```



## 在给thread调用的线程函数传递参数的时候，注意参数是否是不可拷贝的

```c++
void threadfunc(mutex &mylock){ //注意必须传引用
    Sleep(1000);
    mylock.unlock();
}
void testfunc(){
    mylock.lock();
    thread th(threadfunc, ref(mylock)); //注意必须传引用
    mylock.lock();
    mylock.unlock();
    th.join();

}
```

因为`mutex`是不可拷贝的。所以必须引用传参。

 # 第三章

- 尽可能不要使用原始锁，而使用`lock_guard`。因为使用原始锁意味着必须在函数的每一个出口都手动解锁。
- **一个指针或引用，也会让这种保护形同虚设。切勿将受保护数据的指针或引用传递到互斥锁作用域之外。因为指针或引用可以在锁的作用域外面直接修改数据。锁是管不到那些的。所以切勿将受保护数据的指针或引用传递到互斥锁作用域之外，无论 是函数返回值，还是存储在外部可见内存，亦或是以参数的形式传递到用户提供的函数中去。**

一个例子：

```c++
class list_wrapper{
    list<int> my_list;
    mutex m;

    void add_to_list(int x){
        lock_guard<mutex> lcg(m);
        my_list.push_front(x);
    }

    list<int>* get_list(){
        return &my_list;
    }
};
```

如上面所示，我们有一个函数会返回一个指向受保护数据（`my_list`）的指针。然而有可能有别人通过这个指针直接修改我们的`my_list`。这样做就完全绕过了我们的函数`add_to_list`所添加的锁的保护。

- 避免死锁
  - 方式之一就是让两个互斥量总以相同的顺序上锁。不要一个函数先锁A再锁B，另一个先锁B再锁A。
  - 我们也可以使用`std::lock`或`std::scoped_lock`(c++17起)来同时上锁多个互斥量。（由于设计的原因，不会发生死锁。因为一旦一个锁报异常就会把另一个锁也解锁 -- 要么两个都锁，要么一个都不锁。）同时，我们可以用`lock_guard` 的可选参数`std::adopt_lock`来接管已经上锁了的互斥量。
  - 避免死锁的进阶指导：
    - 避免嵌套锁。
    - 避免在持有锁时调用外部代码。
    - 使用固定顺序获取锁。
    - 使用层次锁结构。当代码试图对互斥量上锁，而低层已持有该层锁时，不允许锁定。因此锁的顺序只能先锁层级高的锁再锁层级低的锁。
- `unique_lock`比`lock_guard`更灵活，但是成本会更高。
- 一般情况下，尽可能将持有锁的时间缩减到最小。
- 单例模式也可以使用`call_once`来解决线程安全问题。
- 可以使用读写锁来减少一定场合下普通锁的开销。c中可以使用`pthread_rwlock_t`，c++可以使用`shared_lock`(c++17起）/`shared_mutex`（c++14起）
  - 用 `std::unique_lock` 与 `std::lock_guard` 管理排他性锁定。(写锁)
  - 用 `std::shared_lock` 管理共享锁定。（读锁）

# 第四章

- 同步操作可使用条件变量。此处不赘述用法。
- 剩下的都在杂记3.





# thread源码解析

```c++

// 管理线程的类
class thread {
public:
	class id;                   // 内部ID类
	typedef void *native_handle_type;
 
	thread() _NOEXCEPT {	    // 构造函数，专门为空线程设计。这就是为什么默认构造的线程对象并不是有效的
		_Thr_set_null(_Thr);    // 宏定义，原型为：#define _Thr_set_null(thr) (thr._Id = 0)
	}
 
	template<class _Fn, class... _Args>
    explicit thread(_Fn&& _Fx, _Args&&... _Ax) {	// 带参模板构造函数_Fx(_Ax...)
		_Launch(&_Thr, _STD bind(_Decay_copy(_STD forward<_Fn>(_Fx)), _Decay_copy(_STD forward<_Args>(_Ax))...));
        //一堆乱七八糟连带着完美转发和退化的。你看到copy了。所以说了thread是一种必拷贝传值的。引用的话得用ref包一下。
    }
 
	~thread() _NOEXCEPT {	    // 析构函数
		if (joinable())         // 如果析构线程对象的时候，线程依旧是可结合的（没有调用join或detach）的话会调用terminate
			_XSTD terminate();  // terminate会调用abort()来终止程序
	}
 
	thread(thread&& _Other) _NOEXCEPT : _Thr(_Other._Thr) {	    // 拷贝构造函数，调用move
		_Thr_set_null(_Other._Thr);
	}
 
	thread& operator=(thread&& _Other) _NOEXCEPT {	// 赋值函数，调用move
		return (_Move_thread(_Other));
	}
 
	thread(const thread&) = delete;                 // 禁用 拷贝构造函数
	thread& operator=(const thread&) = delete;      // 禁用 赋值函数
 
	void swap(thread& _Other) _NOEXCEPT {	        // 交换两线程
		_STD swap(_Thr, _Other._Thr);
	}
 
	bool joinable() const _NOEXCEPT {	            // 若线程可结合程，返回 true；否则，返回flase
		return (!_Thr_is_null(_Thr));               // 宏定义，原型为：#define _Thr_is_null(thr) (thr._Id == 0)
	}
 
	void join();                                    // 线程结合，阻塞的
 
	void detach() {	                                // 线程分离
		if (!joinable())                            // 若线程是不可结合的，则异常
			_Throw_Cpp_error(_INVALID_ARGUMENT);
		_Thrd_detachX(_Thr);					//detach的核心
		_Thr_set_null(_Thr);					//设置线程id为0
	}
 
	id get_id() const _NOEXCEPT;                    // 获取线程唯一 id
 
	static unsigned int hardware_concurrency() _NOEXCEPT {	    // 返回硬件线程上下文数量
		return (::Concurrency::details::_GetConcurrency());
	}
 
	native_handle_type native_handle() {	        // 以 void* 形式返回线程的 Win32 句柄
		return (_Thr._Hnd);
	}
 
private:
	thread& _Move_thread(thread& _Other) {	        // move from _Other
		if (joinable())
			_XSTD terminate();
		_Thr = _Other._Thr;
		_Thr_set_null(_Other._Thr);
		return (*this);
	}
 
	_Thrd_t _Thr;            // 私有成员变量，_Thrd_t是一个结构体
};

```



里面的`_Thrd_t`结构体长这样：

```c++
_Thrd_t _Thr; //其实_Thrd_t 是类型的别名
 
typedef _Thrd_imp_t _Thrd_t;    // 而_Thrd_imp_t是一个结构体
 
typedef struct {	/* 线程 Win32 标识符 */
    void *_Hnd;	    /* Win32 句柄 */
    unsigned int _Id;    // 线程id
} _Thrd_imp_t;
```



`join`长这样：

```c++

inline void thread::join(){	// join thread
	if (!joinable())            // 如果线程不可结合，调用join就报错。
		_Throw_Cpp_error(_INVALID_ARGUMENT);
	if (_Thr_is_null(_Thr))     // 如果是空线程，调用join继续报错。
		_Throw_Cpp_error(_INVALID_ARGUMENT);
	if (get_id() == _STD this_thread::get_id()) // 线程不能自己join自己。自己join自己就死锁了。
		_Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);
	if (_Thrd_join(_Thr, 0) != _Thrd_success)   // 线程结合（_Thrd_join()是join方法的核心），是阻塞的
		_Throw_Cpp_error(_NO_SUCH_PROCESS); //如果结合失败就报错
	_Thr_set_null(_Thr);        // 设置线程id为0
}

```

所以我们看到这几种情况不可以`join`：

- 默认构造的线程对象（空对象）
- 是非joinable的 (比如已经`join`或者`detach`过的，`move`过的和空的）
- 自己和自己。

如果一个可结合的线程经过`join`后（等线程执行完毕后），会将线程id置为0。



**我们查看`_Move_thread`函数可以发现，如果尝试给一个仍有效的线程对象再次用一个线程对象赋值，则会触发`terminate`**





## 为什么析构一个非joinable的线程会报错？

- 在实例化了线程对象之后，它们的状态默认都是可结合的，如果现在直接调用它们的析构函数来析构它们，那么在析构的时候线程处于什么状态呢？是执行完了吗？还是正在执行呢？注意，如果一个在没有结合（join）的情况下，就算它先于主线程执行完毕，其id依然是不为0的。所以我们是不能确定其状态的，所以我们只能析构明确了id为0的线程。因为id为0的线程要么已经执行完毕，要么是空线程，要么是分离后的线程。
- 另外，一个线程分离（`detach`）后，该线程对象便不能控制该线程，而是交由系统接管。



学习，整理自[这里](https://blog.csdn.net/hujingshuang/article/details/70208443)









# join和detach区别

- `join`在主线程和新线程中引入了一个同步点。
  - 主线程调用`join`后，会阻塞直到新线程完成并返回。只有当`join`返回后，主线程才能回收被调线程资源，并继续运行。
- 当使用`detach`函数时，主线程继续运行，被调线程驻留后台运行。二者同时运行。主调线程无法再取得该被调线程的控制权。当主调线程结束时，由运行时库负责清理与被调线程相关的资源。

我们对一个线程对象使用`join`或`detach`后，这个线程对象就不再是`joinable`的了。这时候线程对象可以被安全销毁。

当`detach`函数被调用后，执行的线程从线程对象中被分离，已不再被一个线程对象所表达--这是两个独立的事情。**C++线程对象可以被销毁，同时OS执行的线程可以继续。**如果程序想要知道执行的线程何时结束，就需要一些其它的机制。`join`函数在那个thread对象上不能再被调用，因为它已经不再和一个执行的线程相关联。
**去销毁一个仍然可以“joinable”的C++线程对象会被认为是一种错误。为了销毁一个C++线程对象，要么`join`函数需要被调用（并结束），要么`detach`函数被调用。如果一个C++线程对象当销毁时仍然可以被`join`，异常会被抛出。**



# 提防表面的线程安全

假设我们有这样一个表面线程安全的`stack`包装器

```c++
template<typename T>
class not_good_stack{
    public:
    stack<T> my_stk;
    mutex m;
        void push(const T& element){
            lock_guard<mutex>lcg (m);
            my_stk.push(element);
        }
        void pop(){
            lock_guard<mutex>lcg (m);
            my_stk.pop();
        }
        bool empty(){
            lock_guard<mutex>lcg (m);
            return my_stk.empty();
        }
        T& top(){
            lock_guard<mutex>lcg (m);
            return my_stk.top();
        }
};
```

它很简单，因为只是给每一个标准库实现的函数外面加了个锁。而且现在看起来很安全。不会同时又`push`又`pop`。但是有一个问题。在`empty`和`pop`中间，`top`和`pop`中间都会有间接的线程不安全问题。

```c++
void race1(){
    not_good_stack<int> mystk;

    if(!mystk.empty()){
        int value = mystk.top();
        mystk.pop();
    }  
}
```

在这种情况下，假设我们现在`stack`只有一个元素。有可能有两个线程并发的进入了该函数。

- 第一个函数检查是否为空，答案是不为空，所以进入`if`。
- 第二个函数此时刚好也进来了，检查是否为空。由于第一个函数没有来得及进行下一步，则此时依旧不为空。也进入`if`。

这时候就已经有问题了。可能第一个元素已经移除元素，这时候`top`会出现错误。

甚至，因为两个线程必定会执行两次`pop`。但是此时只有一个元素。所以会出现错误。

如果并不是只有一个元素，也会额外的多删除一个元素。也是错误。

## 如何解决

一般有两种方式。

- 第一种方式是针对整个函数`race1`加锁。
- 另一种方式是把有竞争关系的函数整合为一个。例如`empty`和`pop`合起来

```c++
void pop(){
    lock_guard<mutex>lcg (m);
    if(my_stk.empty()){
        cout << "already empty" <<endl;
        return;
    }
    my_stk.pop();
}
```

# 杂项

- 注意，线程对象在创建时就已经启动。而非调用`join`或`detach`时启动，这里和异步API有些不同。

```c++
void func(){
    cout<<"我的线程开始执行了"<<endl;
    //...
    cout<<"我的线程结束执行了"<<endl;
}

int main(){
    thread my_thread(func);
    Sleep(5000);
    my_thread.join();//等待子线程执行结束

    cout<<"abc"<<endl;
    return 0;
}
/*
我的线程开始执行了
我的线程结束执行了

然后睡眠直到时间到达。开始继续执行join
abc

*/
```

