---
title: C++ STL - 2 - 迭代器设计思路。萃取。
date: 2022-06-11 15:50:00 -0500
categories: [笔记]
tags: [STL]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true

---

# C++ STL - 2 - 迭代器设计思路。萃取。

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=410446173&amp;auto=1&amp;height=66"> </iframe>



# 什么是萃取？

**三个字：中间层**

我们这里先以侯捷老师的`iterator_traits`做为例子。

我们知道，`iterator`迭代器本身有五个属性。我们也知道迭代器是一个`class`。所以也就是迭代器类有五个变量。分别是：

```c++
namespace std
{
    template <typename T>
    struct iterator_traits
    {
        typedef typename T::iterator_category   iterator_category;  迭代器分类，比如正向迭代器，双向迭代器
        typedef typename T::value_type          value_type;  迭代器对应的数据类型，比如int string 等等
        typedef typename T::difference_type     difference_type; 用来表示两个迭代器之间的距离，因此也可以用来表示一个容器的最大容量
        typedef typename T::pointer             pointer; 
        typedef typename T::reference           reference; 
    };
}
```

算法组想通过迭代器访问容器数据。假设我们的算法组就一定要问你，迭代器指向的数据的类型是什么，我们可以轻易地像这样获取：

```c++
list<int>::iterator::value_type
```

它会回答你是一个`int`。

这样非常好。但是有一个问题。迭代器是一个泛化的指针。反过来说，指针就是一个退化的迭代器。

我们发现在迭代器类内部有一大堆的`typedef`。我们正是通过这个来告诉外面你这个类的`value_type`是个什么玩意。

举个小例子：

```c++
class test{
    public:
    test(){}
    typedef int inputtype;
};

int main(){
    test::inputtype x; //这句话等于告诉你 test类下面的inputtype这个东西是int 
}
```

**这里不需要加`typename`的原因是这不是模板类。类型是已经确定好的。后文会讲到。**

但是如果我们给算法传入的不是迭代器，而是一个指针怎么办？指针不是类，指针不是结构体，指针无法给自己弄一堆`typedef`。也就是你问一个指针，问他你的`value_type`是什么，他懵逼了，说我没有这玩意啊？怎么办

这就是萃取的意义。我们可以间接地获取类型。也就是利用模板的特化包装一层，让算法统一去问萃取层，这个东西的`value_type`是个什么玩意。

![QQ截图20220613172835](/assets/blog_res/2022-06-12-STL2.assets/QQ%E6%88%AA%E5%9B%BE20220613172835.png)

在图里，我们可以看见，如果传入的是迭代器，我们可以走到`1`里面，直接问迭代器的`value_type`是什么。

如果传入的是一个指针，我们可以走到`2`里面。人为地设定一个`value_type`。也就是把`T`提取出来。告诉算法组这个指向`T`类型的指针的`value_type`是`T`类型

举个例子：

```c++
template<typename T>
class pclass{
public:
    typedef T valuetype;
};

template<typename T>
class pclass<T*>{
public:
    typedef T valuetype;
};

int main(){
    pclass<int>::valuetype x; //x的类型是int
    pclass<int*>::valuetype x; //x的类型还是int。 可以看成T* = int*, 拿掉*就是 T = int 所以还是int。
    return 0;
}

```

