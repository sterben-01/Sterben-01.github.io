---
title: 虚函数表
date: 2022-07-20 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true

---

# 虚函数表

- **每个包含了虚函数的类都包含一个虚函数表。**虚函数表是一个指针数组，其元素是指向虚函数的指针，每个元素对应一个虚函数的函数指针。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以**虚表的元素并不包括普通函数的函数指针**。
- 虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表即可。**同一个类的所有对象都使用同一个虚表。**
- **虚表内的条目，即指向虚函数的指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚函数表就可以构造出来了。**
- `_vfptr`对象中指向虚函数表的这个指针是创建对象的时候才会出现，因为这个东西属于对象。
- 如果一个基类有虚函数，那么这个基类地址的头部（偏移量为0，最开始的地方）是一个**指向虚函数表的指针**。这个指向虚函数表的指针是在类对象创建时自动赋值的。**会自动被设置为指向自己这个类的虚表**。我们可以管这个指针叫做`_vfptr`。(具体的位置因平台而异)
- 也就是说。在多态情况下，也就是父类有虚函数的情况下，每一个类（父类/子类）都有一个自己的虚函数表。子类在多重继承的时候可能会有多个虚函数表，和多重继承导致的多个`_vfptr`
- 对象的虚表指针用来指向自己所属类的虚表，**虚表中的指针会指向其继承的最近的一个类的虚函数**。这里的要点是，假如`C`继承`B`，`B`继承`A`。`B`重写了`A`的虚函数，如果`C`没有重写，那么由于是`C`继承的`B`，所以`C`的虚函数表中的指针会指向`B`重写过的虚函数而不是`A`的。即 继承的最近一个类的虚函数。
- C++中虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。
- 当子类继承父类后，子类会继承（复制）父类的虚函数指针和虚函数表，（在子类构造函数调用时）会将自己的虚函数指针指向自己的虚函数表，但是如果子类重写了该方法(加virtual或者不加都可以，但是方法必须完全相同包括返回值)，那么子类的虚函数表中的函数则会改变。
- 父类指针指向子类对象时，发生动态联编，如果虚函数表被重写，则调用父类虚函数会指向被重写的方法，否则父类指针指向自身的方法，是静态联编。







举例：

```c++
class Base
{
public:
    virtual void function1() {};
    virtual void function2() {};
};
 
class D1: public Base
{
public:
    virtual void function1() {};
};
 
class D2: public Base
{
public:
    virtual void function2() {};
};
```

这是一个最简单的例子。因为这里有三个类，所以编译器会创建三个虚函数表。

编译器会在使用了虚函数的最上层的基类中的定义我们提到过的指向虚函数表的指针`_vfptr`。

加上之后长这样：

```c++
class Base
{
public:
    FunctionPointer *__vptr; //注意这里
    virtual void function1() {};
    virtual void function2() {};
};
 
class D1: public Base
{
public:
    virtual void function1() {};
};
 
class D2: public Base
{
public:
    virtual void function2() {};
};

```

这就是为什么说，这个`_vfptr`指针的偏移量是0，在最开始。因为类的内存分布是按照声明顺序的。

**注意这里为什么D1和D2没有添加`_vfptr`，因为`_vfptr`属于基类部分。子类是包含基类部分的。所以说这里不能再写了。也就是说，子类虽然包含自己的`_vfptr`，但是它是继承自父类的。**

`_vfptr` 在类对象创建的时候会设置成指向类的虚函数表。例如，类型 `Base` 被实例化的时候，`_vfptr` 就指向 `Base` 的虚函数表。类型 `D1` 或者 `D2` 被实例化的时候，`_vfptr` 就在子类调用父类构造期间，先指向 `Base`的虚函数表，再在执行子类构造期间指向`D1` 或者 `D2` 的自己的虚函数表。

## 不应在构造和析构函数中调用虚函数

**我们都知道，构造子类对象的时候，子类对象会先调用父类构造。调用父类构造的时候，我们可以理解为子类对象目前是父类类型。所以对象的`_vfptr`指针此时会指向父类的虚函数表。所以说这个时候虚函数不是虚函数。当父类构造完毕，调用子类的构造函数之时，子类对象会被认为是子类类型。这时这个`_vfptr`指针会指向子类自身的虚函数表，这时候虚函数才是虚函数**。这就是为何不应在构造和析构函数中调用虚函数。因为此时的虚函数并不表现出虚函数的多态性质。举个例子，我们在父类的构造函数中使用了一个虚函数，因为这个虚函数被调用是在父类构造期间。所以即便是子类对象来调用，这个`_vfptr`也是指向的父类的虚函数表。

举例:

```c++
class A{
    public:
    A(){
        p();
    }
    virtual void p(){
        cout << "A" <<endl;
    }
};

class B: public A{
    public:
    B(){
        p();
    }
    void p(){
        cout << "B"<<endl;
    }
};

class C :public B{
    public:
    C(){
        p();
    }
    void p(){
        cout << "C" << endl;
    }
};

int main(){
    A* a = new C; //会输出 ABC
}
```

这个程序会输出`ABC`。因为构建子类对象会依次调用父类构造。表面上这里构造函数调用了虚函数，**但是这个虚函数实际执行的是对应类的虚函数**。这就是我们说的，可以在构造函数中调用虚函数，但是不应调用。我们会发现，因为是依次构造，所以在调用对应类的构造的时候，调用的是对应类的虚函数。（C类对象在执行A类部分构造期间，调用的虚函数执行的是A类自己的。在执行B类部分构造期间，执行的是B类自己的。在执行C类部分构造期间，执行的是C类自己的）所以说并没有多态特性。**在实际应用中，这种在构造函数中调用虚函数的时候，不会有这种每一个类的虚函数都调用了对应虚函数的情形**。 标准情况下，`B`和`C`类的构造函数是不会调用函数`P`的。所以如果仅仅在父类`A`中调用了`P`，这个`P`也会是类`A`的`P`，不是类`C`的`P`

**记住：在自己类的构造函数中调用了虚函数，将会是自己类的函数。即，父类构造函数中调用的虚函数依旧是父类的，子类构造函数中调用的虚函数依旧是子类的。顺序是父类构造->此时虚函数表指针指向父类虚函数表->子类构造->此时虚函数表指针指向子类虚函数表。所以再次重申，父类指针指向子类对象，子类对象先调用了父类构造。父类构造中有虚函数，即便被子类重写过，但是此时子类对象仍在父类构造期间，虚函数表指针依旧指向父类的虚函数表。所以此时虚函数实际执行的不会具有多态性，会依旧执行父类虚函数而不是子类虚函数。**



## 虚函数表长什么样

我们假设所有的函数都是虚函数

### 基类的虚函数表

![QQ截图20220724044555](/assets/blog_res/2022-07-24-vptr.assets/QQ%E6%88%AA%E5%9B%BE20220724044555.png)

### 一般继承（无虚函数覆盖*）的子类虚函数表

![QQ截图20220724044712](/assets/blog_res/2022-07-24-vptr.assets/QQ%E6%88%AA%E5%9B%BE20220724044712.png)

![QQ截图20220724044722](/assets/blog_res/2022-07-24-vptr.assets/QQ%E6%88%AA%E5%9B%BE20220724044722.png)

此时：

1）虚函数按照其声明顺序放于表中。
2）父类的虚函数在子类的虚函数前面。

### 一般继承（有虚函数覆盖*）的子类虚函数表

![QQ截图20220724044950](/assets/blog_res/2022-07-24-vptr.assets/QQ%E6%88%AA%E5%9B%BE20220724044950.png)

![QQ截图20220724044958](/assets/blog_res/2022-07-24-vptr.assets/QQ%E6%88%AA%E5%9B%BE20220724044958.png)

此时：
1）覆盖的`f()`函数被放到了虚表中原来父类虚函数的位置。
2）没有被覆盖的函数依旧。

所以当如下代码执行时

```c++
Base *b = new Derive();
b->f();
```

**由`b`所指的内存中的虚函数表（子类构造结束后，子类`_vfptr`指向自己的虚函数表）的`f()`的位置已经被`Derive::f()`函数地址所取代，于是在实际调用发生时，编译器检测到了`f`是一个虚函数，所以不会静态的将`Base`类的函数直接编译过来。，而是运行的时候，动态的根据`b`指向的对象，找到这个对象的自己的`_vfptr`指针找到这个对象(一个类的所有对象共用一个虚函数表)的虚函数表。然后调用虚函数表里面对应的函数。于是`Derive::f()`被调用了。这就实现了多态。**

### 多重继承（无虚函数覆盖*）的子类虚函数表

假设有如下继承关系(无覆盖)

![QQ截图20220724045219](/assets/blog_res/2022-07-24-vptr.assets/QQ%E6%88%AA%E5%9B%BE20220724045219.png)





![QQ截图20220724045811](/assets/blog_res/2022-07-24-vptr.assets/QQ%E6%88%AA%E5%9B%BE20220724045811.png)

我们可以看到：
1） **每个父类都有自己的虚表。**因为每一个继承，子类都会有一个对应的虚表。所以多继承，子类也会有多个虚表（虚表指针）。

2） 所以子类有多重继承而来的多个`_vfptr`以指向多个虚函数表

3）**子类的成员函数被放到了第一个父类的表中**。（所谓的第一个父类是按照声明顺序来判断的）
这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。

**注意，多重继承有多个虚函数表，而每一个虚函数表的开头都会有一个偏移量和一个RTTI信息**





### 多重继承（有虚函数覆盖*）的子类虚函数表



![QQ截图20220724050212](/C:/Users/01/Desktop/QQ%E6%88%AA%E5%9B%BE20220724050212.png)



![QQ截图20220724050217](/assets/blog_res/2022-07-24-vptr.assets/QQ%E6%88%AA%E5%9B%BE20220724050217.png)

#### 注：覆盖又称override 重载



## 虚函数表的其他内容

虚函数表在第一个指向虚函数指针的前面还会有两个东西：

1. 一个指针，指向一个存有字符串的类(`type_info`)。也就是储存了RTTI信息。c++运行时类型识别信息。**我们就是靠这个来让在有虚函数的情况下，父类指针指向子类对象的时候，子类到底是什么类型** 。我们知道只有带有虚函数的类才会生成虚函数表,因此**动态类型强制转换只用于多态类型**，在进行动态类型转换时只要取虚函数表中的第-1个元素得到`type_info`类对象判断其真正的类型再进行操作



2. 一个偏移量。指示类中这个`_vfptr`离类的头指针有多远。一般情况下都是0。因为`_vfptr`会在头部。**但是在多继承的时候，如上图，会有多个`_vfptr`。所以会有偏移量。**









# RTTI 和虚函数的关系



在解释这个问题之前我们先回顾一下向上和向下转型

```c++
class Base{
    virtual void func(){
        //...虚函数有没有都行
    }
};
class Derive :public Base{
    
};
int main(){
    Base* b = new Derive(); //父类指针指向子类对象。这句话等同于下面这两行。也就是子转父。也就是向上转型。此行是对象切片
    Base* b = static_cast<Base*>(new Derive()); 
    Base* b = (Base*) new Derive(); //C风格
    
    Derive* d = new Base(); //错误，禁止隐式的向下转型。也就是子类指针指向父类对象。也就是父转子。下面这两行可以通过编译
    Derive* d = static_cast<Derive*>(new Base()); 
    Derive* d = (Derive*) new Base(); // C风格
    
    
    return 0;
}
```



`static_cast`强制类型转换不安全，因为没有类型检查。但是并不禁止编译。**会产生未定义行为**。我们上一行的`Derive* d = static_cast<Derive*>(new Base());`可能看得不够清楚。我们拆开来看

```c++
Base* baseptr = new Base();
Derive* d = static_cast<Derive*>(baseptr); //不安全
```

看到问题了吗？我们仅仅初始化了父类成员，但是转成了子类对象。这代表会多出一块未定义的空间。

但是如果

```c++
Base* baseptr = new Derive(); //注意这里
Derive* d = static_cast<Derive*>(baseptr); //安全
```

这样就是安全的，为什么？因为我们这里用的是指针。虽然子类对象隐式已经在第一行被转换成了父类类型，但是我们可以安全的手动转回来。因为我们第一行`new`的时候初始化了全部的子类成员，隐式转换成父类后会被隐藏（**此处使用的是指针。切记，指针类型表示编译器可以合法读取多大区域的内存。我分配了整个子类，但是我只让指针读取父类的部分，这是可以的，数据没有被清除，仅仅是指针访问不到而已。**），手动转回来不会出现未定义空间。

在没有多态的时候，由于无法使用`dynamic cast`导致没有类型检查导致风险较大。因为你必须要手动保证转型的指针`new`的是子类对象而不是父类对象。但是`dynamic cast`就帮助我们进行了一个类型检查。

为了避免这种不安全的转换，所以我们需要`dynamic_cast`来在运行时检查是否可以安全转换。这就用到了RTTI。

**只有包含虚函数的类才可以使用`dynamic_cast`因为RTTI 依赖于虚表，所以用dynamic_cast 对应的类一定要有虚函数。**



- 在**没有虚函数**的前提下，如果父类和子类定义了相同名称的成员函数，那么通过对象指针调用成员函数时，**到底调用那个函数要根据指针的原型来确定，而不是根据指针实际指向的对象类型确定。**

```c++
class Base{
  	//...没有虚函数  
};
class Derive:public Base{
    
};
int main{
    Base* ptr = new Derive(); //静态绑定。ptr实际上指向的类型是ptr的类型即父类类型
    cout << typeid(*ptr).name() << endl; //输出base
    return 0
}
```

- 在**有虚函数**的前提下，如果父类和子类定义了相同名称的成员函数（重写，动态绑定），那么通过对象**指针调用**成员函数时，**与当前指向类实例的父类指针类型无关，仅和类实例对象本身有关。**

```c++
class Base{
  	virtual void p(){
        //...
    }
};
class Derive:public Base{
    //...子类无论是否定义了相同名称的成员函数（重写），都会使父类指针指向的类型变为子类类型
};
int main{
    Base* ptr = new Derive(); //动态绑定。ptr实际上指向的类型是Derive的类型即子类类型。指针的静态类型和目标类型不同
    cout << typeid(*ptr).name() << endl; //输出Derive
    return 0
}
```



**虽然此时`ptr`可以被认为是指向了子类类型，但是我们不要忘记了，指针类型其实是告诉编译器应该正确解析多大的内存空间。所以此时依旧无法访问子类自己的部分 如变量和非虚函数。**

所以如果此时我们想要访问子类函数或变量应该怎么办？我们需要`dynamic_cast`来在运行时检查是否可以安全转换。这就用到了RTTI。

**`dynamic_cast` 如果执行成功，会返回子类地址。如果转的是指针，失败会返回`nullptr`, 如果转的是指针，失败会抛出`bad_cast`因为引用无法为空**

### 通过运行时类型信息（RTTI）能够使用基类的指针或引用来检查这些指针或引用所指的对象的实际派生类型

我们说过，有虚函数表的开头是一个指向RTTI的指针里面包含了，指向当前类对应的 `type_info `对象。当程序在运行阶段获取类型信息时，可以通过对象指针找到对象自己的指向虚函数表的指针 `_vfptr`，再通过 `_vfptr`找到 `type_info` 对象的指针，进而取得类型信息。

`static_cast`转型的话只要是有点关系的两个类型就可以转，转了会不会出问题他不管，用户自己负责。

`dynamic_cast`的话会根据虚表里信息去比对，这个基类指针指向的对象真的是派生类才会转换，否则就返回空指针，提醒用户不能转换。



# 一段话总结

父类指针指向子类对象，限制了父类指针读取的内存区域，只可以读取父类部分。所以我们认为这时候这个东西是父类类型。所以在没有虚函数的时候，父类指针是无法使用子类独有资源（成员变量，成员函数）的。

当多态发生的时候，我们父类指针指向子类对象依旧会被编译器认为是父类类型（也可以理解为指向对象被隐式转换或者是切片）。所以只能访问子类对象的父类部分，无法访问子类独有的数据（变量和非虚函数）。但是我们说过，指向虚函数表的指针`_vfptr`是在子类的父类部分中的。所以这个指针是可以访问的。当我们调用虚函数的时候，由于我们指向的是子类对象，也就是**实例化的是子类对象**，（`Base* ptr = new Derive()`这句话我们看到`new`了一个`Derive`，所以还是会进行正常的构造过程。也就是先执行父类构造，再执行子类构造。我们说过，父类构造期间，对象的`_vfptr`会指向父类的虚函数表，然后执行子类构造期间，`_vfptr`会指向子类虚函数表。所以**子类构造完毕后，`_vfptr`一定会指向自己的虚函数表**）。所以`_vfptr`指向的是子类的虚函数表。所以可以通过这个指向了子类虚函数表的`_vfptr`指针找到对应的虚函数表，然后对虚函数进行调用。**但是这个时候我们还是不可以通过父类指针访问子类的非虚函数和子类的成员变量。因为他还是被认为是父类类型。**所以这时候我们想访问子类独有资源就可以使用`dynamic_cast`来进行安全的转换。

这个`dynamic_cast`是怎么用的呢？我们父类指针指向子类对象的时候，限制了指针仅可以读取子类对象的父类部分。我们进行`dynamic_cast`的时候，会使用RTTI信息。这个信息是储存在虚函数表的头部。也就是编译器找到了虚函数表指针（子类对象的虚函数表指针一定指向自己的虚函数表，所以RTTI信息类型也是子类），然后问RTTI：”这人想要让我转换成子类，也就是多读点儿子类的东西，你帮我看看我指向的对象到底是不是子类，多读的那部分被正确初始化了没有？合法不合法？“。RTTI看了一眼回答：”哦，你指向的部分实际类型确实是一个子类的类型，因为他`new`的时候`new`的是一个子类对象。我检查了，都初始化了，也合法，那你就多读点儿吧“。这就是`dynamic_cast`和RTTI的联系。



所以虚函数表的RTTI应该就是进行一个安全检查。

# 为什么多态只能使用指针或者引用？

c++确定类型分两种，一种是对象，一种是指针或者是引用。如果是对象，那就是我们编译时确定它是什么玩意。如果是指针或引用，在设计层面他们就被允许指向声明类型或者是声明类型的子类的对象。**首先有一点，对象永远不应该改变它的类型。这就是对象模型的工作方式。**所以只有在用指针和引用调用的时候才发生了这个RTTI查询并且执行正确的函数。而通过对象调用则不会有这种情况。所以在直接使用对象赋值的时候，拷贝赋值这种东西会忽略掉`_vfptr`这种只有动态绑定才会激活的东西，只会拷贝赋值普通成员变量。所以哪怕子类的`_vfptr`和虚函数表继承了父类的，也确实是父类的，但是因为他是个`_vfptr`，规定只有在指针或者引用的情况才会被激活，所以会在拷贝赋值的时候忽略。

第二点，我们指针指向的对象没法互相赋值，赋值只能是交换指针。**指针的拷贝赋值是指针类型自己的，和指向的对象类型无关。**所以这一层面的拷贝赋值使用的是对象的拷贝赋值，而不是指针的拷贝赋值。所以自然忽略掉了`_vfptr`对应的内容。

我们梳理一下，假设我们有下面代码

```c++
class A  
{  
public:  
    virtual void T(){}  
    virtual void print()  
    cout<<"A"<<endl;
};  
class B:public A  
{  
public:  
    void print()  
    cout<<"B"<<endl;  
};  
int main()  
{  
  A a;  
  B b;  
  a = b;  
  a.print();                         //通过对象直接访问  
  b.print();  
  return 0;  
}
```

我们的`a` 和 `b`已经被构造完毕，所以此时`_vfptr`已经指向了自己的。**哪怕我们没有使用多态调用，但是由于类内存在虚函数，则一定存在虚函数表。对象也一定存在`_vfptr`指针。（我可以不用，但不能没有）**

![QQ截图20220823022745](/assets/blog_res/2022-07-24-vptr.assets/QQ%E6%88%AA%E5%9B%BE20220823022745.png)

**我们可以看到，对象`b`的虚函数表指针和虚函数表被认为是在A里面的，也就是继承来的。但是继承是复制。所以才有那句话：每一个类都有一个自己的虚函数表，每一个对象都有一个自己的虚函数表指针`_vfptr`**

**当我们执行到`a = b`的时候，虚函数表的内容并没有被替换。所以我们可以认为，拷贝赋值或者拷贝构造的时候会忽略掉任何和虚函数相关的东西，只针对可以拷贝的东西进行操作。默认的赋值运算符并不会操作虚函数表。一个类对象里面的`_vfptr`永远不会变，永远都会指向所属类型的虚函数表，因为对象的语义就是类型永远不会改变。**

![QQ截图20220823024407](/assets/blog_res/2022-07-24-vptr.assets/QQ%E6%88%AA%E5%9B%BE20220823024407.png)

**一句话总结：虽然子类的虚表指针和虚函数表是继承自父类，并且认为是父类的，但是在把子类对象拷贝给父类对象的时候，编译器会忽略掉所有虚机制的部分。**



更多可以看深度探索c++对象模型的1.3和虚函数章节。包括笔记的2.2拷贝构造函数部分。



# 虚继承：

待补充 可以看文章：https://blog.csdn.net/xiaxzhou/article/details/76576516

解决菱形继承问题。

# 哪些函数不可被声明为虚函数：

## 普通函数（非成员函数）

非成员函数只能被重载(overload)，不能被继承(override)，而虚函数主要的作用是在继承中实现动态多态，非成员函数早在**编译期间就已经绑定函数了**，无法实现动态多态，那声明成虚函数还有什么意义呢？

## 构造函数（注意析构函数不仅可以，而且在有虚函数的类里，必须把析构函数声明为虚函数）

要想调用虚函数必须要通过“虚函数表”来进行的，但虚函数表是要在对象实例化之后才能够进行调用。而在构造函数运行期间，还没有为虚函数表分配空间，自然就没法调用虚函数了。**一句话概括：构造函数用来实例化对象，虚函数必须要在对象实例化后才可调用。**

## 静态成员函数

静态成员函数对于每个类来说只有一份，所有的对象都共享这一份代码，它是属于类的而不是属于对象。**虚函数必须根据对象类型才能知道调用哪一个虚函数**，故虚函数是一定要在对象的基础上才可以的，两者一个是与实例相关，一个是与类相关。而且因为只有一份，没有动态绑定的必要。

## 内联成员函数

内联函数是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够实施多态性。但是inline函数在编译时被展开，而虚函数在运行时才能动态地绑定函数。

## 友元函数

C++不支持友元函数的继承。对于没有继承特性的函数没有虚函数的说法。友元函数不属于类的成员函数，不能被继承。















## 更清晰的继承状态下的虚函数表例子：

```c++
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};
class B : public A {
public:
    virtual void vfunc1();
    void func1();
private:
    int m_data3;
};
class C: public B {
public:
    virtual void vfunc2();
    void func2();
private:
    int m_data1, m_data4;
};


int main() 
{
    B bObject;
    A *p = & bObject;
    p->vfunc1();
}
```



![QQ截图20220724172506](/assets/blog_res/2022-07-24-vptr.assets/QQ%E6%88%AA%E5%9B%BE20220724172506.png)



程序在执行`p->vfunc1()`时，会发现`p`是个指针，且调用的函数是虚函数，接下来便会进行以下的步骤。

首先，根据虚表指针`p->_vfptr`来访问对象`bObject`对应的虚表。虽然指针`p`是基类`A*`类型，但是`_vfptr`也是基类的一部分，所以可以通过`p->_vfptr`可以访问到对象对应的虚表。**即便是父类指针指向子类对象，也是查找子类对象的虚函数表。因为子类调用父类构造函数完毕后，调用子类构造期间会将自己的`_vfptr`指向子类自身的虚函数表**

然后，在虚表中查找所调用的函数对应的条目。由于虚表在编译阶段就可以构造出来了，所以可以根据所调用的函数定位到虚表中的对应条目。对于`p->vfunc1()`的调用，B 的虚函数表的第一项即是`vfunc1`对应的条目。

最后，根据虚表中找到的函数指针，调用函数。可以看到，B 的虚函数表的第一项指向`B::vfunc1()`，所以`p->vfunc1()`实质会调用`B::vfunc1()`函数。



## 注意重载 重写 重定义的区别

### 1. 重载（overload）

指函数名相同，但是它的**参数表列个数或顺序，类型不同**。但是不能靠返回类型来判断。 
特征是：
1. 相同的范围（在同一个作用域中）
2. 函数名字相同
3. 参数不同
4. `virtual` 关键字可有可无

**仅根据函数返回值类型不能进行重载**。如果两个函数仅仅返回值类型不同，则不可以进行重载。因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。

### 2. 重写（也称为覆盖 override）
指派生类重新定义基类的虚函数

特征是：

1. 不在同一个作用域（分别位于派生类与基类） ；
2. 函数名字相同；
3. 参数相同；
4. 基类函数必须有 `virtual` 关键字，不能有` static `。
5. 返回值相同（或是协变），否则报错
6. 重写函数的访问修饰符可以不同。尽管 virtual 是 private 的，派生类中重写改写为 public,protected 也是可以的

### 3. 重定义（也称为隐藏）
特征是：

1. 不在同一个作用域（分别位于派生类与基类） ；
2. 函数名字相同；
3. 返回值可以不同；
4. **参数不同时**，**不论有无** `virtual` 关键字，基类的函数将被隐藏（注意别与重载以及覆盖混淆） 
5. **参数相同时**，**基类函数没有**` virtual`关键字。此时，基类的函数被隐藏（注意别与覆盖混淆） 。

​	**特别注意：当使用基类指针指向子类对象，并且发生重定义，且基类函数没有`virtual`的时候。依旧执行基类函数。因为首先：没有发生多态，其次，基类指针指向子类对象，他只能访问子类的基类部分。所以说他也就是基类类型，自然只能访问到基类函数。**



**父类指针指向子类对象，仅可访问子类的父类部分。因为不知道子类的内存布局，所以没法访问子类的部分。也就是说，父类指针指向子类对象会发生隐式转换。所以说它还是个父类类型。**

#### 隐藏也会发生在父类子类中有同名变量的时候。子类中会隐藏父类的变量，我们可以用作用域访问运算符去访问。

```c++
class test{
    public:
    int val;

    test(int x):val(x){}
    virtual void print(){
        cout <<"test" << endl;
    }
};
class test1 : public test{
    public: 
    int val = 10;               //子类父类同名变量 这个val是test1::val 所以值是10.
    int vala;
    test1(int x, int y):test(x), vala(y){};     //调用父类构造函数赋值，这里是给子类的父类变量赋值，也就是给test::val赋值
    void print(){
        cout <<"test1" << endl;
    }
};

```



```c++
int main()
{
    test t(4);
    cout << t.val << endl;      //此时输出4
    test1 t1(43,5);
    cout << t1.val << endl;     //此时输出10。因为t1是子类对象，访问的是子类的val，也就是test1::val
    t = t1;                     //这样赋值的时候只会赋值43。因为我们的构造函数是给test::val赋值而不是test1::val赋值。而且这样的拷贝赋值只会操作子类父类共有的部分，也就是test::val。
    //而test1::val是子类自己的。所以无法赋值。
    cout << t.val << endl;      //此时输出43。
    test* tptr = new test1(43,5);   //多态调用，输出43。因为父类指针指向子类对象也是父类类型。父类无法访问子类独有部分。所以这里访问的是test::val而不是test1::val
    cout << tptr->val <<endl;       //输出43。
	return 0;
}
```















## 注意不能靠返回值类型来进行函数重载

- 因为重载是编译期决定，函数要么是可以调用要么是不能调用，不存在有可能调用，所以有歧义。（静态多态）
- 我们调用函数的时候没有指定函数返回值类型，也不能指定函数返回值类型，所以有歧义。

如果硬要返回值重载，那么就要重新设计语言。设计成函数调用的时候需要指定返回值类型，而且函数签名也要包含返回值。

## C语言没有函数重载。因为C语言的函数签名只有名称没有参数。C++可以重载是因为函数签名包括函数名字和参数类型，但是不包括返回值。

