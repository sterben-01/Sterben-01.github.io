---
title: 操作系统相关
date: 2022-07-20 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true
  
---



# 进程是进程是操作系统分配资源的最小单位。线程是程序执行的最小单位。



# 进程和线程资源共享：

## 线程共享的内容包括:

- 1.进程代码段
- 2.进程数据段
- 3.进程打开的文件描述符
- 4.信号的处理器
- 5.进程的当前目录和
- 6.进程用户ID与进程组ID
- **7.堆**

## 线程独有的内容包括:

- 1.**线程ID**
- 2**.寄存器组的值**
- 3.**线程的栈**
- 4.错误返回码
- 5.线程的信号屏蔽码



# 进程退出

- 进程退出的时候会自动关闭自己打开的所有文件和网络连接
- 进程退出的时候**不会自动销毁共享内存**（注意不是mmap是shmget）。因为进程间通信使用的数据结构是内核级别的。创建 后由内核管理



# 孤儿进程 僵尸进程

## 孤儿进程：

一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 

**一句话总结：父进程比子进程走得早。子进程由系统接管。变成孤儿进程**

## 僵尸进程：

一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息（没有回收子进程资源），那么子进程的进程描述符（资源）仍然保存在系统中。这种进程称之为僵死进程。也就是子进程结束了父进程没结束，子进程部分PCB信息就会被悬挂。 当子进程走完了自己的生命周期后,它会执行exit()系统调用,内核释放该进程所有的资源,包括打开的文件,占用的内存等。**但是仍然为其保留一定的信息(包括进程号the process ID,退出码exit code,退出状态the terminationstatus of the process,运行时间the amount of CPU time taken by the process等),这些数据会一直保留到系统将它传递给它的父进程为止,直到父进程通过wait / waitpid来取时才释放。** 也就是说,当一个进程死亡时,它并不是完全的消失了。进程终止,它不再运行,但是还有一些残留的数据等待父进程收回。当父进程 fork() 一个子进程后,它必须用 wait() (或者 waitpid())等待子进程退出。正是这个 wait() 动作来让子进程的残留数据消失。 

- 一句话总结：如果子进程结束，父进程没有回收子进程的资源，则子进程部分PCB信息会被悬挂。如果不用wait或waitpid回收就会变成僵尸进程。因为没办法回收掉其中资源







# 主线程和子线程退出关系： 

**主线程和子线程之间没有必然的退出次序关系。主线程退出，子线程可以继续执行，也可以整体退出。；子线程退出，主线程也可以继续执行。** 程序加载到内存中执行的时候，**进程**就会生成一个**主线程**。虽然主线程和子线程之间没有必然的退出次序关系，但是**如果进程终止，那么进程下所有的线程都会终止** 

- **若想主线程在子线程前结束，并且进程不结束，就需要用到pthread_exit()函数**。按照POSIX标准定义，当主线程在子线程终止之前调用pthread_exit()时，子线程是不会退出的。 这里在main函数中调用pthread_exit()只会是主线程退出，而进程并未退出。通过调用pthread_exit函数，线程会显式终止。如果主线程调用pthread_exit，它会先终止，然后等待其他子线程终止后，进程才终止。
- 如果主线程以return的方式退出，则子线程会退出。如果主线程使用的是pthread_exit() ，实际上是提前结束了 main 的主线程，也就无法执行后续的 exit() 函数了。所以，这种方法是可以达到主线程退出子线程继续运行的目的。



# 用户空间(0-3G):进程私有,内核空间(3G-4G):所有进程共享

![QQ截图20220809045820](/assets/blog_res/2022-07-27-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3.assets/QQ%E6%88%AA%E5%9B%BE20220809045820.png)

# EXIT和return区别

## EXIT

- 是系统层级的系统调用，**指的是让进程退出**。调用后会开始进行资源的清理和回收。
- exit是一个函数

## return

- return是一个关键字，用于退出这个函数。（结束函数的执行）

## pthread_exit

所以使用pthread_exit可以维持子线程不退出的原因是，虽然主进程也是主线程，但是我只让主进程自己的线程退出，也就是不回收进程资源，相当于进程没有结束，子线程依旧可以执行。

# 每一个进程都有一个自己的页表

# 进程有独立地址空间，线程没有。因为线程属于进程，多个线程都属于一个进程，所以互相之间共享这个地址空间。也导致没有隔离性。



# 中断中的缺页中断

- 在请求分页的过程中，如果访问的页面不再内存中，会产生一次缺页中断，在外存中找到所缺的一页将其调入内存。

- 步骤：

  - 保护cpu现场

  - 分析中断原因

  - 转入缺页中断处理函数

  - 恢复cpu现场，继续执行



# 缺页异常

**会出现缺页异常的情况：**

1. 线性地址不在虚拟地址空间中
2. 线性地址在虚拟地址空间中，但没有访问权限
3. 接上一条，没有与物理地址建立映射关系

**fork等系统调用时并没有映射物理页（没有权限），写数据->缺页异常->写时拷贝**

1. 映射关系建立了，但在交换分区中
2. 页面访问权限不足



# 上下文切换

## CPU的上下文切换- CPU上下文包含寄存器和程序计数器

任务是交给 CPU 运行的，那么在每个任务运行前，CPU 需要知道任务从哪里加载，又从哪里开始运行。

所以，操作系统需要事先帮 CPU 设置好 **CPU 寄存器和程序计数器**。

- **CPU 寄存器**是 CPU 内部一个容量小，但是速度极快的内存（缓存）。我举个例子，寄存器像是你的口袋，内存像你的书包，硬盘则是你家里的柜子，如果你的东西存放到口袋，那肯定是比你从书包或家里柜子取出来要快的多。
- **程序计数器**则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。

所以说，CPU 寄存器和程序计数是 CPU 在运行任何任务前，所必须依赖的环境，这些环境就叫做 **CPU 上下文**。

CPU 上下文切换就是先把前一个任务的 CPU 上下文（CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

系统内核会存储保持下来的上下文信息，当此任务再次被分配给 CPU 运行时，CPU 会重新加载这些上下文，这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。

**一句话：任务需要切换的时候，（CPU切换到其他任务进行执行的时候），需要先保存旧任务的上下文，然后再加载新的上下文，上下文包括cpu寄存器和程序计数器。**

上面说到所谓的「任务」，主要包含进程、线程和中断。所以，可以根据任务的不同，把 CPU 上下文切换分成：**进程上下文切换、线程上下文切换和中断上下文切换**。

## 进程的上下文切换 - 进程上下文包括内核空间的资源（内核堆栈，寄存器等） + 用户空间资源（虚拟内存，堆，栈，全局变量等） 这一大堆就是PCB

进程是由内核管理和调度的，所以进程的切换只能发生在内核态。

所以，**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。而且，由于切换了进程，也切换了页表。涉及到缓存的部分比如L1 L2 L3 和 TLB大概率会被全部击穿，导致需要进行IO**

通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行。

**一句话，我们把重要的信息保存在PCB里面，进程上下文就是PCB内容（如进程ID，进程堆栈，进程各个寄存器的状态）。**

### 发生进程上下文切换有哪些场景？

- 为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行；
- 进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行；
- 当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度；
- 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行；
- 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；

## 线程的上下文切换：

在前面我们知道了，线程与进程最大的区别在于：**线程是调度的基本单位，而进程则是资源拥有的基本单位**。

所以，所谓操作系统的任务调度，实际上的调度对象是线程，而进程只是给线程提供了虚拟内存、全局变量等资源。

对于线程和进程，我们可以这么理解：

- 当进程只有一个线程时，可以认为进程就等于线程；
- 当进程拥有多个线程时，这些线程会共享相同的虚拟内存（虚拟地址空间）和全局变量， **堆**等资源，这些资源在上下文切换时是不需要修改的；
- **另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时是需要保存的。（这部分不共享，每一个线程独有）**

### 所以上下文切换这还得看线程是不是属于同一个进程：

- 当两个线程**不属于**同一个进程，则切换的过程就跟进程上下文切换一样；
- **当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。比如上面写到的不共享的，重点就是俩：寄存器，栈，线程ID**；

所以，线程的上下文切换相比进程，开销要小很多

# 为什么维护进程开销大？而线程开销小？

## 进程：

- 创建进程时，分配资源、建立 PCB；
- 终止进程时，回收资源、撤销 PCB；
- 进程切换时，保存当前进程的状态信息；

## 线程：

- 线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；**一句话：线程不复制（建立）PCB**
- 线程的终止时间比进程快，因为线程释放的资源相比进程少很多；**一句话：线程不复制pcb，所以也不撤销PCB**
- 同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；**一句话：共享虚拟地址空间，映射也不修改所以侧面也是共享物理地址空间，切换线程不需要切换页表**。
- 由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；**一句话：线程没有隔离性，文件资源和内存都共享。因为线程是属于进程的**





# 子进程fork父进程，哪些数据复制哪些不复制？

- 所有用户区数据都复制，比如堆，栈，bss, data, text, 内存映射区，环境变量命令行参数等。
- 内核区只有一样不同（不复制）：PID。
- 会复制页表（因为每一个进程都有自己的页表），**但不复制物理页面。（如果有写时拷贝COW）**

**一句话：没有写时复制的话全都复制，只有PID不同。有写时复制的话用哪儿复制哪儿。**

- 在没有写时复制（copy on write）的时候，fork的那一刻，就会为子进程分配新的虚拟内存并且把物理内存中的数据复制至新开辟的物理内存中，然后映射至虚拟内存。
- 如果有写时复制，则fork的时候为子进程开辟新的虚拟内存，**但是物理内存依旧映射至父进程的物理内存**。所以可以理解为现在父子进程共享这一段物理内存，但是**进程针对这段虚拟内存一定是只读的，因为只有设置为只读，这样进行写操作的时候才能触发缺页异常然后分配新的物理内存并复制里面的内容。在这之后，就可以把进程的内存设置为可读写了 。**。
- 注意上面是触发缺页异常不是缺页中断。缺页中断说法不准确，应该叫因为缺页异常触发的中断叫缺页中断，因为要和一般中断区分开。
  - 直到：
    - 父进程或者是子进程对相应的一段区域（代码段，数据段等等）修改，（理解为对共享区域进行写操作），这个时候内核才会为其对应的段复制一个对应的物理页面然后分配给这个进程使用。同时修改对应的页表。
    - 理论上因为写时复制，所以代码段不会被修改，如果有进程替换的话，则代码段会被修改。

- **fork前打开的文件描述符共享，fork后的不共享**
  - 因为子进程也复制了父进程 的PCB，所以也将父进程中的文件描述符复制了，struct file是内核文件表，每个进程只要有它的地址，就可以找到，所以子进程便可以找到这个文件，对文件进行操作。**所以fork前打开的文件描述符被复制后，引用计数器也会+1。子进程对文件操作也会影响父进程**，实际上是操作的文件中的偏移量，共享了文件偏移量。**但是在fork之后打开的文件，那就是各自进程打开各自的了，这当然是不共享的了。**




# 线程崩溃会导致进程崩溃吗

线程崩溃会触发SIGSEGV信号。你可以让他选择不直接崩溃，捕捉信号然后继续运行。但是这个信号一般意味着很严重的错误，你也不希望有任何线程触碰到引起错误的这块。**但是线程没有隔离性，各个线程共享同一个地址空间你也无法保证说引起错误的这块一定不会被其他线程碰到。**所以一个接着一个的错误会陆续发生。所以进程崩溃是迟早的事。

# 一个进程中的线程在其他进程中可见吗？ -- 不可见

每一个进程都认为系统中只有自己，因为虚拟化。所以说他根本就不知道有其他进程，更不可见其他进程中的线程

## 所有的进程间通信都是间接的。都依赖系统调用



# Linux 系统的根目录下主要包括哪些文件夹，各自的作用是什么？

- `/boot`  存放Linux内核、引导配置等启动文件
- `/bin`  存放最基本的用户命令，普通用户有权限执行。
- `/dev`  存放硬盘、键盘、鼠标、光驱等各种设备文件。
- `/etc`  存放各种配置文件、配置目录
- `/home` 存放普通用户的默认工作文件夹(即 宿主目录、家目录)
- `/root`  Linux系统管理员(超级用户)root的宿主目录。
- `/sbin`  存放最基本的管理命令，一般是管理员才有权限执行。
- `/usr`  存放额外安装的应用程序、源码编译文件、文档等各种用户资料
- `/var` 存放日志文件、用户邮箱目录、进程运行数据等变化的文档。
- `/tmp` 存放系统运行过程中使用的一些临时文件。

# 什么时候陷入内核态

注意：陷入内核态和上下文切换无必然关联。上下文切换理解为切换任务。而陷入内核态和此事无必然联系

## 中断是陷入内核的唯一方式

中断分为内中断和外中断。

### 内中断（异常，例外） 中断信号来自CPU内部。和当前指令有关

- 陷阱，陷入
  - 一般由陷入指令引发。是应用程序故意引发的。比如系统调用。

- 故障
  - 错误条件引发，可以被修复。比如缺页中断

- 终止
  - 异常错误无法修复。比如整数除0 或 非法请求


### 外中断。中断信号来自CPU外部。和当前指令无关。

- 时钟中断
- IO中断请求



# Linux 查看进程指令

- ps (process status) 列出当前系统运行的进程
  - aux 
    - all 列出所有用户启动的进程
    - user 使用该格式列出
    - x 列出当前用户在所有中端下的进程
  - -ef
    - 打印所有进程
  - 这俩区别就是格式不同
- top
  - 交互式的，实时动态显示，默认情况下每3秒更新一次。 以全屏交互式的界面显示进程排名，及时跟踪包括CPU、内存等系统资源占用情况   按ctrl + c 终止
- pstree -aup
  - 以树状图的方式展现进程之间的派生关系，显示效果比较直观。

# Linux 查看CPU使用率

- top
  - %us：表示用户空间程序的cpu使用率（没有通过nice调度）

  - %sy：表示系统空间的cpu使用率，主要是内核程序。

  - %ni：表示用户空间且通过nice调度过的程序的cpu使用率。

  - %id：空闲cpu

  - %wa：cpu运行时在等待io的时间

  - %hi：cpu处理硬中断的数量

  - %si：cpu处理软中断的数量

  - %st：被虚拟机偷走的cpu
    

# GDB

记得编译的时候要加`-g`才能源码级调试。`-g` 选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证 gdb 能找到源文件。

