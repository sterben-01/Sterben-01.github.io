---
title: 操作系统相关
date: 2022-07-20 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true
  
---



# 进程是进程是操作系统分配资源的最小单位。线程是程序执行的最小单位。



# 进程和线程资源共享：

## 线程共享的内容包括:

- 1.进程代码段
- 2.进程数据段
- 3.进程打开的文件描述符
- 4.信号的处理器、
- 5.进程的当前目录和
- 6.进程用户ID与进程组ID
- **7.堆**

## 线程独有的内容包括:

- 1.线程ID
- 2.寄存器组的值
- 3.线程的栈
- 4.错误返回码
- 5.线程的信号屏蔽码





# 进程退出

- 进程退出的时候会自动关闭自己打开的所有文件和网络连接
- 进程退出的时候**不会自动销毁共享内存**（注意不是mmap是shmget）。因为进程间通信使用的数据结构是内核级别的。创建 后由内核管理



# 孤儿进程 僵尸进程

## 孤儿进程：

一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 

**一句话总结：父进程比子进程走得早。子进程由系统接管。变成孤儿进程**

## 僵尸进程：

一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息（没有回收子进程资源），那么子进程的进程描述符（资源）仍然保存在系统中。这种进程称之为僵死进程。也就是子进程结束了父进程没结束，子进程部分PCB信息就会被悬挂。 当子进程走完了自己的生命周期后,它会执行exit()系统调用,内核释放该进程所有的资源,包括打开的文件,占用的内存等。**但是仍然为其保留一定的信息(包括进程号the process ID,退出码exit code,退出状态the terminationstatus of the process,运行时间the amount of CPU time taken by the process等),这些数据会一直保留到系统将它传递给它的父进程为止,直到父进程通过wait / waitpid来取时才释放。** 也就是说,当一个进程死亡时,它并不是完全的消失了。进程终止,它不再运行,但是还有一些残留的数据等待父进程收回。当父进程 fork() 一个子进程后,它必须用 wait() (或者 waitpid())等待子进程退出。正是这个 wait() 动作来让子进程的残留数据消失。 

- 一句话总结：如果子进程结束，父进程没有回收子进程的资源，则子进程部分PCB信息会被悬挂。如果不用wait或waitpid回收就会变成僵尸进程。因为没办法回收掉其中资源







# 主线程和子线程退出关系： 

**主线程和子线程之间没有必然的退出次序关系。主线程退出，子线程可以继续执行，也可以整体退出。；子线程退出，主线程也可以继续执行。** 程序加载到内存中执行的时候，**进程**就会生成一个**主线程**。虽然主线程和子线程之间没有必然的退出次序关系，但是**如果进程终止，那么进程下所有的线程都会终止** 

- **若想主线程在子线程前结束，并且进程不结束，就需要用到pthread_exit()函数**。按照POSIX标准定义，当主线程在子线程终止之前调用pthread_exit()时，子线程是不会退出的。 这里在main函数中调用pthread_exit()只会是主线程退出，而进程并未退出。通过调用pthread_exit函数，线程会显式终止。如果主线程调用pthread_exit，它会先终止，然后等待其他子线程终止后，进程才终止。
- 如果主线程以return的方式退出，则子线程会退出。如果主线程使用的是pthread_exit() ，实际上是提前结束了 main 的主线程，也就无法执行后续的 exit() 函数了。所以，这种方法是可以达到主线程退出子线程继续运行的目的。



# 用户空间(0-3G):进程私有,内核空间(3G-4G):所有进程共享

![QQ截图20220809045820](/assets/blog_res/2022-07-27-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3.assets/QQ%E6%88%AA%E5%9B%BE20220809045820.png)

# EXIT和return区别

## EXIT

- 是系统层级的系统调用，**指的是让进程退出**。调用后会开始进行资源的清理和回收。
- exit是一个函数

## return

- return是一个关键字，用于退出这个函数。（结束函数的执行）

## pthread_exit

所以使用pthread_exit可以维持子线程不退出的原因是，虽然主进程也是主线程，但是我只让主进程自己的线程退出，也就是不回收进程资源，相当于进程没有结束，子线程依旧可以执行。

# 线程崩溃会导致进程崩溃吗

线程崩溃会触发SIGSEGV信号。你可以让他选择不直接崩溃，捕捉信号然后继续运行。但是这个信号一般意味着很严重的错误，你也不希望有任何线程触碰到引起错误的这块。但是线程没有隔离性你也无法保证说引起错误的这块一定不会被其他线程碰到。所以一个接着一个的错误会陆续发生。所以进程崩溃是迟早的事。

# 进程有独立地址空间，线程没有。因为线程属于进程，多个线程都属于一个进程，所以互相之间共享这个地址空间。也导致没有隔离性。

