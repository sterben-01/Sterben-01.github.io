---
title: 操作系统相关
date: 2022-07-20 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true
  
---



# 进程是进程是操作系统分配资源的最小单位。线程是程序执行的最小单位。



# 进程和线程资源共享：

## 线程共享的内容包括:

- 1.进程代码段
- 2.进程数据段
- 3.进程打开的文件描述符
- 4.信号的处理器、
- 5.进程的当前目录和
- 6.进程用户ID与进程组ID
- **7.堆**

## 线程独有的内容包括:

- 1.线程ID
- 2.寄存器组的值
- 3.线程的栈
- 4.错误返回码
- 5.线程的信号屏蔽码





# 进程退出

- 进程退出的时候会自动关闭自己打开的所有文件和网络连接
- 进程退出的时候**不会自动销毁共享内存**（注意不是mmap是shmget）。因为进程间通信使用的数据结构是内核级别的。创建 后由内核管理



# 孤儿进程 僵尸进程

## 孤儿进程：

一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 

**一句话总结：父进程比子进程走得早。子进程由系统接管。变成孤儿进程**

## 僵尸进程：

一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息（没有回收子进程资源），那么子进程的进程描述符（资源）仍然保存在系统中。这种进程称之为僵死进程。也就是子进程结束了父进程没结束，子进程部分PCB信息就会被悬挂。 当子进程走完了自己的生命周期后,它会执行exit()系统调用,内核释放该进程所有的资源,包括打开的文件,占用的内存等。**但是仍然为其保留一定的信息(包括进程号the process ID,退出码exit code,退出状态the terminationstatus of the process,运行时间the amount of CPU time taken by the process等),这些数据会一直保留到系统将它传递给它的父进程为止,直到父进程通过wait / waitpid来取时才释放。** 也就是说,当一个进程死亡时,它并不是完全的消失了。进程终止,它不再运行,但是还有一些残留的数据等待父进程收回。当父进程 fork() 一个子进程后,它必须用 wait() (或者 waitpid())等待子进程退出。正是这个 wait() 动作来让子进程的残留数据消失。 

- 一句话总结：如果子进程结束，父进程没有回收子进程的资源，则子进程部分PCB信息会被悬挂。如果不用wait或waitpid回收就会变成僵尸进程。因为没办法回收掉其中资源







# 主线程和子线程退出关系： 

**主线程和子线程之间没有必然的退出次序关系。主线程退出，子线程可以继续执行；子线程退出，主线程也可以继续执行。** 程序加载到内存中执行的时候，**进程**就会生成一个**主线程**。虽然主线程和子线程之间没有必然的退出次序关系，但是**如果进程终止，那么进程下所有的线程都会终止** 若想主线程在子线程前结束，并且进程不结束，就需要用到pthread_exit()函数。按照POSIX标准定义，当主线程在子线程终止之前调用pthread_exit()时，子线程是不会退出的。 这里在main函数中调用pthread_exit()只会是主线程退出，而进程并未退出。通过调用pthread_exit函数，线程会显式终止。如果主线程调用pthread_exit，它会先终止，然后等待其他子线程终止后，进程才终止。
