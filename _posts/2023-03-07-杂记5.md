---
title: C++杂记 - 5
date: 2023-03-07 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true
---



# std::pmr 多态内存分配器

## 先回顾一下标准分配器

这一节最好搭配侯捷的标准STL内存分配器来看，这样可以很好帮助理解一些动作的行为。

**分配器的核心就是四个步骤： 分配空间（allocate），构造对象（construct），析构对象（destruct），解分配空间（deallocate）。** 

标准内存分配器就提供了这四个函数。多态内存分配器也提供了这四个函数。 

![QQ截图20230308160711](/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230308160711.png)

- 在标准分配器当中，`allocate`和`deallocate`对应的全局的`::operator new`和`::operator delete`。`construct`和`destruct`对应的就是元素的构造和析构

## 为什么要有多态内存分配器

在没有多态内存分配器的时候，我们面临两个问题。

**第一种情况是内存分配器的传播问题。**

我们有一个独特的例子：

![QQ截图20230308162015](/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230308162015.png)



- 我们有一个`CustomString`类，每一个对象接受一个`allocator`。我们现在有三个不同`allocator`的同类对象。注意此时对象类型均为`CustomString`。
- 然后我们放入`vector`。在`push_back` `x1`和`x2`的时候没什么问题，使用了对应的分配器。但是如果我们在头部插入了`x3`，情况就不对了。
- `vector`的头插逻辑是先在下一个可用位置分配一块内存，然后使用移动（拷贝）构造在新的位置构造出最后一个元素。然后再按照顺序把前面的元素搬移（拷贝）。在搬移（拷贝中），分配器是不会被拷贝（赋值）的。因为永远不该这么做，因为内存是已经被分配好了的，无法更改。
- 所以这个时候有问题了。`x1`用了`alloc2`，`x3`用了`alloc1`。瞬间混乱了起来。



**我们真正想要的是这样的东西：**

![QQ截图20230308162600](/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230308162600.png)



- 所以在C++17之前，我们有一个`std::scoped_allocator_adaptor`。我们可以把自己的分配器使用它包装，它可以保证分配器的正确传播：

> `std::scoped_allocator_adaptor` 类模板是可用于多层容器（ map 的 list 的 set 的 vector 等等）的分配器。它以外层分配器类型 `OuterAlloc` 与零或更多个内层分配器类型 `InnerAlloc...` 实例化。直接以 `scoped_allocator_adaptor` 构造的容器用 `OuterAlloc` 分配其元素，但若元素自身是容器，则它使用首个内存分配器。该容器的元素，若其自身是容器，则使用第二个内存分配器，以此类推。若容器的层级多于内层分配器的数量，则最内层分配器为所有进一步内嵌的容器再度使用。

**第二个问题是内存分配器固有的问题：**

- 针对默认内存分配器本身的性能有如下问题：

  - 内存分配、回收慢。

  - 内存分配可能有锁。

  - 内存对齐无法控制。

  - 分配位置无法控制。比如连续多次分配时，内存的定域性/局部性(locality)无法保证。

- 针对使用的参数方面有如下问题（尤其针对`std::allocator`)

  - `allocator`是模板签名的一部分。不同`allocator`的容器，无法混用。

    - ```c++
      void func(const std::vector<int>&); // Default allocator
      //上面的vector签名是：std::vector<int, std::allocator<int>>
      std::vector<int, MyAlloc<int>> v(someAlloc); // 自定义分配器
      func(v); // ERROR: v is a different type than std::vector<int>
      ```

    - 二者签名不匹配。我们尽管可以使用模板，但是这会让后面所有的函数都是模板。

  - c++11以前，`allocator`无状态；c++11以后，可以有状态，然而`allocator`类型复杂难用。

  - `allocator`内存对齐无法控制，需要传入自定义`allocator`。

  - 以上三点、特别是第一点，造成STL无法成为软件接口(interface)的一部分。

  - **难以将局部特种内存（比如共享内存），内存池用于STL容器。**







## 多态内存分配器，内存资源和容器的关系

![QQ截图20230308163419](/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230308163419.png)







`memory_resource`是获得的原始内存，我们拿到了原始内存后，通过`polymorphic_allocator`分配器来进行分配。最后容器需要使用分配器来给元素分配内存。说白了，分配器从内存资源中获得资源，然后进行内存的再分配。`polymorphic_allocator`分配器是一层`memory_resource`的包装。

- 多态内存分配器作用域下的容器是`pmr::`。其实就是别名模板。所以我们以`vector`为例：


```c++
namespace pmr {
    template< class T >
    using vector = std::vector<T, std::pmr::polymorphic_allocator<T>>;
}
```

**由于多态内存分配器把内存资源的获取和分配分离开来，所以可以保证同一个元素哪怕底层内层资源不同，但是分配器的类型可以相同。**

这部分的细节我们后面再细说。

### 再次解释一下多态内存分配器为什么解决了签名问题

**重申一下，内存资源不是类模板。而是使用了继承。所以这一部分是动态多态。所以说内存资源类型是运行时确定的。在编译期间，所有`pmr::vector<T>`类型的容器都是同一个类型。**分配器使用一个内存资源的指针在内部对内存资源进行管理。在上面的`pmr::`容器中，我们看到了多态内存分配器的模板参数是元素类型。然后我们容器已经构建完毕了。然后我们可以使用容器的构造函数传入分配器。这里用`vector`举例子：去查看[文档](https://zh.cppreference.com/w/cpp/container/vector/vector) 以第二个构造函数为例，就是接受一个分配器。

所以传入展开后会长这样：

```c++
std::vector<MyClass, std::pmr::polymorphic_allocator<MyClass> > vec = std::vector<MyClass, std::pmr::polymorphic_allocator<MyClass> >(allocator2);
```

**我们可以看到所有的模板参数都是元素类型。分配器底层的内存资源并不影响分配器的类型。因为我们重申多态内存分配器把内存资源和分配分离开来了。所以针对同一元素类型的容器，可以使用不同类型的分配器。**

![QQ截图20230309004954](/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230309004954.png)



## 内存资源 memory_resources

![image-20230308163929518](/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/image-20230308163929518.png)

- 上图是一个抽象简化版的内存资源类。我们看到里面有allocate和deallocate。这两个是非虚函数。他们的分配动作是委托给私有虚成员函数`do_allocate`和`do_deallocate`进行的。
  - **这里是模板方法模式的NVI（non-virtual-interface）技术。**

- `memory_resource`是一个抽象基类。STL给我们提供了内置的5种内存资源和一些工具函数。

  - 我们如果要自己实现自己的内存资源，也需要继承自此类。

  - > 类 `std::pmr::memory_resource` 是抽象接口，针对封装内存资源类的无界集。

- 继承自`memory_resource`的类需要实现的函数主要是四个

  - `do_allocate`
    - 从自身内存中分配特定大小的内存。
      - 具体定义会随之变化。比如从何处分配。

  - `do_deallocate`
    - 从自身内存中解分配某一特定位置，特定大小的区块。
      - 具体定义会随之变化。比如解分配到何处，是否真的解分配。

  - `is_equal`
    - 比较两个内存资源是否相等。也就是从当前这个内存资源分配的内存是否可以通过另一个内存资源解分配。

  - `release`
    - 调用上游的deallocate来释放内存。将全部内存交还给上游内存分配器。

- **内存资源是可以成为链条的。这一点我们下面讲。**

- **注意内存资源类不是类模板！！！**

### std::pmr::new_delete_resource

这是最基础的，也是默认的内存资源。它是从哪儿获取的原始内存呢？答案是从全局的`::operator new`

> 返回指向使用全局 [operator new](https://zh.cppreference.com/w/cpp/memory/new/operator_new) 与 [operator delete](https://zh.cppreference.com/w/cpp/memory/new/operator_delete) 分配内存的 `memory_resource` 的指针。

- **allocate**
  - 因为这是默认的选项，所以非常自然地，内存的分配会使用`::operator new`
- **deallocate**
  - 既然分配的都用默认的了，那么解分配也是会用到`::operator delete`

**一般来说，上游分配器都是它。默认也是它。**

### std::pmr::monotonic_buffer_resource

- 这是一个比较特殊的资源。它特殊就特殊在我们可以使用栈内存做为内存资源。如使用`char buffer[1024]`来获取一段栈内存做为原始内存。**它是一种单调递增的资源。它仅在销毁资源时释放分配的内存。它的意图是提供非常快速的内存分配，在内存用于分配少量对象，并于之后一次释放的情况下。**
  - **因为它的原理仅仅是推指针。所以分配速度非常快。属于一块线性内存。**
- **构造函数**

```c++
monotonic_buffer_resource(); 											//(1)
explicit monotonic_buffer_resource(std::pmr::memory_resource* upstream);	//(2)
explicit monotonic_buffer_resource(std::size_t initial_size);				//(3)
monotonic_buffer_resource(std::size_t initial_size, std::pmr::memory_resource* upstream);			//(4)
monotonic_buffer_resource(void* buffer, std::size_t buffer_size);			//(5)
monotonic_buffer_resource(void* buffer, std::size_t buffer_size, std::pmr::memory_resource* upstream);//(6)
monotonic_buffer_resource(const monotonic_buffer_resource&) = delete;		//(7)
```

> `monotonic_buffer_resource` 能以初始缓冲区构造，若无初始缓冲，或缓冲用尽，则从构造时提供的*上游分配器*分配缓冲区。缓冲区的大小以几何级数增长。

比较常用的有1,2,5,6

- 第一个就是默认构造函数。默认构造函数会使用`std::pmr::get_default_resource`返回的`memory_resource `当做上游分配器。

- 第二个就是指定上游分配器。

- 第五个是提供一块给定内存`buffer`，然后设置当前资源为`buffer`。`buffer_size`是下一块缓冲区的大小，然后使用`std::pmr::get_default_resource`返回的`memory_resource `当做上游分配器。
  - 当给定的内存用尽后，使用上游分配器进行内存分配。

- 第六个是提供一块给定内存`buffer`，然后设置当前资源为`buffer`。`buffer_size`是下一块缓冲区的大小，并且指定上游分配器。

  - 当给定的内存用尽后，使用上游分配器进行内存分配。

- **do_allocate**

  - >**若当前缓冲区有足够的未使用空间以适合一个拥有指定大小和对齐的块，则从当前缓冲区分配返回的块。**
    >
    >**否则，此函数通过调用 `upstream_resource()->allocate(n, m)` 分配新缓冲区**，其中 `n` 不小于`bytes` 与*下个缓冲区大小*的较大者，且 `m` 不小于 `alignment` 。它设置新缓冲区为*当前缓冲区*，以实现定义的增长因子（不必是整数）增加*下个缓冲区大小*，然后从新分配的缓冲区分配返回块。

  - 插一句话，这个时候就是使用`std::pmr::null_memory_resource`的一个典型场景

- **do_deallocate**

  - **此函数无效应。！！！啥也不干！！！因为我们都说了它是单调递增的！！！直到销毁资源为止（对象析构或调用release）**

- **release**

  - >**通过上游 memory_resource 的 `deallocate` 函数，按需要释放所有分配的内存。**重设*当前缓冲区*及*下个缓冲区大小*为其构造时的初始值。
    >
    >内存被释放回上游资源，即使未对某些被分配块调用 `deallocate` 。

  - 释放内存。注意，这是调用**上游**`deallocate`解分配。**解分配不代表调用内存中储存对象的析构函数。仅仅是把指针塞回给上游内存池。**

    - 如果上游是`null_memory_resource`，那就相当于啥也没干。**同时，一般来说使用这种方式分配内存的时候，初始缓冲区一般是在栈上。如果在堆上，记得要手动回收提供的初始内存。因为这些内存资源不会帮助我们回收初始内存资源。所谓的：重设当前缓冲区及下个缓冲区大小为其构造时的初始值 的含义仅仅是把指针推回去。**
    - 内存被释放回上游资源，即使未对某些被分配块调用 `deallocate` 。这句话每一个内存资源的`release`都有。我们下面再说。

  源代码，[来自](https://reviews.llvm.org/D47090) 

  ```c++
  void monotonic_buffer_resource::release()
  {
      const size_t header_size = sizeof(__monotonic_buffer_header);
  
      __original_.__used_ = 0;
      while (__original_.__next_ != nullptr) {
          __monotonic_buffer_header *header = __original_.__next_;
          __monotonic_buffer_header *next_header = header->__next_;
          size_t aligned_capacity = header->__capacity_ + header_size;
          __res_->deallocate(header->__start_, aligned_capacity, header->__alignment_); //调用上游分配器的deallocate
          __original_.__next_ = next_header;
      }
  }
  //除了那一行以外其他的就是回推指针。
  ```

- **析构函数**
  - 调用`this->release() `来解分配此资源拥有的所有内存。
    - 所以说针对这几种内存资源，压根没必要`release`。因为已经应用了RAII特性。

**测试**

我们下面的测试是单纯的测试内存分配器。并没有结合容器。但是效果是一致的。

```c++
class MyClass {
public:
    MyClass(int val = 0) : m_val(new int(val)) {
        std::cout << "MyClass constructed with value: " << val << std::endl;
    }
    ~MyClass() {
        std::cout << "MyClass destroyed with value: " << *m_val << std::endl;
        delete m_val;
    }
private:
    int* m_val;
};
int main() {
    char buffer[1024]; //从栈获取原始内存
    std::size_t buffer_size = sizeof(buffer); 
    cout << "original "<<&buffer << endl; //原始内存地址
    {
        std::pmr::monotonic_buffer_resource buffer_resource{buffer, buffer_size, std::pmr::null_memory_resource()};
        //monotonic memory resource使用栈获取的资源做为初始资源，使用null_memory_resource当做上游分配器强调内存用尽后抛出bad_alloc而不是从默认分配器分配
        std::pmr::polymorphic_allocator<MyClass> allocator{ &buffer_resource }; //初始化分配器
        {
            MyClass* t = allocator.allocate(1); //分配1个Myclass对象 8字节
            cout << &t << endl; //获取指针地址
            cout << "1st alloc place "<<&*t << endl; //获取当前分配地址
            allocator.construct(t, 20); //在该地址构造元素

            MyClass* tt = allocator.allocate(1); //再分配1个Myclass对象 8字节
            cout << &tt << endl; //获取指针地址
            cout << "2nd alloc place  "<<&*tt << endl; //获取当前分配地址
            allocator.construct(tt, 30); //在该地址构造元素
//------------如果不destroy会泄露。因为deallocate解分配并不会调用元素的析构函数---------
            allocator.destroy(t); //析构元素
            allocator.destroy(tt); //析构元素
//----------使用release重置内存，把首地址推回分配起始地址（原始内存首地址）           
            buffer_resource.release();
            
            MyClass* ttt = allocator.allocate(1); //再次分配1个Myclass对象
            cout << &ttt << endl;//获取指针地址 
            cout << "3rd alloc place  "<<&*ttt << endl; //获取当前分配地址
            allocator.construct(ttt, 40);  //在该地址构造元素
            allocator.destroy(ttt);  
        }
    }
    return 0;
}

```

```
original 0x7ffe4ff6eb90 起始地址
0x7ffe4ff6eb30
1st alloc place 0x7ffe4ff6eb90 起始地址和第一次分配地址一致
MyClass constructed with value: 20
0x7ffe4ff6eb38
2nd alloc place  0x7ffe4ff6eb98 第二次分配在第一次分配上+8
MyClass constructed with value: 30
MyClass destroyed with value: 20
MyClass destroyed with value: 30
0x7ffe4ff6eb40
3rd alloc place  0x7ffe4ff6eb90 release后指针推回至原生内存起始位置。
MyClass constructed with value: 40
MyClass destroyed with value: 40
```

- 我们从上面的测试能看到
  - 如果不`destroy`会导致内存泄露。因为`deallocate`解分配并不会调用内存中元素的析构函数，仅仅是回推指针。
  - 如果不需要重复使用内存，则无需手动调用`release`。RAII特性会让`buffer_resource`内存资源在析构时自动调用`release`
  - 注意：我们是使用`allocator`进行内存分配，对象构造和对象摧毁。

- 假设我们的初始内存是从堆中获取的，则必须要手动释放。因为分配器和内存资源并不保有底层原始内存

```c++
char* buffer = new char[1024]; //堆内存。
std::size_t buffer_size = 1024;
{
    std::pmr::monotonic_buffer_resource buffer_resource{buffer, buffer_size, std::pmr::null_memory_resource()};
    std::pmr::polymorphic_allocator<MyClass> allocator{ &buffer_resource };
    {
        //...
    }
}
delete[] buffer; //回收内存
```

分析一下`release`过程。无论是析构还是手动调用`release`，都有两个步骤：第一步是调用上游的`memory_resource` 的 `deallocate` 函数。第二步是重设当前缓冲区及下个缓冲区大小为其构造时的初始值。当前我们上游是`null_memory_resource`，`deallocate`函数无效果。所以仅仅是把当前缓冲区及下个缓冲区大小为其构造时的初始值。（推回指针）



### std::pmr::unsynchronized_pool_resource / std::pmr::synchronized_pool_resource

**这是一种池化的内存资源：**

![QQ截图20230308173021](/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230308173021.png)

具体应该不用赘述。侯捷老师的课讲标准分配器的时候就提到过大概的样子。

- 这俩唯一的区别是一个线程安全，一个线程不安全。线程安全的性能贼差尽量别用。

> - **它占有被分配内存并在析构时释放它，即使 `deallocate` 未被对于某些被分配块调用。**
>   - 这个释放是指调用`release`。`release`中调用上游 memory_resource 的 `deallocate` 函数，释放所有此资源所占有的内存。
>
> - **它由供应不同块大小请求的池的汇集组成。每个池管理之后被分入一致大小的大块的汇集。**
> - **对 `do_allocate`的调用被派发到供应适应请求大小的最小块的池。**
> - **在池中耗尽内存，会导致该池从上游分配器分配额外的内存大块，以填满池。获取的大块大小以几何级数增加。**
> - 请求超出最大的块大小的分配，由上游分配器直接供应。
> - 最大的块大小和大块大小的最大值可通过传递`std::pmr::pool_options`结构体给其构造函数调节。



- **构造函数**

```c++
unsynchronized_pool_resource(); //(1)
explicit unsynchronized_pool_resource(std::pmr::memory_resource* upstream); //(2)
explicit unsynchronized_pool_resource(const std::pmr::pool_options& opts); //(3)
unsynchronized_pool_resource(const std::pmr::pool_options& opts,std::pmr::memory_resource* upstream); //(4)
unsynchronized_pool_resource(const unsynchronized_pool_resource&) = delete; //(5)
```

**有没有发现这一组构造函数和`monotonic_buffer_resource`有个非常明显的差别？也就是我们不再有像`monotonic_buffer_resource`第5和第6个构造函数那种提供初始原始内存的构造函数了。也就是说这两个池化内存资源必须从上游分配器获取资源。**

如果依旧想要从栈分配，则可以先使用栈分配`monotonic_buffer_resource`，然后让它成为当前池化内存的上游分配器。

第一个构造函数就是使用默认的池化选项和默认的上游分配器。

第二，三，四个分别指定上游分配器，池化选项和二者皆指定。



- **do_allocate**

  - > 若为 `bytes` 大小的块所选的池不足以满足来自其内部数据结构的请求，则调用上游 memory_resources 上的 `allocate()` 以获得内存。
    >
    > **若请求的大小大于最大的池所能处理者，则通过调用上游 memory_resources 上的 `allocate()` 分配内存。**


- **do_deallocate**

  - >  将在 `p` 的内存返还到池。**此操作是否或在何种场合下导致对上游 memory_resource 上的 `deallocate()` 调用是未指定的。**

  - 在对池化资源使用`do_deallocate`的时候一定要仅返回内存至内存池，而不是调用上游分配器的`deallocate`直接回收。一定要格外注意。但是这一点平时普通人不需要过多操心


- **release**

  - > 需要时，通过调用上游 memory_resource 的 `deallocate` 函数，释放所有此资源所占有的内存。
    >
    > 即使未对某些被分配块调用 `deallocate` ，资源也被返还给上游 memory_resource 。

  - 这就是`release`和`deallocate`的最大区别。`deallocate`是返还内存到内存池。而`release`是释放（返还）整个内存池全部的内存至上游分配器。因为是调用上游分配器的`deallocate`。
  - **不知道这玩意是只释放内存还是摧毁整个池。标准库没说**
  
- **析构函数**


  - 通过调用 `this->release()` 释放此资源所拥有的所有内存。

    - 和其他的一样。


### 我们捋一下针对池化内存release的可能情况

- 第一种情况：
  - 如果`sync`或`unsync`的上游分配器是`monotonic`，`sync`或`unsync`调用`release`会使上游的`monotonic`调用`deallocate`。但是`monotonic`的`deallocate`不做任何事情。所以分配出去的内存无法被`monotonic`回收。只能单调递增直到`monotonic`的`release`被调用
- 第二种情况：
  - 如果`sync`或`unsync`的上游是`new_delete_resource`，则`sync/unsync`调用`release`会使得上游的`new_delete_resource`调用其`deallocate`，我们说过它的`deallocate`是全局`::operator delete`。

###  在已经release的内存资源上再次调用allocate是否是UB？

标准库没有明确说明。例子如下：

```c++
std::pmr::monotonic_buffer_resource buffer_resource{std::pmr::new_delete_resource()}; //最外层monotonic通过new_delete获取原始内存。
std::pmr::unsynchronized_pool_resource midlevel{&buffer_resource}; //第一层unsync池化
std::pmr::unsynchronized_pool_resource un_sync{&midlevel}; //第二层unsync 池化
std::pmr::polymorphic_allocator<MyClass> allocator{&un_sync};
{
    MyClass* t = allocator.allocate(1);
    cout << &t << endl;
    cout << "1st alloc place "<<&*t << endl;
    allocator.construct(t, 20);

    MyClass* tt = allocator.allocate(1);
    cout << &tt << endl;
    cout << "2nd alloc place  "<<&*tt << endl;
    allocator.construct(tt, 30);

    allocator.destroy(t);
    allocator.destroy(tt);

    un_sync.release(); //release内存资源。此行为会导致第一层unsync调用deallocate。回收已分配的内存到第一层unsync的内存池

    MyClass* ttt = allocator.allocate(1); //第二层unsync再次allocate
    cout << &ttt << endl;
    cout << "3rd alloc place  "<<&*ttt << endl;
    allocator.construct(ttt, 40);
    allocator.destroy(ttt);
}
```

```
0x7ffe69b80ed8
1st alloc place 0x559e13abbc00 //第一次分配
MyClass constructed with value: 20
0x7ffe69b80ee0
2nd alloc place  0x559e13abbc08 //第二次分配
MyClass constructed with value: 30
MyClass destroyed with value: 20
MyClass destroyed with value: 30
释放
0x7ffe69b80ee8
3rd alloc place  0x559e13abbc00 //第三次分配。地址同第一次。
MyClass constructed with value: 40
MyClass destroyed with value: 40
```

**经过我的测试，似乎是会重建内存池。**

已提问，目前无人[回答](https://stackoverflow.com/questions/75680593/call-allocate-again-on-the-released-unsynchronized-pool-resource-is-an-undefin)



### std::pmr::null_memory_resource

- 很多人很奇怪？为啥要弄个空的呢？答案很简单。我们提到了，内存资源可以成为链条。如果某一个分配资源不够了，我们不希望它去默认的上游分配器去获取内存，就可以把这个分配器做为那个分配器的上游分配器。

- allocate

  - > - 其 `allocate()` 函数始终抛出 std::bad_alloc；

- deallocate

  - 其 `deallocate()` 函数无效果；



## 分配器 allocator

我们提到过。分配器是一种对内存资源的包装

![QQ截图20230309000840](/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230309000840.png)

![QQ截图20230309004214](/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230309004214.png)

- 第二个转换构造函数非常有用。它的作用是我们可以直接把`memory_resource`传入任何需要`polymorphic_allocator`的地方。比如直接传入`pmr::`容器。

- **构造函数**

```c++
polymorphic_allocator() noexcept; //(1)
polymorphic_allocator( const polymorphic_allocator& other ) = default; //(2)
template< class U > 
polymorphic_allocator( const polymorphic_allocator<U>& other ) noexcept; //(3) 关键的构造函数模板。
polymorphic_allocator( memory_resource* r); //(4) 转换构造
```

第一个：默认构造函数会默认构造一个以默认值（通常为`new_delete_resource`）为内存资源的分配器

第二个：拷贝构造

**第三个：构造函数模板。下面的模板参数以及正确转换全都靠它**

第四个：是上文提到的转换构造。

- **allocate**

  - > 用底层的 memory_resource 分配 `n` 个 `T` 类型对象的存储。
    >
    > 等价于 `return static_cast<T*>(resource()->allocate(n * sizeof(T), alignof(T)));` 。

  - 由于我们提过，分配器是一种内存资源的wrapper。所以分配器调用的`allocate`就相当于对内存资源调用`allocate`。

  - 格外要注意的是，内存资源返回的内存是`void*`。而分配器返回的内存是对应类型的。

- **deallocate**

  - > 解分配 `p` 所指向的存储，它必须通过与 `*resource()` 比较等于的（相等的）`std::pmr::memory_resource` `x` 使用 `x.allocate(n * sizeof(T), alignof(T))` 分配。
    >
    > 等价于 `this->resource()->deallocate(p, n * sizeof(T), alignof(T));`

  - 还是调用了底层内存资源的`deallocate`

- **construct**

  - 这玩意有一堆重载。主要是看第一个：

    - ```c++
      template < class U, class... Args >
      void construct( U* p, Args&&... args ); //(1)
      ```

    - > 在 `p` 所指的，分配但未初始化的存储上，以提供的构造函数参数构造一个对象。**若对象自身拥有使用分配器的类型，或它是 `std::pair` ，则传递 `this->resource()` 给被构造的对象。**

    - > 以[使用分配器构造](https://zh.cppreference.com/w/cpp/memory/uses_allocator#.E4.BD.BF.E7.94.A8.E5.88.86.E9.85.8D.E5.99.A8.E6.9E.84.E9.80.A0)的手段在 `p` 所指示的未初始化内存位置，以 `*this` 为分配器创建给定类型 `U` 的对象。

  - 说白了就如果提供了分配器，就使用提供的分配器构造。

- **destroy**

  - >  销毁 `p` 所指向的对象，如同以调用 `p->~U()` 

  - 所以我们强调了，`dellocate`解分配不调用内存位置上元素的析构函数。摧毁元素和回收内存是两个独立动作。

## polymorphic_allocator 的模板参数

有一些讲座说我们应该始终以`std::byte`为`polymorphic_allocator `的模板参数。但是直觉来说，应该以元素类型为模板参数。

```c++
class MyClass {
public:
    MyClass(int val = 0) : m_val(new int(val)) {
        std::cout << "MyClass constructed with value: " << val << std::endl;
    }
    ~MyClass() {
        std::cout << "MyClass destroyed with value: " << *m_val << std::endl;
        delete m_val;
    }
private:
    int* m_val;
};
int main() {
    char buffer[1024];
    std::size_t buffer_size = 1024;
    {
        std::pmr::monotonic_buffer_resource buffer_resource{buffer, buffer_size, std::pmr::null_memory_resource()};
        //monotonic内存资源从已分配栈内存做为初始资源。并使用null做为上游资源
        std::pmr::polymorphic_allocator<MyClass> allocator{ &buffer_resource }; //版本1，分配器参数为元素类型：MyClass
        std::pmr::polymorphic_allocator<byte> allocator{ &buffer_resource }; //版本2，分配器参数为byte。
        {
            std::pmr::vector<MyClass> vec(allocator); //使用分配器初始化pmr vector
            vec.reserve(1);//预留一个空间
            vec.emplace_back(1);//原地构造一个对象
        }
    }
    return 0;
}

```

```c++
MyClass constructed with value: 1
MyClass destroyed with value: 1
```

- 注意关于monotonic内存资源和winkout的联系会在下一节讲。但是这里必须要提到一点，winkout和使用何种内存资源之间无任何联系。

两种分配器参数都可以正常工作。那么是什么原因呢？我们看一下这一行代码：

```c++
std::pmr::polymorphic_allocator<MyClass> allocator{ &buffer_resource };
std::pmr::vector<MyClass> vec(allocator); //此行展开
```

这一行代码展开后的样子是这样的：

```c++
std::vector<MyClass, std::pmr::polymorphic_allocator<MyClass>> vec = std::vector<MyClass, std::pmr::polymorphic_allocator<MyClass>>(allocator);
```

首先记住一点：`allocator`的模板参数一定会被推导为元素类型。因为别忘了上面提到的`pmr`是别名模板，元素类型是`T`，`allocator`的类型是根据`T`来的。

其次，我们发现如果分配器类型和元素类型一致，则顺利构造。左右两侧无区别。

但是如果我们换成`byte`呢？

```c++
std::pmr::polymorphic_allocator<byte> allocator{ &buffer_resource };
std::pmr::vector<MyClass> vec(allocator); //此行展开
```

这一行展开后是这样的：

```c++
std::vector<MyClass, std::pmr::polymorphic_allocator<MyClass>> vec = std::vector<MyClass, std::pmr::polymorphic_allocator<MyClass>>(std::pmr::polymorphic_allocator<MyClass>(allocator));
```

再次重申，`allocator`的模板参数一定会被推导为元素类型。同时，右侧括号内传入的分配器发生了隐式类型转换。调用的正是我们在分配器中提到的第三个构造函数。

**所以理论上讲，此时行为都是一致的。而分配器本身的构造并不会造成性能的过多损失。但是有一点要注意，隐式类型转换后，传入的分配器是那个转换后的临时对象。所以现在`vector`内部的分配器和外面传入的`allocator`其实是两个独立对象了。一定要注意。最好还是使用和元素一样类型的分配器。**

我的[提问](https://stackoverflow.com/questions/75669627/what-is-the-usage-of-the-template-parameter-of-the-stdpmrpolymorphic-allocat)



## 分配器种类，分配器绑定方式和析构的组合

**目前为止，分配器绑定方式可以分为两种**

- 类型参数（模板参数）
- 继承自抽象基类，比如：
  - ![QQ截图20230309225735](/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230309225735.png)
  
  - 注意这里不是继承自`std::allocator`。一般也不应该这样做。原因见[这里](https://stackoverflow.com/questions/21081796/why-not-to-inherit-from-stdallocator)
  
  - ![QQ截图20230310032548](/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230310032548.png)





**目前为止，分配器内存来源可以分为这么几种**

- 默认全局分配器（std::allocator)
  - 绑定方式一定是类型参数
- New_Delete_Allocator
  - 和默认全局分配器原理一致，但是绑定方式一定是继承自抽象基类

- 多态内存资源
  - 如`monotonic_buffer_resource`，`unsync/synchronized_pool_resource`等

**析构方式又可以分为两种：**

- 常规析构
- wink-out

所以，一共我们可以得到这么多种搭配组合

![QQ截图20230309225948](/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230309225948.png)

## wink-out 和 常规析构

首先注意，wink-out适用于任何内存资源。**我们还记得容器分配构造的四个步骤：分配空间，构造对象，析构对象，解分配空间。**

wink-out就是不析构，直接解分配。所以使用wink-out的时候一定要注意，如果内存区域的元素是含有额外资源的，则不可以winkout。会导致内存泄漏。

- **我们看一下常规析构：**

![QQ截图20230309234908](/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230309234908.png)

一切都很正常。标准的四个步骤。

- **我们再来看一下所谓的winked-out**

![QQ截图20230310023351](/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230310023351.png)

核心意思就是我们不再需要析构和解分配两个步骤

不需要析构非常好理解，因为如果某些对象没有保有其他资源，也就是析构函数是trivial的时候，调用析构是没有意义的。所以可以不调用这些析构。

不需要`deallocate`如何理解呢？一般情况下，通常只针对`monotonic_buffer_resource`使用winkout。因为它的`deallocate`是无作用。只有在析构的时候才会把资源交还给上游分配器。当然了，标准库提供的所有内存资源都符合RAII特性，在析构的时候都会把内存交还给上游分配器。所以这里不使用`deallocate`也是可以的。**一定要记住，所有解分配`deallocate`都不会调用元素的析构函数**。所以要注意内存泄漏问题，使用这个技巧之前一定要清楚自己在做什么。

我们来看个特殊例子，因为有时候容易错误理解：

```c++
int main() {
    char buffer[1024];
    std::size_t buffer_size = 1024;
    {

        std::pmr::monotonic_buffer_resource buffer_resource{buffer, buffer_size, std::pmr::null_memory_resource()};
        //外层monotonic原始内存
        std::pmr::polymorphic_allocator<MyClass> allocator{ &buffer_resource }; //分配器
        {
            std::pmr::vector<MyClass> t(allocator); //分配器传入pmr vector
            t.reserve(1); //预留1个位置
            t.emplace_back(20); //原地构造元素
        }
    }
    return 0;
}
```

```c++
MyClass constructed with value: 20
MyClass destroyed with value: 20
```

奇怪？明明我们没有手动对内存资源进行操作，怎么会正确析构呢？因为这是`pmr::vector`帮助我们做的。因为它毕竟还是`vector`。还是会在`vector`被销毁的时候帮助我们对元素进行析构。

> `std::vector<T,Allocator>::~vector`：调用元素的析构函数，然后解分配所用的存储。





**针对如何实现内存资源，和如何实现使用多态内存分配器的容器，可以看看下面参考资料的内容**

## 参考资料

[CppCon 2017针对如何实现内存资源和自己的使用分配器的容器](https://youtu.be/v3dz-AKOVL8)

[CppCon 2019针对如何实现带有多态内存分配器的类和容器类](https://youtu.be/RLezJuqNcEQ)

[CppCon 2017理解并测试分配器](https://youtu.be/nZNd5FjSquk)

[游戏引擎新感觉](https://zhuanlan.zhihu.com/p/96089089)

[CSDN的pmr](https://blog.csdn.net/audi2/article/details/118252089)

[分配器，内存资源，容器的关联](https://blog.feabhas.com/2019/03/thanks-for-the-memory-allocator/)

[polymorphic allocator的模板参数](https://stackoverflow.com/questions/75669627/what-is-the-usage-of-the-template-parameter-of-the-stdpmrpolymorphic-allocat)

[如何测试wink-out](https://stackoverflow.com/questions/74012811/what-is-the-difference-between-magically-winked-out-and-monotonic)

[memory_source的LLVM源代码](https://reviews.llvm.org/D47090) 和 [LLVM最终源代码](https://fossies.org/linux/gcc/libstdc++-v3/src/c++17/memory_resource.cc)



# 反射

反射的核心目的是根据一个类名来生成对应的实例。也就是**如何通过类名称字符串来生成类的对象。比如有一个类`ClassA`，那么如何通过类名称字符串`ClassA`创建类的对象呢？**比如

```c++
class Person {
public:
   virtual void show() = 0;
}

class Allen : public Person {
  virtual void show() {
    std::cout << "Hello, I'm Allen!" << std::endl;
  }
}
std::string className = /*从配置文件中读取*/
Person *p = getNewInstance<Person>(className);
```

但是C++不像java或者C#一样提供这种机制。但是我们可以通过工厂模式+单例模式+映射器+宏来实现一个反射



一般来说，实现反射需要如下几个组件（步骤）：

- 我们的业务代码，也就是需要被反射的类。这个类通常继承自一个反射基类如`ReflectObject`。
  - 这个步骤的目的是为抽象对象工厂类`ObjectFactory`提供统一的接口
- 一个抽象对象工厂类`ObjectFactory`
- 具体对象工厂类
  - 一般情况下使用宏
- 反射器
  - 通常情况下，反射器可以是单例。
  - 反射器的核心是建立字符串（标识符）到回调函数的映射。然后通过一个容器储存。
  - 在我们即将展示的例子中，这个回调函数是一个具体对象工厂的指针。然后我们会通过这个具体对象工厂来创建具体对象。



**下面我们看代码**

- 反射基类`ReflectObject`。所有实现反射的类都需要继承自它。

```c++
class ReflectObject { 
public:
	virtual ~ReflectObject(){}
};
```

- 具体的被反射类

```c++
class Person : public ReflectObject{
public:
	Person(){
        std::cout << "Person()" << std::endl;
    }
	virtual ~Person(){
        std::cout << "~Person()" << std::endl;
    }
	virtual void show(){
        std::cout << "Hello, I'm person" << std::endl;
    }
};

class Miku : public Person{
public:
	Miku(){
        std::cout << "Miku()" << std::endl;
    }
	virtual ~Miku(){
        std::cout << "~Miku()" << std::endl;
    }
	virtual void show(){
        std::cout << "Hello, I'm Miku" << std::endl;
    }
};

class Animal : public ReflectObject{
public:
	Animal(){
        std::cout << "Animal()" << std::endl;
    }
	virtual ~Animal(){
        std::cout << "~Animal()" << std::endl;
    }
	virtual void bark(){
        std::cout << "animal bark" << std::endl;
    }
};

```

- 抽象对象工厂`ObjectFactory`

```c++
class ObjectFactory {
public:
	ObjectFactory(){ std::cout << "ObjectFactory()" << std::endl; }
	virtual ~ObjectFactory(){ std::cout << "~ObjectFactory()" << std::endl; }
	virtual ReflectObject* newInstance() = 0; //提供统一的纯虚函数，返回反射基类的指针。也就是说，所有的具体对象工厂类都要通过这个函数返回具体对象并被转化为反射基类的指针
};
```

- 反射器Reflector
  - 此处我们以单例模式呈现。

```c++
class Reflector
{
public:
    static Reflector& reflector(); //mayer’s单例模式经典方法
    Reflector(const Reflector&) = delete; //禁止拷贝构造
    Reflector& operator= (const Reflector&) = delete; //禁止拷贝赋值
	void registerFactory(const std::string& className, ObjectFactory* function); //注册至映射map

	ReflectObject* getNewInstance(const std::string& className); //在映射器内查找类名对应的对象工厂指针。然后通过该指针调用该对象工厂对应的创建实例的函数。此处是newInstance
private:
    Reflector(); //私有构造
	~Reflector(); //私有析构
	std::map<std::string, ObjectFactory*> objectFactories; //映射map。key是类名，value是该类的对象工厂指针。
};
Reflector::Reflector(){
    std::cout << "Reflector constructor" << std::endl;
}
Reflector::~Reflector(){
    //析构函数中释放资源。在当前业务中，反射器的映射map负责保有所有的具体对象工厂指针。所以需要负责释放。
	std::map<std::string, ObjectFactory*>::iterator it = objectFactories.begin();
	for (; it != objectFactories.end();++it){
		delete it->second;
	}
	objectFactories.clear();
}

void Reflector::registerFactory(const std::string& className, ObjectFactory *of){
    //注册函数。首先在map中查找是否有对应的键值，如果没有则创建一个 名称-对象工厂指针 的映射
	std::map<std::string, ObjectFactory*>::iterator it = objectFactories.find(className);
	if (it != objectFactories.end()) {
		std::cout << "该类已经存在" << std::endl;
	}
	else {
		objectFactories[className] = of;
	}
}
ReflectObject* Reflector::getNewInstance(const std::string& className){
    //通过类名获取对象工厂的指针，然后调用对象工厂的创建具体实例的方法并返回。
	std::map<std::string, ObjectFactory*>::iterator it = objectFactories.find(className);
	if (it != objectFactories.end()) {
		ObjectFactory *of = it->second; 
		return of->newInstance(); //如果找到了。那么调用这个对象工厂指针的创建具体实例的方法。
	}
	return NULL;
}
Reflector& Reflector::reflector() {
    //经典的mayer‘s单例模式
    std::cout <<"get reflector reference " << std::endl;
    static Reflector reflector;
    return reflector;
}

/*
这是个非常特殊的地方。我们有一个全局函数模板。外部调用的是这个函数。
这个函数是我们的反射器的包装。传入一个具体被映射类名字，同时将其做为模板参数。
该函数内部会先获取单例的反射器的实例，然后通过该实例调用内部的getNewInstance成员函数。
由于调用返回的是ReflectObject*指针，但是通常我们等号左侧调用的时候会是当前类型或者是实际父类，所以需要强转一下。
*/
template<typename T, typename... Args>
T* getNewInstance(const std::string& className) {
	return static_cast<T*>(Reflector::reflector().getNewInstance(className));
}
```

- 具体对象工厂

```c++
class ObjectFactory_Miku: public ObjectFactory{ //继承自反射基类
    public:
    	ObjectFactory_Miku(){
            std::cout <<"ObjectFactory_Miku() " << std::endl;
        }
        ReflectObject* newInstance(){ //实现创建实例的接口。
            return new Miku();
        };
};
```

- 主函数

```c++
int main(){
    Reflector::reflector().registerFactory("Miku", new ObjectFactory_Miku());
	Person *allen = getNewInstance<Miku>("Miku");
	allen->show();
	delete allen;
	return 0;
}
/*
get reflector reference  获取反射器实例
Reflector constructor 反射器创建且只创建一次
ObjectFactory() new的对象工厂类的父类部分
ObjectFactory_Miku() new的对象工厂类子类部分
---以上是第一行的注册部分------
get reflector reference  第二行的getnewinstance内部调用的获取反射器实例。
Person() 反射器实例调用的getnewinstance找到的对象工厂指针调用的newInstance导致的Miku类的父类部分创建
Miku() //miku类本类创建
Hello, I'm Miku //show 业务代码
~Miku()
~Person()
~ObjectFactory()
*/
```



这时候我们发现，写对象工厂类和注册比较麻烦，我们可以用一个宏来实现

```c++
#define REFLECT(name)\
class ObjectFactory_##name : public ObjectFactory{\
public:\
	ObjectFactory_##name(){ std::cout << "ObjectFactory_" << #name << "()" << std::endl; }\
	virtual ~ObjectFactory_##name(){ std::cout << "~ObjectFactory_" << #name << "()" << std::endl; }\
	ReflectObject* newInstance() {\
		return new name(); \
	}\
}; \
Reflector::reflector().registerFactory(#name, new ObjectFactory_##name());
```

宏的部分语法我们在杂记4中提到过，这里不赘述

这样我们可以直接`REFLECT(Animal)`就完成了创建对象工厂和注册

也可以考虑使用一个额外的类和全局对象的方式替换最后一行

```c++
class Register_##name{\
public:\
	Register_##name(){\
		Reflector::reflector().registerFactory(#name, new ObjectFactory_##name()); \
	}\
};\
Register_##name register_##name;
```

我目前不清楚有什么好处，可能和链接有关？因为全局对象的构造函数在`main`前执行。



上面的代码我们梳理了最基本的反射原理和实现，参考自[这里](https://blog.csdn.net/q1007729991/article/details/56012253)。现在有一个问题。如果我的类需要使用有参构造函数怎么办？可以使用可变模板参数。但是导致复杂非常多。我找到了Nebula的一种实现方式，参考自[这里](https://zhuanlan.zhihu.com/p/40134288)，我们一起分析一下。



```c++
#include <string>
#include <iostream>
#include <typeinfo>
#include <memory>
#include <unordered_map>
#include <functional>
#include <cxxabi.h>

namespace neb{
    class Actor{ //*理解为反射基类 reflectobject
    public:
        Actor(){std::cout << "Actor construct" << std::endl;}
        virtual ~Actor(){};
        virtual void Say()
        {
            std::cout << "Actor" << std::endl;
        }
    };

    template<typename ...Targs>
    class ActorFactory{  //*理解为反射器类。此处是单例模式
    public:
        //typedef Actor* (*ActorCreateFunction)();
        //std::function< Actor*(Targs...args) > pp;

        static ActorFactory* Instance(){  //! 线程不安全的单例模式。获取反射器指针。
            std::cout << "static ActorFactory* Instance()" << std::endl;
            if (nullptr == m_pActorFactory){
                m_pActorFactory = new ActorFactory();
            }
            return(m_pActorFactory);
        }

        virtual ~ActorFactory(){};

        //Lambda: static std::string ReadTypeName(const char * name)

        //bool Regist(const std::string& strTypeName, ActorCreateFunction pFunc)
        //bool Regist(const std::string& strTypeName, std::function<Actor*()> pFunc)
        /*
        
        &将“实例创建方法（对象工厂的CreateObject方法）”注册到ActorFactory，注册的同时赋予这个方法一个名字“类名”，后续可以通过“类名”获得该类的“实例创建方法”。
        &这个实例创建方法实质上是个函数指针，在C++11里std::function的可读性比函数指针更好，所以用了std::function。
        */
        bool Regist(const std::string& strTypeName, std::function<Actor*(Targs&&... args)> pFunc){
            std::cout << "bool ActorFactory::Regist(const std::string& strTypeName, std::function<Actor*(Targs... args)> pFunc)" << std::endl;
            if (nullptr == pFunc){
                return(false);
            }
            std::string strRealTypeName = strTypeName;
            //[&strTypeName, &strRealTypeName]{int iPos = strTypeName.rfind(' '); strRealTypeName = std::move(strTypeName.substr(iPos+1, strTypeName.length() - (iPos + 1)));};

            bool bReg = m_mapCreateFunction.insert(std::make_pair(strRealTypeName, pFunc)).second; // 创建键值对
            std::cout << "m_mapCreateFunction.size() =" << m_mapCreateFunction.size() << std::endl;
            return(bReg);
        }

        //& 传入“类名”和参数创建类实例，方法内部通过“类名”从m_mapCreateFunction获得了对应的“实例创建方法（DynamicCreator的CreateObject方法）”完成实例创建操作。
        Actor* Create(const std::string& strTypeName, Targs&&... args){
            std::cout << "Actor* ActorFactory::Create(const std::string& strTypeName, Targs... args)" << std::endl;
            auto iter = m_mapCreateFunction.find(strTypeName);
            if (iter == m_mapCreateFunction.end()){
                return(nullptr);
            }
            else{
                //return(iter->second());
                return(iter->second(std::forward<Targs>(args)...)); //把参数完美转发至实例创建方法。
            }
        }

    private:
        ActorFactory(){std::cout << "ActorFactory construct" << std::endl;}; //私有构造，经典的单例模式
        static ActorFactory<Targs...>* m_pActorFactory;   //静态的单例的本类指针
        std::unordered_map<std::string, std::function<Actor*(Targs&&...)> > m_mapCreateFunction; //存贮映射的数据结构。第二个std::function对象统一存储返回类型是Actor*，入参可变的函数。
    };

    template<typename ...Targs>
    ActorFactory<Targs...>* ActorFactory<Targs...>::m_pActorFactory = nullptr; //静态的单例的本类指针的类外定义并初始化

    template<typename T, typename ...Targs>
    class DynamicCreator{  //*理解为对象工厂
    /*
    我们写自己的业务类的时候，不仅要继承自反射基类，也要继承自这个类。
    继承自这个类的第一个参数就是我们的类名。会通过mangled方法获取到这个字符串
    然后把这个字符串和这个类的CreateObject函数放进去
    */
    public:
        struct Register{
            Register(){
                std::cout << "DynamicCreator.Register construct" << std::endl;
                std::puts(__PRETTY_FUNCTION__);
                char* szDemangleName = nullptr;
                std::string strTypeName; //这个就是类名
                #ifdef __GNUC__
                    szDemangleName = abi::__cxa_demangle(typeid(T).name(), nullptr, nullptr, nullptr);
                #else
                //in this format?:     szDemangleName =  typeid(T).name();
                    szDemangleName = abi::__cxa_demangle(typeid(T).name(), nullptr, nullptr, nullptr);
                #endif
                if (nullptr != szDemangleName){
                    strTypeName = szDemangleName;
                    free(szDemangleName);
                }
                std::cout << strTypeName << std::endl;
                ActorFactory<Targs...>::Instance()->Regist(strTypeName, CreateObject); //通过反射器类实例把类名和创建函数放进去。
            }
            inline void do_nothing()const { }; //!注意这个do_nothing。
        };
        DynamicCreator(){
            std::puts(__PRETTY_FUNCTION__);
            std::cout << "DynamicCreator construct" << std::endl;
            m_oRegister.do_nothing(); //!这里的目的是使用一次我们嵌套类的static对象。这样的话编译器不会优化掉嵌套类静态对象的构造。尤其是分离编译的时候，可能会发生链接错误。
        }
        virtual ~DynamicCreator(){m_oRegister.do_nothing();}; //!这里我就不知道为什么了

        static T* CreateObject(Targs&&... args){ //这个实例创建函数很有意思。别看它返回的是T*，但是由于我们所有的业务代码具体类都需要继承自反射基类。所以说T*是子类指针，而反射器存储的是Actor*父类指针。很自然的多态存储。
            std::cout << "static Actor* DynamicCreator::CreateObject(Targs... args)" << std::endl;
            return new T(std::forward<Targs>(args)...); //一旦调用这个函数，就执行这个new。把传进来的参数再次完美转发至对象类的构造函数。
        }

        virtual void Say(){
            std::cout << "DynamicCreator say" << std::endl;
        }
        static Register m_oRegister; //这里必须要是静态的。注意这是静态成员变量，不是静态局部变量。因为我们把注册的过程放到了Register的构造函数中。细节下面再说。
    };

    template<typename T, typename ...Targs>
    typename DynamicCreator<T, Targs...>::Register DynamicCreator<T, Targs...>::m_oRegister; //成员static变量的类外定义并默认初始化。这一行非常关键。注意这是静态成员变量，不是静态局部变量。


    //下面开始是业务类。第一个是继承自反射基类，然后继承自对象工厂类。对象工厂类第一个模板参数是本类类型，然后依次是构造函数参数类型。
    class Cmd: public Actor, public DynamicCreator<Cmd>{
    public:
        Cmd(){std::cout << "Create Cmd " << std::endl;}
        virtual void Say(){
            std::cout << "I am Cmd" << std::endl;
        }
    };

    class Step: public Actor, DynamicCreator<Step, std::string, int>{
    public:
        Step(const std::string& strType, int iSeq){std::cout << "Create Step " << strType << " with seq " << iSeq << std::endl;}
        virtual void Say(){
            std::cout << "I am Step" << std::endl;
        }
    };

    struct miku:public Actor, DynamicCreator<miku, int, int>{
        miku(int x, int y){
            std::cout <<"miku" << x << y << std::endl;
        }
    };

    class Worker{
    public:
        template<typename ...Targs>
        Actor* CreateActor(const std::string& strTypeName, Targs&&... args){
            Actor* p = ActorFactory<Targs...>::Instance()->Create(strTypeName, std::forward<Targs>(args)...);
            return(p);
        }
    };

}

int main()
{
    neb::Worker W;
    std::cout << "----------------------------------------------------------------------" << std::endl;
    neb::Actor* p1 = W.CreateActor(std::string("neb::Cmd"));
    p1->Say();
    std::cout << "----------------------------------------------------------------------" << std::endl;
    neb::Actor* p2 = W.CreateActor(std::string("neb::Step"), std::string("neb::Step"), 1002);
    p2->Say();
    std::cout << "----------------------------------------------------------------------" << std::endl;
    neb::Actor* p3 = W.CreateActor(std::string("neb::miku"),2,3);
    p3->Say();
    return(0);
}
```



有一些具体的代码内容已经在注释说过了。我们一起看一下执行结果

```text
DynamicCreator.Register construct //静态成员变量类外定义导致的默认初始化。
neb::DynamicCreator<T, Targs>::Register::Register() [with T = neb::Cmd; Targs = {}] //为了好看打出来的
neb::Cmd //strTypeName也就是拿到的类名
static ActorFactory* Instance()//拿到ActorFactory的实例。因为ActorFactory也是单例模式。
ActorFactory construct //构造ActorFactory。因为不同的模板参数是不同的类。所以也是三次。
bool ActorFactory::Regist(const std::string& strTypeName, std::function<Actor*(Targs... args)> pFunc) //注册
m_mapCreateFunction.size() =1 //不知道干啥的。
    
    
DynamicCreator.Register construct
neb::DynamicCreator<T, Targs>::Register::Register() [with T = neb::Step; Targs = {std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, int}]
neb::Step
static ActorFactory* Instance()
ActorFactory construct
bool ActorFactory::Regist(const std::string& strTypeName, std::function<Actor*(Targs... args)> pFunc)
m_mapCreateFunction.size() =1
    
    
DynamicCreator.Register construct
neb::DynamicCreator<T, Targs>::Register::Register() [with T = neb::miku; Targs = {int, int}]
neb::miku
static ActorFactory* Instance()
ActorFactory construct
bool ActorFactory::Regist(const std::string& strTypeName, std::function<Actor*(Targs... args)> pFunc)
m_mapCreateFunction.size() =1
```

上面这一部分是在执行main的第一行代码前执行的。为什么是这个顺序？

首先，我们代码的这一行

```c++
template<typename T, typename ...Targs>
    typename DynamicCreator<T, Targs...>::Register DynamicCreator<T, Targs...>::m_oRegister; //成员static变量的类外定义并且被默认初始化。这一行非常关键。注意这不是静态局部变量
```

非常重要。首先，业务代码有三个类模板。分别继承了不同模板参数的`DynamicCreator`类模板。所以我们有三个不同模板参数的`DynamicCreator`。所以三个不同的类都有自己的`m_oRegister`。同时，`m_oRegister`不是静态局部变量，是静态成员变量。生存周期不同。所以说，我们在类外部的这个对静态成员变量的定义导致了其被**默认初始化**。所以我们看到有三个`DynamicCreator`内部的`Register`的默认构造函数被调用。

在`Register`的默认构造函数中，我们获得到了不同的`T`。然后通过这个`T`，获得到了特殊处理的类名。随后，由于`ActorFactory`也是类模板，所以它也是三份。自然也有三份不同的`m_pActorFactory`，所以也有三个`ActorFactory`的构造函数被调用。然后我们拿到了`ActorFactory`的实例，调用它的`Regist`注册，传入类名和一个函数`CreateObject`。这个函数很特殊，是一个静态的成员函数。别看它返回的是`T*`，但是由于我们所有的业务代码具体类都需要继承自反射基类。所以说`T*`是子类指针，而反射器存储的是一个返回值为`Actor*`（父类指针）的`std::function`对象。很自然的多态存储。这个函数一旦被调用，就会`new`。把传进来的参数再次完美转发至对象类的构造函数。

好了，下面开始看执行部分。

由于我们已经获取到了`ActorFactory`的实例，所以这次在调用中不再构造。然后调用`Create`函数。传入类名和构造函数参数。在这个函数中寻找对应类名的实例创建方法，然后完美转发参数至这个函数。进入到映射器存储的对应类的实例创建方法也就是`CreateObject`函数，`new`一个对应的对象。

这时候，我们刚刚才开始创建对象。随后，这个对象的第一基类也就是反射基类被创建。然后第二基类，也就是对象工厂基类被创建。然后是对象的子类部分。

```text
----------------------------------------------------------------------
static ActorFactory* Instance() //获取实例。由于上面已经构造过ActorFactory了，所以直接拿就可以。
Actor* ActorFactory::Create(const std::string& strTypeName, Targs... args) //正式调用create
static Actor* DynamicCreator::CreateObject(Targs... args) //调用至映射器存储的对应类的CreateObject函数，new一个对应的对象
Actor construct //对应对象的反射基类部分
neb::DynamicCreator<T, Targs>::DynamicCreator() [with T = neb::Cmd; Targs = {}]//为了好看
DynamicCreator construct //对应对象的DynamicCreator基类部分。注意这个和上面的不同。这里是基类的构造。上面执行前的是内部嵌套类静态Register对象的初始化导致的。
Create Cmd //对象子类部分
I am Cmd
----------------------------------------------------------------------
static ActorFactory* Instance()
Actor* ActorFactory::Create(const std::string& strTypeName, Targs... args)
static Actor* DynamicCreator::CreateObject(Targs... args)
Actor construct
neb::DynamicCreator<T, Targs>::DynamicCreator() [with T = neb::Step; Targs = {std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, int}]
DynamicCreator construct
Create Step neb::Step with seq 1002
I am Step
----------------------------------------------------------------------
static ActorFactory* Instance()
Actor* ActorFactory::Create(const std::string& strTypeName, Targs... args)
static Actor* DynamicCreator::CreateObject(Targs... args)
Actor construct
neb::DynamicCreator<T, Targs>::DynamicCreator() [with T = neb::miku; Targs = {int, int}]
DynamicCreator construct
miku23
Actor
```



编译期静态反射，来自[这里](https://netcan.github.io/2020/08/01/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0C-%E7%BC%96%E8%AF%91%E6%9C%9F%E9%9D%99%E6%80%81%E5%8F%8D%E5%B0%84/)，看不懂。



# 动态链接的使用经验

## 运行时动态链接

- 首先拥有动态库源文件，如`chn_lang.cpp`

```c++
#include <iostream>
extern "C"{ //必须使用extern "C"
    void print_cur_language(){
        std::cout << "chinese" << std::endl;
    }
}
```

- 编译源文件

```bash
g++ -c -fPIC chn_lang.cpp -o chn_lang.o
```

- 链接为动态链接库

```bash
g++ -shared chn_lang.o -o libchn_lang.so
```

- 编写主文件

```c++
#include <iostream>
#include <dlfcn.h>
int main() {
    void* handle = dlopen("./libchn_lang.so", RTLD_LAZY);
    if (!handle) {
        std::cout << "Failed to load the library: " << dlerror() << std::endl;
        return 1;
    }
    // 从动态链接库中获取函数指针
    typedef void (*ExampleFunction)();
    ExampleFunction exampleFunc = (ExampleFunction) dlsym(handle, "print_cur_language");
    if (!exampleFunc) {
        std::cout << "Failed to load the function: " << dlerror() << std::endl;
        dlclose(handle);
    return 1;
    }
    // 调用函数
    exampleFunc();
    // 关闭动态链接库
    dlclose(handle);
}
```

- 编译主文件
  - 使用 `g++` 编译器时，使用 `-ldl` 选项是为了链接 `libdl` 库，该库提供了对动态链接库（`.so` 文件）的动态加载和符号解析的支持。


```bash
g++ main.cpp -ldl -o main
```

### 运行时动态链接的好处和坏处

好处是可以自由的加载和卸载所需的动态库。坏处是有些API，比如`dlsym`是采用字符串来进行符号查找，所以`C++`这种带mangling的就会很难受。一般会使用`extern "C"`来强制使用C风格的API，但是这样就不能使用函数重载了。

## 加载时动态链接

根据我目前的学习方式，由于`dlsym`是采用我们拿字符串来进行符号查找，所以C++这种带mangling的就会很难受。

- 首先拥有动态库源文件，如`chn_lang.cpp`

```c++
#include <iostream>
extern "C"{ //如果此处使用了extern "C", 则后面的头文件也需要使用extern "C"注明
    void print_cur_language(){
        std::cout << "chinese" << std::endl;
    }
}
```

- 编译源文件

```bash
g++ -c -fPIC chn_lang.cpp -o chn_lang.o
```

- 链接为动态链接库

```bash
g++ -shared chn_lang.o -o libchn_lang.so
```

- 编写头文件

```c++
#ifndef LANGUAGEHEADER_H
#define LANGUAGEHEADER_H

extern "C" void print_cur_language(); //因为我们上面使用了extern "C"，所以这里也需要
#endif
```

- 编写主文件

```c++
#include <iostream>
#include "languageheader.h"
int main(){
    print_cur_language();
}
```

- 编译主文件并链接至动态链接库

  - ```bash
    g++ main.cpp -l<library1> -l<library2> -o executable
    如
    g++ main.cpp -lchn_lang -o main
    ```
  
  - 如果在使用`-l`指定库文件名称的时候，我们的动态链接库不在标准路径，则需要配置环境变量并添加`-L`指定库文件的目录路径：
  
    - ```bash
      export LD_LIBRARY_PATH=<path_to_library>:$LD_LIBRARY_PATH
      如
      export LD_LIBRARY_PATH=./:$LD_LIBRARY_PATH
      然后
      g++ main.cpp -L./ -lchn_lang -o main
      ```
  
    - 采用`-l`指定库文件名称会帮助我们把动态链接库的前缀`lib`和后缀`.so`补齐，所以此处不需要再添加。
  
    - 搜索路径可以是绝对路径或相对路径。如果是完整的绝对路径（例如 `/path/to/library`），则链接器将使用该路径作为库文件的准确位置。如果是相对路径（例如 `./libraries` 或 `../libs`），则链接器将在当前工作目录下搜索库文件。
  
      ![QQ截图20230619203556](/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230619203556.png)
  
  - 如果我们的库文件的名称并不是标准化，如`lib___.so`形式，则可以在`-l`命令后添加冒号`:`。然后放入库文件的全名附带后缀
  
    - ```bash
      g++ main.cpp -L./ -l:somethingchn_lang.so -o main
      ```

如果此时我们有多个动态链接库文件，并且都有同名符号，则链接顺序和符号强度决定了具体调用的函数。比如：

```bash
g++ main2.cpp -L./ -lchn_lang -leng_lang -o main2
g++ main2.cpp -L./ -leng_lang -lchn_lang -o main2
```

第一种输出`chinese`而第二种输出`english`

具体的一些讨论可以参考这两篇文章：[动态链接库的符号重名问题](https://xuhongxu.com/2018/09/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%AC%A6%E5%8F%B7%E9%87%8D%E5%90%8D%E9%97%AE%E9%A2%98/) 和 [强弱符号和强弱引用](https://www.cnblogs.com/kernel_hcy/archive/2010/01/27/1657411.html)
