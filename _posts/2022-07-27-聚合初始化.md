---
title: 聚合初始化，列表初始化。
date: 2022-07-20 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true
  
---



# 列表初始化（大括号初始化）uniform_initialization

**带等号和不带等号一般不做区分。`int c{5};`是直接列表初始化 ，`int d = {5};`是拷贝列表初始化。 两种形式一般不做区分。**

首先第一点：c++不允许在一个类内使用圆括号初始化另一个类。

```c++
class test{
    int a = 5; 	//拷贝初始化 OK
    int b(5); 	//直接初始化。ERROR。
    int c{5};	//默认类型使用的列表初始化。其实还是调用了对应的构造函数进行了直接初始化。也叫直接列表初始化
    int d = {5}; //和上面那种一般不做区分。一般也不用。但是这个叫做拷贝列表初始化。
};
```



```c++
class test{
    int test_val1;
    int test_val2;
    public:
    test(int x, int y):test_val1(x), test_val2(y){};
    struct obj{
        int _objval;
        int _faf;
        obj(){}
        obj(int x): _objval(x){}		//注意我们obj有自定义构造函数。所以不是聚合体。
    };
    obj inclass_obj1; 		//obj对象使用无参构造函数
    obj inclass_obj2(); 	//这是返回obj类型的函数
    obj inclass_obj3(5); 	//这里表面是使用了obj的有参构造，但是不允许这种行为。因为有二义性。编译器认为这是个返回obj类型的形参为5的函数。但是形参为5是啥玩意？所以一个类内不允许使用圆括号初始化另一个类。也就是不允许使用直接初始化
    //替代方案：
    obj inclass_obj4 = {test_val1}; // 列表初始化(其实还是调用了对应的构造函数) OK //* 注意这里使用了类的有参构造函数。没有使用拷贝构造  //!注意这不是聚合初始化。聚合初始化不能有用户定义的构造函数
    obj inclass_obj5{test_val2}; //列表初始化(其实还是调用了对应的构造函数) OK //* 注意这里使用了类的有参构造函数。没有使用拷贝构造 //!注意这不是聚合初始化。聚合初始化不能有用户定义的构造函数
    obj inclass_obj6 = 5; //该处的初始化方式是隐式调用obj(int)构造函数生成一个临时的匿名对象，再调用拷贝构造函数完成初始化。
    obj inclass_obj7 = obj(5); //显式调用有参构造函数生成一个临时的匿名对象，再调用拷贝构造函数完成初始化 OK

};
```

# 聚合初始化

`(aggregate initialization)`。聚合类型可以进行直接列表初始化。没有构造函数也可以初始化其中的参数。但是聚合类型有如下限制

      1. 数组类型 或
   2. 满足下列条件的类类型（通常是结构体（struct）或者联合体（union））：

      - 没有私有或保护的非静态数据成员
      - 没有用户**提供**（user-provided)的显式的或继承的构造函数，还包括：
        - 没有默认成员初始化器（没有默认构造函数）
      - 没有基类
        - 有一说是没有虚函数，保护的或私有的非静态数据成员的基类也可以是聚合类。
      - 没有虚函数
      - 没有`{}`和`=`直接初始化的非静态数据成员
   3. POD类型数据（此处参见深度探索对象模型笔记）**。注意：POD类型是聚合类型的子集。**

```c++
class test{
    public:
    struct obj{
        int _objval;
    };
    int _val;
    obj inclass_obj;
    test(int x, int y): _val(x), inclass_obj._objval(y){} // 错误。这是构造函数初始化列表。用来初始化的。这里的inclass_obj._objval(y)是赋值操作。不允许。详细说就是，初始化列表只能初始化对象。这里是给一个对象的某个变量赋值。这是错误的。
    test(int x, int y): _val(x), inclass_obj(y){} 	// 错误 obj类没有有参构造函数。
    test(int x, int y): _val(x), inclass_obj(){} 	// 可以 obj类有默认无参构造函数。
    test(int x, int y): _val(x), inclass_obj{y}{} 	// 可以 这里的inclass_obj{y}叫做聚合初始化。注意后面的{}是test构造函数的{}。不要搞混
    
};
```

针对第一行错误代码，我们可以让`obj`自带一个有参构造。然后使用有参构造对`obj`进行初始化。

- 这东西真正牛逼的在这呢。如果聚合体中间有嵌套，你可以不用使用花 括号分割


```c++
struct Aggregate {
    int arr[4];
    int j;
};
int main(){
    Aggregate aggr = {1, 2, 3, 4, 5};
}
```

# 为什么使用列表初始化？

1. 可以使用初始化列表接受任意长度。不想细说了，查查就可以。用得少。除了容器类。

2. 所有场合都可用，比如：

   - 它能表达一组值，来初始化STL容器：

    ```c++
     std::vector<int> v{1, 3, 5};
     std::vector<int> v = {1, 3, 5}; //当然这也可以。
    ```

   - 它能用来给类的非static成员设定默认值（而`()`就不行）上面提到了。：

   ```c++
   class Widget {
   ...
   private:
       int x{0};   // 可以
       int y = 0;  // 可以
       int z(0);   // 不行
   };
   ```

   - 它和`()`都能用于初始化一个uncopyable的对象（而`=`就不行）：

   ```c++
   std::atomic<int> ai1{0};   // 可以
   std::atomic<int> ai2(0);   // 可以
   std::atomic<int> ai3 = 0;  // 不行
   ```

   - 包括替换`make_pair`

   ```c++
   unordered_map<int, int> my_map;
   my_map.insert(make_pair<int, int>(5,10)); //使用make_pair
   my_map.insert({10,20}); //使用uniform_initialization
   ```

   

3. 使用列表初始化初始**内置类型**的变量时，防止类型窄化，避免精度丢失的隐式类型转换。

   ```c++
   int b = 4.4;		//可以。隐式类型转换。
   int c = {5.5};		//不可以，列表初始化防止隐式转换带来的窄化。
   int d{6.6};			//不可以，列表初始化防止隐式转换带来的窄化。
   ```

   什么是类型窄化，列表初始化通过禁止下列转换，对隐式转化加以限制：

   - 从浮点类型到整数类型的转换
   - 从 `long double` 到 `double`或 `float` 的转换，以及从 `double` 到 `float` 的转换，除非源是常量表达式且不发生溢出
   - 从整数类型到浮点类型的转换，除非源是其值能完全存储于目标类型的常量表达式
   - 从整数或无作用域枚举类型到不能表示原类型所有值的整数类型的转换，除非源是其值能完全存储于目标类型的常量表达式

4. 它不会被认为是声明。

   - C++中规定“所有看起来像声明的语句都会被视为声明”，这导致`()`在一些场景下会被视为函数声明，而`{}`则不会：




# 为什么不使用列表初始化？

- 在类有`std::initializer_list`参数的构造函数时，`{}`会有麻烦：`{}`总会被认为是`std::initializer_list`，即使解析出错。
- `auto`会把列表初始化的型别推导为`std::initializer_list`, 值是`{}`内的内容。
  - 参见下方`i11`
  - 注意区别`i12`

- 一个有趣的地方：如果`{}`中没有元素，那么被调用的是默认构造函数，而不是一个空的`std::initializer_list`。如果你真的想传入一个空的`std::initializer_list`，那么这样：

```c++
Widget w4({});
Widget w5{{}};
```

- `std::vector<int>`会有二义性。我们有

```c++
std::vector<int> v1(10, 20);   //使用普通构造函数创建vector，里面有10个元素，初始值为20.
std::vector<int> v2{10, 20};   // 使用初始化列表构造函数，创建一个有两个元素的vector，元素分别为10和20
```

- 同样的情况存在于使用`make`方法进行智能指针的创建之时。`make`方法无法使用列表初始化



# 看一点有意思的事情

```c++
int i1;				//未定义值。undefined value
int i2 = 42;		//拷贝初始化 使用42
int i3(42);			//直接初始化 使用42
int i4 = int();		//拷贝初始化 使用0（默认值）
int i5{42};			//直接列表初始化 使用42
int i6{};			//直接列表初始化 使用0（默认值）
int i7 = {42};		//拷贝列表初始化 使用42
int i8 = {};		//拷贝列表初始化 使用0 （默认值）

auto i9 = 42;  		//使用42初始化，推导为int
auto i10{42};		//使用42初始化，推导为int。[除旧编译器外]
auto i11 = {42};	//使用42初始化std::initializer_list<int>。推导为std::initializer_list<int>
auto i12 = int{42};	//使用42初始化的int来初始化i12, 推导为int

int i13();			//这是函数声明
int i14(7,9);		//这是编译时错误
int i15 = (7,9);	//使用9。这是使用了逗号运算符。
int i16 = int(7,9);	//这是编译时错误

auto i17(7,9);		//这是编译时错误
auto i18 = (7,9);	//使用9，这是使用了逗号运算符。
auto i19 = int(7,9);//这是编译时错误。


//针对不可拷贝和/或不可移动的类型，在C++17以前 如下是不允许的
auto a = std::atomic<int>{9}; //不可拷贝，C++14编译错误。使用了已删除的拷贝构造函数。但是C++17使用了复制省略技术，可以通过编译。

```

- 逗号运算符
  - 整个逗号表达式的值为系列中最后一个表达式的值。
  - 从本质上讲，逗号的作用是将一系列运算按顺序执行。
- 视频中建议不要使用`()`进行初始化。尽可能使用花括号`{}`
- `i10`的原始语义是使用42初始化一个`std::initializer_list<int>`。已在C++14中修复。
- 注意`i11`的等号改变了`auto`推导的类型。初始化阶段使用等号可能会改变变量的类型。
- 剩余auto解释参见杂记3.

## C++17 复制省略技术

参见杂记3

# std::initializer_list

参见杂记3

## 个人理解

- 个人理解。当是聚合类型的时候，看见`{}`是聚合初始化(aggregate initialization)
- 如果不是聚合类型
  - 如果没有`std::initializer_list`构造函数，那么它叫做统一初始化（uniform initialization)
  - 如果有`std::initializer_list`构造函数，那么它在能匹配`std::initializer_list`构造函数的时候就是列表初始化。其他的时候也叫做统一初始化（uniform initialization)

[CppCon 2018: Nicolai Josuttis “The Nightmare of Initialization in C++”](https://www.youtube.com/watch?v=7DTlWPgX6zs)
