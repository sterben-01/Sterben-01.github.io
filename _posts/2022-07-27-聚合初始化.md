---
title: 聚合初始化，列表初始化。
date: 2022-07-20 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true
  
---



# 列表初始化（大括号初始化）

**带等号和不带等号一般不做区分。`int c{5};` 和`int d = {5};` 两种形式一般不做区分。**

首先第一点：c++不允许在一个类内使用圆括号初始化另一个类。

```c++
class test{
    int a = 5; 	//拷贝初始化 OK
    int b(5); 	//直接初始化。ERROR。
    int c{5};	//默认类型使用的列表初始化。其实还是调用了对应的构造函数进行了直接初始化。
    int d = {5}; //和上面那种一般不做区分。一般也不用。
};
```



```c++
class test{
    int test_val1;
    int test_val2;
    public:
    test(int x, int y):test_val1(x), test_val2(y){};
    struct obj{
        int _objval;
        int _faf;
        obj(){}
        obj(int x): _objval(x){}		//注意我们obj有自定义构造函数。所以不是聚合体。
    };
    obj inclass_obj1; 		//obj对象使用无参构造函数
    obj inclass_obj2(); 	//这是返回obj类型的函数
    obj inclass_obj3(5); 	//这里表面是使用了obj的有参构造，但是不允许这种行为。因为有二义性。编译器认为这是个返回obj类型的形参为5的函数。但是形参为5是啥玩意？所以一个类内不允许使用圆括号初始化另一个类。也就是不允许使用直接初始化
    //替代方案：
    obj inclass_obj4 = {test_val1}; // 列表初始化(其实还是调用了对应的构造函数) OK //* 注意这里使用了类的有参构造函数。没有使用拷贝构造  //!注意这不是聚合初始化。聚合初始化不能有用户定义的构造函数
    obj inclass_obj5{test_val2}; //列表初始化(其实还是调用了对应的构造函数) OK //* 注意这里使用了类的有参构造函数。没有使用拷贝构造 //!注意这不是聚合初始化。聚合初始化不能有用户定义的构造函数
    obj inclass_obj6 = 5; //该处的初始化方式是隐式调用obj(int)构造函数生成一个临时的匿名对象，再调用拷贝构造函数完成初始化。
    obj inclass_obj7 = obj(5); //显式调用有参构造函数生成一个临时的匿名对象，再调用拷贝构造函数完成初始化 OK

};
```

# 聚合初始化

`(aggregate initialization)`。聚合类型可以进行直接列表初始化。没有构造函数也可以初始化其中的参数。但是有如下限制
   1. 数组类型 或

   2. 满足下列条件的类类型（通常是结构体（struct）或者联合体（union））：

      - ​        没有私有或保护的非静态数据成员

      - ​        没有用户提供的构造函数

      - ​        没有基类

      - ​        没有虚函数

      - ​        没有`{}`和`=`直接初始化的非静态数据成员

      - ​        没有默认成员初始化器（没有默认构造函数）
   3. POD类型数据（此处参见深度探索对象模型笔记）**。注意：POD类型是聚合类型的子集。**

```c++
class test{
    public:
    struct obj{
        int _objval;
    };
    int _val;
    obj inclass_obj;
    test(int x, int y): _val(x), inclass_obj._objval(y){} // 错误。这是构造函数初始化列表。用来初始化的。这里的inclass_obj._objval(y)是赋值操作。不允许。详细说就是，初始化列表只能初始化对象。这里是给一个对象的某个变量赋值。这是错误的。
    test(int x, int y): _val(x), inclass_obj(y){} 	// 错误 obj类没有有参构造函数。
    test(int x, int y): _val(x), inclass_obj(){} 	// 可以 obj类有默认无参构造函数。
    test(int x, int y): _val(x), inclass_obj{y}{} 	// 可以 这里的inclass_obj{y}叫做聚合初始化。注意后面的{}是test构造函数的{}。不要搞混
    
};
```

针对第一行错误代码，我们可以让`obj`自带一个有参构造。然后使用有参构造对`obj`进行初始化。

这东西真正牛逼的在这呢。如果聚合体中间有嵌套，你可以不用使用花 括号分割

```c++
struct Aggregate {
    int arr[4];
    int j;
};
int main(){
    Aggregate aggr = {1, 2, 3, 4, 5};
}
```

# 为什么使用列表初始化？

1. 可以使用初始化列表接受任意长度。不想细说了，查查就可以。用得少。除了容器类。

2. 所有场合都可用，比如：

   - 它能表达一组值，来初始化STL容器：

    ```c++
     std::vector<int> v{1, 3, 5};
    ```

   - 它能用来给类的非static成员设定默认值（而`()`就不行）上面提到了。：

   ```c++
   class Widget {
   ...
   private:
       int x{0};   // 可以
       int y = 0;  // 可以
       int z(0);   // 不行
   };
   ```

   - 它和`()`都能用于初始化一个uncopyable的对象（而`=`就不行）：

   ```c++
   std::atomic<int> ai1{0};   // 可以
   std::atomic<int> ai2(0);   // 可以
   std::atomic<int> ai3 = 0;  // 不行
   ```

   

3. 使用列表初始化初始**内置类型**的变量时，防止类型窄化，避免精度丢失的隐式类型转换。

   ```c++
   int b = 4.4;		//可以。隐式类型转换。
   int c = {5.5};		//不可以，列表初始化防止隐式转换带来的窄化。
   int d{6.6};			//不可以，列表初始化防止隐式转换带来的窄化。
   ```

   什么是类型窄化，列表初始化通过禁止下列转换，对隐式转化加以限制：

   - 从浮点类型到整数类型的转换
   - 从 long double 到 double 或 float 的转换，以及从 double 到 float 的转换，除非源是常量表达式且不发生溢出
   - 从整数类型到浮点类型的转换，除非源是其值能完全存储于目标类型的常量表达式
   - 从整数或无作用域枚举类型到不能表示原类型所有值的整数类型的转换，除非源是其值能完全存储于目标类型的常量表达式

4. 它不会被认为是声明。

C++中规定“所有看起来像声明的语句都会被视为声明”，这导致`()`在一些场景下会被视为函数声明，而`{}`则不会：

```c++
Widget w1(10);      // 调用有参构造。
Widget w2();        // 声明了一个无参，名为w2返回Widget的函数
Widget w3{};        // 调用无参构造
```

# 为什么不使用列表初始化？

- 在类有`std::initializer_list`参数的构造函数时，`{}`会有麻烦：`{}`总会被认为是`std::initializer_list`，即使解析出错。
- `auto`会把列表初始化的性别推导为`std::initializer_list`, 值是`{}`内的内容。
- 一个有趣的地方：如果`{}`中没有元素，那么被调用的是默认构造函数，而不是一个空的`std::initializer_list`。如果你真的想传入一个空的`std::initializer_list`，那么这样：

```
Widget w4({});
Widget w5{{}};
```

- `std::vector<int>`会有二义性。我们有

```c++
std::vector<int> v1(10, 20);   //使用普通构造函数创建vector，里面有10个元素，初始值为20.
std::vector<int> v2{10, 20};   // 使用初始化列表构造函数，创建一个有两个元素的vector，元素分别为10和20
```

- 同样的情况存在于使用`make`方法进行智能指针的创建之时。`make`方法无法使用列表初始化
