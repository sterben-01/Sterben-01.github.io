---
title: C++ 杂记
date: 2022-07-15 15:50:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true

---

# C++ 杂记

```c++
 1 #include <iostream>  
 2 #include <cstring>  
 3 using namespace std;
 4 class ClassTest
 5 {
 6 public:
 7     ClassTest()
 8     {
 9         c[0] = '\0';
10         cout << "ClassTest()" << endl;
11     }
12     ClassTest& operator=(const ClassTest &ct)
13     {
14         strcpy(c, ct.c);
15         cout << "ClassTest& operator=(const ClassTest &ct)" << endl;
16         return *this;
17     }
18     ClassTest(ClassTest&& ct)
19     {
20         cout << "ClassTest(ClassTest&& ct)" << endl;
21     }
22     ClassTest & operator=(ClassTest&& ct)
23     {
24         strcpy(c, ct.c);
25         cout << "ClassTest & operator=(ClassTest&& ct)" << endl;
26         return *this;
27     }
28     ClassTest(const char *pc)
29     {
30         strcpy(c, pc);
31         cout << "ClassTest (const char *pc)" << endl;
32     }
33     //private:  
34     ClassTest(const ClassTest& ct)
35     {
36         strcpy(c, ct.c);
37         cout << "ClassTest(const ClassTest& ct)" << endl;
38     }
39     virtual  int ff()
40     {
41         return 1;
42     }
43 private:
44     char c[256];
45 };
46 ClassTest f1()
47 {
48     ClassTest c;
49     return c;
50 }
51 void f2(ClassTest ct)
52 {
53     ;
54 }
55 int main()
56 {
57     ClassTest ct1("ab");//直接初始化  
58     ClassTest ct2 = "ab";//复制初始化  
59     ClassTest ct3 = ct1;//复制初始化  
60     ClassTest ct4(ct1);//直接初始化  
61     ClassTest ct5 = ClassTest("ab");//复制初始化  
62     ClassTest ct6 = f1(); 
63     f1();
64     f2(ct1);
65     return 0;
66 }
```



（1）什么是拷贝初始化（也称为复制初始化）：将一个已有的对象拷贝到正在创建的对象，如果需要的话还需要进行类型转换。拷贝初始化发生在下列情况：

1. 使用赋值运算符定义变量
2. 将对象作为实参传递给一个非引用类型的形参
3. 将一个返回类型为非引用类型的函数返回一个对象
4. 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

 

（2）什么是直接初始化：在对象初始化时，通过括号给对象提供一定的参数，并且要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数

 

（3）在底层实现中，可以看出编译器的思想是能不用临时对象就不用临时对象。因此对于下面这些拷贝初始化，都不会生成临时对象再进行拷贝或移动到目标对象，而是直接通过函数匹配调用相应的构造函数。

```c++
1 ClassTest ct2 ="ab"; //相当于ClassTest ct2("ab");
2 ClassTest ct5 =ClassTest("ab"); //相当于ClassTest ct5("ab")
```

（4）下面的语句，visual studio才会生成一个无名的临时对象（位于main函数的栈中），注意：f1的返回值类型是非引用的，f2的形参类型是非引用的。

通常如下三种情况会生成临时对象：

1. 以值的方式给函数传参；（调用拷贝构造）
2. 类型转换；
3. 函数需要返回一个对象时；

```c++
1 f1(); //临时对象用于存储f1的返回值
2 f2(ct1); //临时对象用于拷贝实参，并传入函数
```

而下面则是直接传入赋值表达式左边对象地址，然后再对该对象进行移动拷贝，注意f1返回值类型是非引用的，如果是引用的，则会调用拷贝构造函数。

上面这句话的意思是 把`f1()`作为参数放进`ct6`调用的`operator=`重载函数里。然后这个函数里面把`f1()`函数的返回的对象**移动**到`ct6`

**本质上应该是复制。但是因为这里他写了移动构造所以采用了移动。**

```c++
1 ClassTest ct6 = f1();
```

 

（5）直接初始化和拷贝初始化效率基本一样，因为在底层的实现基本一样，所以将拷贝初始化改为直接初始化效率提高不大。

 

（6）拷贝初始化什么时候使用了移动构造函数：**当你定义了移动构造函数，下列情况将调用移动构造函数**

1. 将一个返回类型为非引用类型的函数返回一个[临时]对象 [并赋值给一个对象]（如上面的`ClassTest ct6 = f1();`)

 

（7）我们需要先知道什么时候调用拷贝构造函数：
1. 当用类一个对象去初始化另一个对象时。
2. 如果函数形参是类对象。
3. 如果函数返回值是类对象，函数执行完成返回调用时。





（8）拷贝初始化什么时候使用拷贝构造函数：
1. 赋值表达式右边是一个对象
2. 直接初始化时，括号内的参数是一个对象
3. 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
4. 将一个返回类型为引用类型的函数返回一个对象
5. 形参为非引用类型的函数，其中是将实参拷贝到临时对象

 

（9）什么时候使用到拷贝赋值运算符：

- 赋值表达式右边是一个左值对象（如果需要，可以调用构造函数类型转换，生成一个临时对象）
- 当赋值表达式右边是一个右值对象，且没有定义移动赋值运算符函数

 

（10）什么时候使用移动赋值运算符：

- 当赋值表达式右边是一个右值对象，且定义了移动赋值运算符函数

 

（11）即使编译器略过了拷贝/移动构造函数，但是在这个程序点上，拷贝/移动构造函数必须存在且是可访问的（例如：不能是private），如下：

```c++
ClassTest ct2 = "ab";//复制初始化
```

编译器会将其等同下面的语句，调用的是ClassTest的ClassTest(const char *pc)构造函数

```c++
ClassTest ct2("ab");//直接初始化
```

但是ClassTest的拷贝或移动构造函数需要定义至少其中一个，否则会报错



原文地址：

https://www.cnblogs.com/cposture/p/4925736.html

https://nettee.github.io/posts/2018/What-happens-when-return-an-object-by-value-in-Cpp/
