---
title: 智能指针
date: 2022-07-20 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true
  
---



# 智能指针

我们不爱裸指针的原因：

1. 裸指针的声明没办法告诉我们它指向的是单个对象还是数组。
2. 没办法知道用完这个裸指针后要不要销毁它指向的对象。
3. 没办法知道怎么销毁这个裸指针，是用`operator delete`还是什么其它自定义的途径。
4. 参照原因1，没办法知道该用`delete`还是`delete[]`，如果用错了，结果未定义。
5. 很难保证调用路径上恰好销毁这个指针一次，可能内存泄露，也可能double free。
6. 通常没办法知道裸指针是否是空悬指针，即是否指向已销毁的对象。

智能指针就是来解这些问题的，它们用起来像裸指针，但能避免以上的很多陷阱。C++11中有4种智能指针：`std::auto_ptr`、`std::unique_ptr`、`std::shared_ptr`、`std::weak_ptr`。其中`std::auto_ptr`已经过时了，C++11中可以被`std::unique_ptr`取代了。

# `unique_ptr`

`std::unique_ptr`体现了**显式所有权**的语义：非空的`std::unique_ptr`总是拥有它指向的对象；移动一个`std::unique_ptr`会将源指针持有的所有权移交给目标指针；不允许复制`std::unique_ptr`；非空的`std::unique_ptr`总是销毁它持有的资源，默认是通过`delete`。**所以使用 `std::unique_ptr` 管理具备专属所有权的资源**

## 创建指针

```c++
struct myobj{
    myobj(int x):val(x){}
    int val;
};

void deleter(myobj* ptr){
    cout <<"deleter called" << endl;
    delete ptr;        //需要在这里删掉new出来的内容 如果不写的话会内存泄漏。因为智能指针不再执行自己的释放资源的函数。改为执行这个函数。但是这个函数里面如果没有释放资源就会内存泄漏。
    ptr = nullptr;
}


template<typename T>
class mydeleter{ 		//自定义删除器类。functor
    public:
        void operator()(T* ptr) const{
            cout <<"deleter called" << endl;
            delete ptr;        
            ptr = nullptr;
        }
};

int main(){
    unique_ptr<myobj> ptr1;                                         //空指针
    unique_ptr<myobj> ptr2 = new myobj(5);                        	//错误。智能指针构造函数是explicit的。禁止隐式转换，所以不允许拷贝初始化。但是可以用直接初始化
    unique_ptr<myobj> ptr3(new myobj(5));                           //ok
    unique_ptr<myobj, void(*)(myobj*)> ptr4(new myobj(5), deleter); //自定义删除器。注意需要在自定义删除器内部进行资源释放，因为使用自定义删除器后，智能指针不会接管释放资源。注意这里传入的是函数指针，会使unique_ptr整体增大，变成两个指针。正确使用应该是下面那种定义类型。
    unique_ptr<myobj, mydeleter<myobj>> ptr4_1(new myobj(5));       //自定义删除器。注意，这里在尖括号内传入的是仿函数类型。这样会直接使用类型的可调用对象做为删除器。这样效率很高，少一个指针
    //所以写自定义删除器的意义是如果你想在某一个资源的析构函数或者是释放资源的同时执行其他动作，就需要写这个。因为，资源的释放阶段是全部交给智能指针接管的。
    unique_ptr<myobj> ptr5 = make_unique<myobj>(new myobj(5));    	//错误 使用make方法。make_unique是把传入参数完美转发至对象构造函数。只需要传递参数即可，无需再次new。
    unique_ptr<myobj> ptr5 = make_unique<myobj>(5);                 //使用make方法。make方法无法使用自定义删除器和大括号初始化（列表初始化）
    unique_ptr<myobj> ptr5_1(make_unique<myobj>(5)); 				//使用make方法。直接初始化
    unique_ptr<myobj> ptr5(ptr3);                                   //禁止拷贝。因为只能有一个unique_ptr指向一个资源。所有权语义。
    ptr5 = ptr3;													//禁止拷贝赋值。
}         
```

关于`make`方法无法使用大括号初始化（列表初始化）可以用auto先把大括号接住（推导出一个`list initializer`类型），然后把auto声明的变量拿过来用。(使用列表初始化构造)。

**注意，正确使用自定义删除器应该是定义一个类型而不是传入一个函数指针，这也是为什么`unique_ptr`把删除器当作类型一部分的原因**。如果传入函数指针的话，智能指针大小将会是16。因为他会额外包含一个指针。这里最后提到。

### 使用`get()`来获取内部包含的普通指针


```c++
unique_ptr<myobj> ptr5 = make_unique<myobj>(5);   
ptr5.get();
```

#### 所有智能指针都可以通过解引用直接获取值。和普通指针一样。



## release()和reset()

### release()

- `u.release()`是放弃对指针的控制权，返回指针，并将u置空。意思是释放后会返回裸指针，我们可以继续使用。（释放所有权，但是指向的对象不会被销毁）

### reset()

- `u.reset()`释放u指向的对象，并将u置为空。意思是释放后无法继续使用。
- `u.reset(q)`释放u原来指向的对象，令u获取q指向对象的所有权。（q的所有权被接管后会成为空指针）




# `shared_ptr`

`std::shared_ptr`内部有引用计数，被复制时，引用计数+1（因为多个指针指向了同一个对象），有`std::shared_ptr`析构时，引用计数-1，当引用计数为0时，析构持有的对象。引用就是计算有多少个`std::shared_ptr`指向了同一个对象。

引用计数的存在有以下性能影响：

- `std::shared_ptr`的大小是裸指针的两倍：一个指针指向持有的对象，一个指针指向引用计数。
- 引用计数使用的内存必须动态分配，原因是`std::shared_ptr`的引用计数是非侵入式的，必须要独立在对象外面。用`std::make_shared`能避免这次单独的内存分配。
- 引用计数的加减必须是原子的，因此你必须假设读写引用计数是有成本的。

注意，不是所有`std::shared_ptr`的构造都会增加引用计数，移动构造就不会。因此移动构造一个`std::shared_ptr`要比复制一个更快。

与`std::unique_ptr`类似，`std::shared_ptr`的默认销毁动作也是`delete`，且也可以接受自定义的销毁器。但与`std::unique_ptr`不同的是，`std::shared_ptr`的销毁器类型不必作为它的模板参数之一。

因此`std::shared_ptr`要比`std::unique_ptr`使用更灵活，比如不同销毁器的`std::shared_ptr`可以放到同一个容器中，而`std::unique_ptr`则不可以。

另外，不同的销毁器不会改变`std::shared_ptr`的大小。`std::shared_ptr`内部需要为引用计数单独开辟一块内存，那么这块内存中再放一个销毁器也没什么额外开销。实际上这块内存被称为”控制块”，它里面包含以下元素：

- 引用计数
- 弱引用计数
- 其它数据，包括：
  - 自定义销毁器
  - 内存分配器
  - 等等

控制块的创建规则为：

- `std::make_shared`总会创建一个控制块。
- 通过一个独享所有权的指针（如`std::unique_ptr`或`std::auto_ptr`）创建出的`std::shared_ptr`总会创建一个控制块。
- 通过裸指针创建的`std::shared_ptr`会创建控制块。

![shared_ptr](/assets/blog_res/2022-07-28-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/shared_ptr.png)

![QQ截图20220728115439](/assets/blog_res/2022-07-28-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/QQ%E6%88%AA%E5%9B%BE20220728115439.png)



![1449936-20211201093930856-124882834](/assets/blog_res/2022-07-28-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/1449936-20211201093930856-124882834-16591462032631.png)







## 创建指针

```c++
shared_ptr<myobj> ptr1(new myobj(5));       //创建共享指针     
shared_ptr<myobj> ptr2(ptr1);               //通过共享指针直接初始化共享指针。两个指针指向同一个数据，所以不新建控制块。引用计数+1
shared_ptr<myobj> ptr3 = ptr1;              //可以通过赋值方法拷贝初始化共享指针。两个指针指向同一个数据，所以不新建控制块。引用计数+1
cout << ptr1.use_count() << endl;           //使用use_count查看引用计数。输出3
cout << ptr2.use_count() << endl;           //输出3
cout << ptr3.use_count() << endl;           //输出3

shared_ptr<myobj> ptr4 = make_shared<myobj>(5);     //使用make方法创建
shared_ptr<myobj> ptr4_1(make_shared<myobj>(5));    //使用make方法直接初始化
ptr4 = ptr3;                                        //可以拷贝赋值。此时ptr4的控制块引用计数为0。因为被3覆盖了。所以ptr4指向的原始资源析构。ptr4此时和ptr3指向同一资源
cout << ptr4.use_count()<<endl;                     //共享控制块，此时为4。

shared_ptr<myobj> ptr5 = new myobj(4);            	//不可以。禁止隐式转换。智能指针构造函数是explicit的
shared_ptr<myobj> ptr6(new myobj(4), deleter);      //自定义删除器。无需指定类型名。
```

### 使用`get()`来获取内部包含的普通指针


```c++
shared_ptr<myobj> ptr5 = make_shared<myobj>(5);   
ptr5.get();
```

### reset()

- 当函数没有实参时，该函数会使当前 `shared_ptr` 所指堆内存的引用计数减 1，同时将当前对象重置为一个空指针；当为函数传递一个新申请的堆内存时，则调用该函数的` shared_ptr `对象会获得该存储空间的所有权，并且引用计数的初始值为 1。


举例:

```c++
shared_ptr<int> p1 = make_shared<int>(5);		//创建指针
p1.reset();										//它将引用计数减少1，同时将当前对象重置为一个空指针。如果引用计数变为0，则释放内存并且删除指针。
p1.reset(new int(34));							//它将原对象引用计数减少1后指向新空间。
```

#### unique()

- 判断是否还有其他的共享指针指向当前指针指向的对象。

## 注意事项

**通过一个裸指针创建两个`std::shared_ptr`，会创建两个控制块，进而导致这个裸指针会被析构两次！**所以

1. 不要直接用裸指针构造`std::shared_ptr`，尽量用`std::make_shared`。当然在需要自定义的销毁器时不能用`std::make_shared`。

2. 非要用裸指针构造`std::shared_ptr`的话，尽量直接new，不要传入已有的裸指针变量。比如

   ```c++
   myobj* ptr1 = new myobj(1); 
   shared_ptr<myobj> ptr2(ptr1);	//ptr2有控制块
   shared_ptr<myobj> ptr3(ptr1);	//ptr3也有控制块！这样会创建第二个。
   
   //所以尽量直接这样new
   shared_ptr<myobj> ptr4(new myobj(1));
   ```

- 有一种场景下，我们可能无意间创建了对应同一指针的两个控制块。

```c++
std::vector<std::shared_ptr<Widget>> processedWidgets;
```

`processedWidgets`表示所有处理过的`Widget`。进一步假设`Widget`有一个成员函数`process`：

```c++
class Widget {
public:
    ...
    void process() {
        ...
        processedWidgets.emplace_back(this); // this is wrong!
    }
};
```

如果被调用`process`的`Widget`对象本身就被`std::shared_ptr`所管理，上面那行代码会导致它又创建了一个新的控制块。这种情况下我们应该令`Widget`继承自`std::enable_shared_from_this`，它允许创建一个指向自身控制块的`std::shared_ptr`：

```c++
class Widget: public std::enable_shared_from_this<Widget> {
public:
    ...
    void process() {
        ...
        processedWidgets.emplace_back(shared_from_this());
    }
};
```

- 通过栈对象创建`shared_ptr`的时候一定要注意传入自定义删除器（接管资源管理）。因为共享指针在引用计数清零时会去`delete`指向的对象。但此时是个指向栈对象的指针。栈对象不能被`delete`

```c++
class myobj{
    public:
    int val;
    myobj(int x):val(x){}
};

void deleter(myobj* ptr){
    cout <<"deleter called" << endl;
    //这里不能delete了 因为是栈对象。
    ptr = nullptr;
}
int main(){
    myobj s = 100;
    shared_ptr<myobj> ptr1(&s,deleter); //接管资源管理
    cout << (*ptr1).val << endl;
    return 0;
}
```

## 并发安全

**多线程对同一个共享指针“写”是不安全的**

当我们在多线程回调中修改shared_ptr指向的时候。

```c++
void fn(shared_ptr<A>& sp) {
    ...
    if (..) {
        sp = other_sp;
    } else if (...) {
        sp = other_sp2;
    }
}
```

`shared_ptr`内数据指针要修改指向，`sp`原先指向对象的引用计数的值要减去1，`other_sp`指向的引用计数值要加1。**然而这几步操作加起来并不是一个原子操作**，如果多少线程都在修改`sp`的指向的时候，那么有可能会出问题。比如在导致计数在操作减一的时候，其内部的指向，已经被其他线程修改过了。引用计数的异常会导致某个管理的对象被提前析构，后续在使用到该数据的时候触发core dump。

当然如果你没有修改指向的时候，是没有问题的。

https://juejin.cn/post/7038581008945872927


# `weak_ptr`

有时候我们需要一种类似`std::shared_ptr`，但又不参与这个共享对象的所有权的智能指针。这样它就需要能知道共享对象是否已经销毁了。这就是`std::weak_ptr`。**`std::weak_ptr`不是单独存在的，它不能解引用，也不能检测是否为空，它就是配合`std::shared_ptr`使用的**。

`std::weak_ptr`没有解引用和访问成员的功能。也就是不可以操作数据。而且不提供`get()`函数来获得裸指针。它只获得资源的观测权，不共享资源，它的构造不会引起指针引用计数的增加。同样，在`weak_ptr`析构时也不会导致引用计数的减少

一般来说，`weak_ptr`需要通过`shared_ptr`来创建。这样这两个指针会指向同一个数据。但是`weak_ptr`不会涉及到`shared_ptr`的引用计数



### 创建指针

```c++
weak_ptr<myobj> ptr2(ptr1);                 //可以 直接初始化
weak_ptr<myobj> ptr3 = ptr1;                //可以 隐式隐式转换后使用拷贝初始化。
weak_ptr<myobj> ptr4(ptr1);                 //可以 弱指针初始化弱指针
ptr4 = ptr2;                                //可以 拷贝赋值
weak_ptr<myobj> ptr5(new myobj(7));         //不可以使用裸指针初始化弱指针。   

unique_ptr<myobj> ptr7(new myobj(5));
weak_ptr<myobj> test1(ptr7);                //不可以使用unique指针初始化弱指针
```



### reset(), lock(), use_count(), expired()

#### `use_count()`

- `use_count()`返回对应弱指针绑定的共享指针的**强引用计数**。

举例：

```c++
shared_ptr<myobj> ptr1(new myobj(5));       //创建共享指针    
shared_ptr<myobj> ptr2(ptr1);   			//引用计数+1
weak_ptr<myobj> ptr3(ptr1);                 //创建弱指针
cout << ptr2.use_count() << endl;			//输出2
cout << ptr3.use_count() << endl;			//输出2
```



**既然`weak_ptr`并不改变其所共享的`shared_ptr`实例的引用计数，那就可能存在`weak_ptr`指向的对象被释放掉这种情况。这时，就不能使用`weak_ptr`直接访问对象。那么如何判断`weak_ptr`指向对象是否存在呢？使用`lock()` 或 `expired()`来进行判断。**

#### `lock()`

- 它能**原子地**检测对象是否有效。**如果对象存在，`lock()`函数返回一个指向共享对象的`shared_ptr`(引用计数会增1)，否则返回一个空`shared_ptr`。所以`lock()`并不是简单的判断。它是通过查看控制块的强引用计数判断的。

#### `expired()`

- `expired()`函数用来判断所指对象是否已经被销毁。如果`use_count()`是0，则为`true`。

#### reset()

- 将对应的弱指针置空。







# 几种指针的大小

- `unique_ptr`的大小是一个指针或两个指针
  - 一个指针的时候是不使用自定义删除器 或 使用了仿函数作为自定义删除器
  - 两个指针大小的时候是使用了函数指针做为自定义删除器
- `shared_ptr`的大小是两个指针。第一个指针指向的是对象，第二个指针指向的是控制块
- `weak_ptr`的大小是两个指针。**推测原因：**第一个指针指向的是对象，第二个指针指向的是控制块。因为`weak_ptr`和`shared_ptr`，继承自同一个基类 `_Ptr_base`。这个基类有两个变量。一个是对象类型的指针`element_type* _Ptr`, 一个是指向控制块的指针`_Ref_count_base* _Rep`



## `weak_ptr`和`shared_ptr`共享控制块

直到释放为止（手动或超出作用域），无论对应的共享指针和其指向的资源是否存在，弱指针都一直存在。只要弱指针还在，共享指针的控制块的弱引用计数就会在。控制块就不会被释放。所以这会产生下面的一个make方法的缺点。



# `shared_ptr`指针的循环引用问题

如下面代码所示：

```c++
class B;

class A{
    public:
        shared_ptr<B> bptr;
        ~A(){
            cout << "A destory" << endl;
            cout << bptr.use_count() << endl;
        }
};

class B{
    public:
        //weak_ptr<A> aptr;
    	shared_ptr<A> aptr;
        ~B(){
            cout << "B destory" << endl;
            cout << aptr.use_count() << endl;
        }
};



int main(){
    {
        shared_ptr<A> classA(new A());
        shared_ptr<B> classB(new B());
        cout << classA.use_count() << endl;         //1
        cout << classB.use_count() << endl;         //1
        classA->bptr = classB;
        cout << classA.use_count() << endl;         //1
        cout << classB.use_count() << endl;         //2
        classB->aptr = classA;
        cout << classA.use_count() << endl;         //2	//换成弱指针之后这里为1。因为弱指针不计数
        cout << classB.use_count() << endl;         //2
        //所有的析构都不会执行。
       	//换成弱指针，所有析构正常执行。
    }
    return 0;
}

```

当我们在两个类中互相包含一个指向对方类的`shared_ptr`的时候，会发生互相引用。这导致了每一个对象的引用计数都会永远至少保持为1。可以理解为两个指针互相都想让对方放开，但是两个人都必须等对方放开了自己才能放开对方。这样就发生了内存泄漏。

解决方案就是把其中一个类的共享指针换成弱指针。因为弱指针的引用不会增加计数。所以那个类的引用计数会到0从而正确释放。

如上面代码，把B的共享指针换成弱指针即可。






# More Effective C++ 条款21

先做一下介绍，`std::make_shared`是在C++11中增加的，但`std::make_unique`却是在C++14中增加的。如果你想在C++11中就用上`std::make_unique`，自己写一个简单版的也不难：

```c++
template <typename T, typename... Ts>
std::unique_ptr<T> make_unique(Ts&&... params) {
    return std::unique_ptr<T>(new T(std::forward<Ts>(params)...));
}
```

这个版本不支持数组，不支持自定义的销毁器，但这些都不重要，它足够用了。但要记住的是，不要把它放到`namespace std`下面。

这两个make函数的功能就不解释了，和它们类似的还有一个`std::allocate_shared`。

## make方法的优点

- 第一个好处：不需要重复写一遍类型。所有程序员都知道：不要重复代码。代码越少，bug越少。

```c++
auto upw1(std::make_unique<Widget>());
std::unique_ptr<Widget> upw2(new Widget);

auto spw1(std::make_shared<Widget>());
std::shared_ptr<Widget> spw2(new Widget);
```

- 第二个好处：异常安全性。想象我们有两个函数：

```c++
void processWidget(std::shared_ptr<Widget> spw, int priority);
int computePriority();
```

调用代码很可能长成这个样子：

```c++
processWidget(std::shared_ptr<Widget>(new Widget), computePriority()); // potential resource leak!
```

上面这行代码有内存泄漏的风险，为什么？根据C++标准，在`processWidget`的参数求值过程中，我们只能确定下面几点：

- `new Widget`一定会执行，即一定会有一个`Widget`对象在堆上被创建。
- `std::shared_ptr<Widget>`的构造函数一定会执行。
- `computePriority`一定会执行。

`new Widget`的结果是`std::shared_ptr<Widget>`构造函数的参数，因此前者一定早于后者执行。除此之外，编译器不保证其它操作的顺序，即有可能执行顺序为：

1. `new Widget`
2. 执行`computePriority`
3. 构造`std::shared_ptr<Widget>`

如果第2步抛异常，第1步创建的对象还没有被`std::shared_ptr<Widget>`管理，就会发生内存泄漏。

如果这里我们用`std::make_shared`，就能保证`new Widget`和`std::shared_ptr<Widget>`是一起完成的，中间不会有其它操作插进来，即不会有不受智能指针保护的裸指针出现：

```c++
processWidget(std::make_shared<Widget>(), computePriority()); // no potential resource leak
```

- 第三个好处：更高效。

```c++
std:shared_ptr<Widget> spw(new Widget);
```

这行代码中，我们以为只有一次内存分配，实际发生了两次，第二次是在分配`std::shared_ptr`控制块。**我们前文提到过，共享指针的控制块是单独建立在堆上的。多以如果使用直接`new`的方式，在分配完我们想要分配的变量后，系统会再次分配一块空间给控制块。所以分配了两次内存。**

但是如果用`std::make_shared`，它会把`Widget`对象和控制块合并为一次内存分配。**但是这也会成为缺点**

## make方法的缺点

- 第一个缺点：无法传入自定义删除器。

- 第二个缺点：无法使用列表初始化。

- 第三个缺点：对象和控制块分配在一块内存上，减少了内存分配的次数，但也导致对象和控制块占用的内存也要一次回收掉。即，如果还有`std::weak_ptr`存在，控制块就要在（因为控制块中有一块弱引用，储存着弱指针的引用），对象占用的内存也没办法回收。如果对象比较大，且`std::weak_ptr`在对象析构后还可能长期存在，那么这种开销是不可忽视的。也就是假如`shared_ptr`本身被析构了（因为自己和控制块是分开的），`weak_ptr`可能过了很久才被析构。这样这一大块内存就都要存在，因为用`make`方法分配的是一整块

如果我们因为前面这三个缺点而不能使用`std::make_shared`，那么我们要保证，智能指针的构造一定要单独一个语句。回到之前`processWidget`的例子中，假设我们有个自定义的销毁器`void cusDel(Widget* ptr);`，因此不能使用`std::make_shared`，那么我们要这么写来保证异常安全性：

```c++
std::shared_ptr<Widget> spw(new Widget, cusDel);
processWidget(spw, computePriority());
```

但这么写还不够高效，这里我们明确知道`spw`就是给`processWidget`用的，那么可以使用`std::move`，将其转为右值，来避免对引用计数的修改：

```c++
std::shared_ptr<Widget> spw(new Widget, cusDel);
processWidget(std::move(spw), computePriority());
```



# 稍微具体说一下自定义删除器为什么用类的时候不增加大小，用函数指针的时候会增加大小

先看一下`unique_ptr`的析构

```c++
_Compressed_pair<_Dx, pointer> _Mypair; 		//mypair定义。_Dx是自定义删除器类型
~unique_ptr() noexcept {
    if (_Mypair._Myval2) {
        _Mypair._Get_first()(_Mypair._Myval2); // call deleter
    }
}
```

这里用`_Get_first`把`_Mypair`的第一个数据也就是自定义删除器提取出来，然后用`（）`创建临时对象，然后把数据塞入这个临时对象的`operator()`里面完成资源释放。

**但是这个_Compressed_pair**有两个特化版本。

```c++
// store a pair of values, deriving from empty first
template <class _Ty1, class _Ty2, bool = is_empty_v<_Ty1> && 
                                         !is_final_v<_Ty1>>
class _Compressed_pair final : private _Ty1 {
public:
    _Ty2 _Myval2;
    
    // ... the rest of impl
}

// store a pair of values, not deriving from first
template <class _Ty1, class _Ty2>
class _Compressed_pair<_Ty1, _Ty2, false> final {
public:
    _Ty1 _Myval1;
    _Ty2 _Myval2;
    
    // ... the rest of impl
}


```

先看第二个版本，这个很直观，基本就是普通的 `std::pair` 的定义。

而当 `_Ty1` (自定义删除器)是一个空类时，则会特化为第一个版本。这里 `_Ty2` 依然作为一个普通的成员，但 `_Ty1` 却通过继承的方式内嵌到 `_Compressed_pair` 中。乍一看这好像有点不伦不类，毕竟从概念上来说 `_Compressed_pair` 和 `_Ty1` 似乎不应该是继承的关系。但注意这里用的是 private 继承，相较于 public 继承表达的 `is-a` 关系，private 继承隐含的意思其实是 `is-implemented-in-terms-of`，即「由…实现出」。这就说得通了，`_Ty1` 是组成 `_Compressed_pair` 的一部分，反过来 `_Compressed_pair` 是由 `_Ty1` 实现的。这也是为什么很多情况下，组合和 private 继承这两种设计可以互换的原因，详细内容可以参阅 《Effective C++》Item 38。

**空类继承不会增加体积。因为有空基类优化。所以传入一个仿函数（无成员变量，所以是空类）的时候会匹配到第一个模板，使用空基类优化使得不需要额外空间。**

**所以如果自定义删除器传入一个函数指针，因为不是空类而是一个函数指针，会被匹配到第二个模板。所以会把函数指针在`_Ty1 _Myval1;`这里存下来。就多了一个指针。**

## 为什么删除器是unique_ptr的模板参数之一(是类型的一部分)

首先，为了尽可能让`unique_ptr`的性能贴近裸指针，比如在删除器为非函数指针的时候，可以触发空基类优化，使得无需额外空间。其次，主要的一点是`unique_ptr`的删除器是编译时绑定的，所以我们必须显式指定其类型。而`shared_ptr`的删除器是运行期绑定的，所以不需要。正因为共享指针的删除器是编译时绑定，则必须要有一个额外的指针（控制块）指向（保存）删除器来让共享指针可以访问。因为删除器的类型是运行时绑定所以直到运行的时候才能知道。所以调用删除器的时候会有一次额外的寻址操作。

另外，正因为如此，`unique_ptr`的删除器，在使用reset更换的时候只可以更换同类型的删除器。而`shared_ptr`的删除器可以在`reset`的时候随意更换。因为类成员类型在运行期间是不可以改变的。而删除器的类型不是共享指针的一部分。

（此部分参照了c++ primer P.599)

https://fuzhe1989.github.io/2017/05/19/cpp-different-role-of-deleter-in-unique-ptr-and-shared-ptr/
