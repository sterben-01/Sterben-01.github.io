---
title: 深度探索 C++ 对象模型 笔记
date: 2022-08-22 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true
  
---

# 深度探索 C++ 对象模型 笔记

# 1.1

- 类的封装不会给C++带来额外成本。
- 额外成本（时间，空间）来自于虚机制
- 类内只包含非静态成员变量的大小 和 虚机制导致的虚指针（如果有的话）。静态成员变量，所有成员函数都不算作类的大小。此处不再赘述
- 关于虚函数和虚指针，RTTI在单独的笔记有。

# 1.2

- C++优先判断一个语句为声明：当语言无法区分一个语句是声明还是表达式时，就需用用一个 超越语言范围的规则 —— C++优先判断为声明。

小例子就是在声明对象的时候，使用无参构造函数不能加括号

```c++
test test1(); 	//这是声明了一个返回test类型的无参函数
test test1; 	//这才是是声明了一个test对象并使用了无参构造
```

- C++只保证处于同一个 access section 的数据，一定会以声明的次序出现在内存布局当中。 C++标准只提供了这一点点的保证

所以说变长数组（柔性数组，动态数组）这种东西一般只出现在单纯的class/struct里面。

# 2.1构造函数语义学  

## 注意，默认构造函数的意思是，我们没写，编译器认为需要，编译器生成的。这个叫默认构造。 但是我们写了一个构造，无论是有参还是无参，假如我们现在只有一个有参构造，则我们需要无参初始化的时候就要再写一个无参构造。因为只要我们写了任意一个构造，编译器就不会为我们合成默认构造。

- **只有编译器认为需要默认构造的时候才会被合成出来。任何被程序需要的东西，编译器都不负责合成，这是程序员的责任**
- **只有全局变量和静态变量会保证被初始化**，因为他们都是保存在BSS段（如果未初始化或者是初始化为0值）。

- **如果 class A 内含一个或以上的 member objects，那么 A 的 constructor 必须调用每一个 member class 的（默认或对应的）构造函数。没有显式调用，编译器则会扩张构造函数，帮我们调用。**

这句话看起来很抽象，什么意思呢？举个例子

```c++
class test{
    public:
    test(){ cout << "test const" << endl;}
    int val;
};
class test1{
    public:
    int t1val; 		
    test tt;			//test1 内涵test 而不是继承
    test1(){			//显式定义无参构造函数，但是没有显式初始化我们的test对象。
        t1val = 10;
        cout <<"t1const " << endl;
    }
};
int main()
{
    test1 t1;			//声明test1
	return 0;
}
```

我们这里`test1`内涵了一个`test`对象（**如果 class A 内含一个或以上的 member objects**），我们`test1`有自己显式的无参构造函数。但是我们的构造函数没有初始化`test`对象，这怎么办？编译器会帮我们。在我们`test1`的构造函数中会被插入形如`tt.test::test()`这样的一条代码来调用对应的构造函数来初始化`test`对象。（**那么 A 的 constructor 必须调用每一个 member class 的（默认或对应的）构造函数。**）

如果有多个class member objects 都要求constructor初始化操作，将如何? **C++语言要求以“member objects 在 class中的声明顺序”来调用各个constructors。这就是声明 的次序决定了初始化次序（构造函数初始化列表一直要求以声明顺序来初始化）的根本原因！**（当然你实际写的时候逆序也可以，但是编译器依旧会按照声明的顺序去初始化，和你写的顺序没关系，但是可能你这么写会造成一些错误）

**整体来说，就是编译器会扩张 constructors ，在其中安插代码使得在 user code 被调用之前先调 用 member objects 的默认构造函数（当然如果需要调用基类的默认构造函数，则放在基类的 默认构造函数调用之后：基类构造函数 -> 成员构造函数 ->user code）。**

带有有 虚函数 的类的默认构造函数毫无疑问是 notrivial 的，需要编译器安插额外的 成员 vptr 并在构造函数中正确的设置好 vptr，这是编译器的重要职责之一。 带有 虚基类 的类的默认构造函数同样也毫无疑问的 notrivial，编译器需要正确设 置相关的信息以使得这些虚基类的信息能够在执行时准备妥当，这些设置取决于编译实现虚基类 的手法。（**一句话：虚基表和虚函数表的存在导致含有虚机制的类在没有构造函数的情况下必须被合成一个默认构造函数**）

## 总结：

编译器**有 4 种情况会使得编译器真正的为 class 生成 nontrivial 的默认构造函数**，这个 nontrivial 的默认构造函数只满足编译器的需要。

1. 调用 member objects 的默认构造函数
2. 调用 base class 的默认构造函数、
3. 初始化 virtual function （虚机制）
4. 初始化 virutal base class （虚机制）
5. **其它情况时，类在概念上拥有默认构造函数，但是实际上根本不会被产生出来**（前面的区分 trivial 和 notrivial）。

## C++新手常见的 2 个误区： 

1. **如果 class 没有定义 default constructor 就会被合成一个； 首先定义了其它的 constructor 就不会合成默认构造函数，再次即使没有定义任何构造函数 也不一定会合成 default constructor，可能仅仅是概念上有，但实际上不合成出来。**
2.  **编译器合成出来的默认构造函数会明确设定每一个 data member 的默认值； 明显不会，区分了 Global objects, Stack objects, Heap objects 就非常明白了只有在 Global 上的 objects （全局或静态变量）会被清 0，其它的情况都不会保证被清 0。**



# 2.2 拷贝构造函数语义学

- **bitwise copy = 浅拷贝**
- **memberwise copy = 深拷贝**

拷贝构造函数 和默认构造函数一样，**只有在必须的时候才会被产生出来**，对于大部分的 class 来说，拷贝构造函数仅仅需要按位拷贝就可以。 满足 bitwise copy semantics 的拷贝构 造函数是 trivial 的，就不会真正被合成出来（与默认构造函数一样，只有 nontrivial 的拷贝构 造函数才会被真正合成出来）。**注意，深拷贝和浅拷贝，也就是拷贝构造函数的正确与否在这里我们是不关心的。我们只关心生成与否。**

**什么时候不满足浅拷贝语义呢？也就是什么时候拷贝构造会被真正的合成出来呢？四种情况**

1. 当class内含一个member object而后者的class声明有一个copy constructor时（不论是被显式地声明，或是被编译器合成）。**一句话：当类内含有另一个类成员，而另一个类成员含有了拷贝构造，无论是声明出来的或者是被合成的。**因为这个类的拷贝构造必须要调用包含的类成员的拷贝构造，执行这个过程则必须生成拷贝构造，然后隐式插入其中。
2. 当class继承自一个base class而后者存在一个copy constructor时（再次强调,不论是被显式声明或是被合成而得）。**一句话：当子类继承父类，父类含有拷贝构造的时候，无论是声明出来的或者是被合成的。**
3. 当class声明了一个或多个virtual functions 时。**（有虚函数时）**
   - 这个就是我们说的，当我们用子类对象给父类对象赋值的时候，会产生切割（slice）。而且在赋值的时候编译器会禁止赋值任何和虚机制相关的东西

![QQ截图20220823200622](/assets/blog_res/2022-08-22-%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.assets/QQ%E6%88%AA%E5%9B%BE20220823200622.png)



**也就是说，合成出来的 父类拷贝构造会显式设定对象的虚函数表指针指向父类自己的虚函数表,而不是直接从右手边的对象 中将其虚函数表指针现值拷贝过来。**



4. 当class派生自一个继承串链，其中有一个或多个virtual base classes时。**（有虚继承时）**
   - **编译器会合成一个拷贝构造函数，安插一些代码用来设定虚基类指针和偏移的初值以及执行其他的内存相关工作**

# 2.3 程序转化语义学

NRV优化 杂记2提到了。不赘述

**然后就是，在不需要深拷贝语义的情况下不要瞎鸡巴写拷贝构造。效率低没意义。**



# 2.4 构造函数初始化列

- 构造函数初始化列在初始化的时候就将值做拷贝构造动作。 而不是赋值 assignment。(直接初始化) 直接调用拷贝构造
- 如果不用初始化列表，则会先initialize初始化再做赋值assignment（拷贝）动作。（拷贝初始化） 先调用默认构造，再调用拷贝赋值。
- 比如如果构造函数中存在string，我们在普通情况下会调用默认构造，再调用拷贝赋值。 如果使用初始化列表，则会调用参数最匹配的构造函数进行直接初始化。也就是直接调用拷贝构造

```c++
test(const string& a){ //先调用默认构造函数构造一个临时string变量, 然后把临时变量使用拷贝赋值给val
  val = a;
}
test(const string& a):val(a){} //直接调用string类的拷贝构造，把a复制进去。因为val是个string
```

- 类的构造函数后面跟冒号：系统创建类成员变量的同时初始化（本例中调用拷贝构造函数）。
- 类的构造函数里面等号赋值的方式：系统创建成员变量后（调用默认构造函数后），再进行拷贝赋值。 

## 四种情况必须使用初始化列进行成员的初始化：

1. 常量成员` const`
2. 引用成员` reference`
3. 调用父类的有参构造的时候
4. 调用类内其他类成员的有参构造的时候

## 构造函数初始化列的初始化顺序和初始化列的顺序无关，只和类内变量声明的顺序有关。但是如果顺序错乱，虽然编译层面不会报错，但会导致不可预知的错误

```c++
class test{
    int i;
    int j;
    test(int val):j(val), i(j){}
}
```

**上面的代码看起来像是要把`j`设初值为`val`，再把`i`设初值为`j`。问题在于，由于声明顺序的缘故，初始化列中的`i(j)`其实比`j(val)`更早执行。但因为`j`一开始未有初值，所以`i (j)`的执行结果导致i无法预知其值。**

**除非改成这样：**

```c++
class test{
    int i;
    int j;
    test(int val):j(val){
        i = j;
    }
}
```

因为**初始化列会被放在用户代码之前执行**，也就是这里，我们由于初始化列只初始化`j`，没有`i`, 所以他跳过了`i`先初始化了`j`，然后进入到用户代码块去给`i`初始化。



在初始化列中使用成员函数是合法的，因为和这个对象相关的`this`指针已经被构建。但是要考虑依赖性来避免发生错误。

比如：

```c++
int i;
int value;
int j;
A():i(99),j(100),value(foo());
```

这会不会产生错误取决于成员函数`foo()`是依赖于`i`还是`j`:
如果`foo`依赖于`i`，由于`i`声明在`value`之前，所以不会产生错误﹔
如果`foo`依赖于`j`，由于`j`声明在`value`之后，就产生了使用未初始化成员的错误。

**一句话总结：编译器会一一操作初始化列表，把其中的初始化操作以 member 声明的次序在 constructor 内安插初始化操作，并且在任何 explicit user code 之前。 以 member 声明的次序来决定初始化次序 和 初始化列表中的排列次序 之间的外观错乱，可 能会导致一些不明显的 Bug。**

# 3.3 类成员变量的存取速度

类静态对象无论是通过对象调用还是通过指针调用，没有差距。因为静态对象不属于类。

普通的类对象通过指针调用还是对象调用也没有区别。因为变量地址可以在编译器确定。

当对象地址无法在编译期被确定，比如在有虚机制发生的时候，这时候通过指针调用和对象调用就会有速度差异。这时候对象调用会更快。因为对象调用不会触发多态，而指针调用会触发多态。编译的时候无法确定到底是哪一种类型。

# 3.4 C++ Standard 保证：“出现在派生类中的 base class subobject 有其完整原样性！”
子类会被放在父类的对齐空白字节之后，因为父类的完整性必须得以保证，父类的对齐空白字节也是父类的一部分，也是不可分割的。

举个例子

![QQ截图20220826025225](/assets/blog_res/2022-08-22-%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.assets/QQ%E6%88%AA%E5%9B%BE20220826025225.png)

我们这里可以用如下语句来进行深拷贝（如果定义了深拷贝的拷贝构造/拷贝赋值）

```c++
*pc1_2 = *pc1_1
```

前提是他俩实际上都指向`Concrete1`。如果`pc1_1`实际指向了`Concrete2`或者`Concrete3`，则上述操作应该吧2和3里面的父类部分（1自己的部分）复制给1。

**如果没有padding，那么父类对象这里现在是空白，而子类对象现在这里有值。那么一旦发生子类对象给父类对象赋值的话，父类对象本来应该空的位置会被子类的数据填充，这样就乱套了。所以先补齐是为了保证每一个类的完整性。**

**所以是先补齐，再继承。**



## 关于多态的虚函数表指针应该放在父类的屁股还是放在开头的小讨论

我们讨论过。父类指针指向子类对象，父类指针可以解析的范围仅是子类的父类范围。因为父类指针仅有权限读取并正确解释那么大的区块。而且我们讨论过，虚函数表指针是可以理解成继承（复制）自父类的。属于子类的父类部分。所以在有虚函数表指针的时候，如果放在基类的屁股，则无论是在屁股后增添子类数据成员还是赋值回去造成的slice都比较自然。如果放在开头，则没有多态和有多态的时候，类成员的起始地址会有差异。

## 关于类的成员对象指针可能会在实际偏移量上+1 也就是取类成员地址的偏移量。

![QQ截图20220828073243](/assets/blog_res/2022-08-22-%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.assets/QQ%E6%88%AA%E5%9B%BE20220828073243.png)



我们如果想拿到一个类的成员的地址可以如下面操作：

```c++
class A {
public:
    int a;
};


int main() {
    A obj;
    cout << &A::a << endl; //输出1
    cout << &obj.a << endl;//输出0x61fe1c
    return 0;
}
```

**这里第一种叫做取一个类的非静态成员的地址。这里会输出相对地址。因为这是废话。真实地址要依靠对象来实现。所以这里会输出1。为啥是1不是0？**

**第二种才是叫做取一个类的对象身上的类的成员地址。这里才会输出真实地址。因为是绑定在对象身上的。**

这里的主要意思我想就是，一个空指针会指向0。但是类的成员指针其实是按照对象起始地址的偏移量来计算的（实际储存的是相对于对象起始地址的偏移）。假如刚好偏移量为0，为了区分是空指针还是指向了成员的头部，可能编译器会在指向成员头部指针的具体offset上面+1.

# 4.1 各种成员函数的调用方式

### 注意 类静态成员函数不可以被声明为const。也就是类成员函数不可同时用const和static修饰。

因为const必须是成员函数（需要this指针）。然而static修饰的成员不属于类，（没有this指针）。



## 非静态成员函数和普通函数在调用层面没有性能差别

因为编译器会把每所有的非虚函数（此处不确定是否正确。有的笔记里写的是普通函数，普通成员函数和静态成员函数。书里此处没有提及静态成员函数。）进行处理：

1. 首先是把对象调用的方式改为值调用。也就是在形参的第一个位置放一个this指针（指向对象的指针）做为入参

2. 其次是把函数内对于非静态数据成员的直接操作变成用this指针的操作。

3. 然后是名称重新编译成独特名称（这一步的目的是实现重载。注意，C++重载是依靠名称和参数，C只有名称）
4. 最后是实施NRV优化（如果有）



## 虚函数在调用层面的优化

- 只有触发多态的时候（引用或指针调用虚函数）才会被编译器处理成进行查表（我们提到过虚函数调用其实就是查虚函数表）。**如果没有触发多态（对象调用）则会被编译器按照正常成员函数处理。因为没有触发多态，不查表。**


- **在虚函数内调用虚函数的时候，可能会有一个非常大的优化空间。也就是因为第一层虚函数已经被查表到了，所以自己内部的调用虚函数的操作可能会被直接处理为通过作用域运算符调用对应类的函数。**（这里不太确定）

#### 使用类作用域访问运算符显式调用虚函数会压制虚函数的调用方法（不会查表），调用法会被处理成调用非静态成员函数。



![QQ截图20220828220848](/assets/blog_res/2022-08-22-%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.assets/QQ%E6%88%AA%E5%9B%BE20220828220848.png)

## 静态成员函数的调用法

在进行静态成员函数的调用时，编译器依旧会把它变成一般的非成员函数进行调用。和类的非静态成员函数唯一的区别就是，静态成员函数没有this指针，不需要添加这个形参。

# 4.2 虚成员函数（就是虚函数）

### 单继承部分

第一部分讲的是虚函数表。已经在别的地方说过了此处不赘述。

需要补充的部分：**虚函数表是编译期确定的原因是，我们已经按照顺序对所有的虚函数进行了排列。也就是知道了每一个虚函数表的下标对应的函数是什么。但是唯一一个需要运行期确定的是，我要找哪个表？**

![QQ截图20220829005232](/assets/blog_res/2022-08-22-%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.assets/QQ%E6%88%AA%E5%9B%BE20220829005232.png)

### 多继承部分

在虚函数笔记有写。

**不要在一个 virtual base class 中声明 nonstatic data members。如果一定要这么做，那么你会距离复杂的深渊愈来愈近，终不可拔。**

# 4.3 函数的效能

函数性能测试表明， inline 函数的性能如此之高，比其它类型的函数高的不是一个等级。因为 inline 函数不只能够节省一般函数调用所带来的额外负担，也给编译器提供了程序优化的额外机会

内联函数就是把调用函数的部分换成内联函数的函数体。会造成代码膨胀。而且inline关键词仅仅是建议，编译器不一定会执行。

# 4.4 指向成员函数的指针

## 非虚函数

我们提到过，直接提取非静态成员数据的地址只能拿到类内的偏移量。只有通过对象调用才可访问到真实地址。

成员函数虽然直接提取可以提取到真正的地址，但是此时无法调用，必须绑定到一个对象上之后通过对象调用，因为会被编译器转化成一个带有this指针的函数。需要传入this指针，所以需要对象地址。 

![QQ截图20220831044250](/assets/blog_res/2022-08-22-%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.assets/QQ%E6%88%AA%E5%9B%BE20220831044250.png)





具体在杂记2有介绍。





## 虚函数

 对一个 虚函数取其地址，所能获得的只是一个 虚函数表中的索引值。

## 多重继承或虚继承

过于复杂不说了。

# 4.5 inline

inline 函数扩展时的实际参数取代形式参数的过程，会聪明地引入临时变量来避免重复求值。

假如有如下代码

```c++
inline int minval(int i, int j){
    return  i < j ? i : j;
}

inline int bar(){
    int minval;
    int val1 = 1024;
    int val2 = 2048;
    
    minval = min(val1, val2);		//1
    minval = min(1024, 2048);		//2
    minval = min(foo(), bar()+1);	//3
    return minval;
}
```

对于第一种，会发生参数替换：

```c++
minval = val1 < val2 : val1, val2;
```

对于第二种，替换后直接常量计算。

```c++
minval = 1024;
```

对于第三种，会引发副作用。所以会引入临时变量避免了对这个函数的多次调用。因此，知道编译器会自动的做这些优化，就没有必须自己去画蛇添足的手动引入临时变量了。

```c++
int temp1;
int temp2;
minval = (t1 = foo), (t2 = bar()+1), t1 < t2 ? t1 : t2;
```

**inline 中再调用 inline 函数，可能使得表面上一个看起来很平凡的 inline 却因连锁的复杂性而没有办法扩展开来。在inline函数中的局部变量和有副作用的参数也会导致大量临时对象的产生。编译器不一定可以把他们移除。**



# 5.1

